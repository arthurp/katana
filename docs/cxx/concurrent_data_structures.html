<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Katana: Concurrent Data Structures</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Katana
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('concurrent_data_structures.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Concurrent Data Structures </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#katana_graphs">Parallel Graphs</a><ul><li class="level2"><a href="#lc_graphs">Label-computation Graphs</a><ul><li class="level3"><a href="#lc_graph_tparam">Template Parameters</a></li>
<li class="level3"><a href="#lc_graph_api">APIs</a></li>
<li class="level3"><a href="#lc_graph_storage">Different Storage Formats</a></li>
<li class="level3"><a href="#lc_graph_in_edges">Tracking Incoming Edges</a></li>
</ul>
</li>
<li class="level2"><a href="#morph_graphs">Morph Graphs</a><ul><li class="level3"><a href="#morph_graph_tparam">Template Parameters</a></li>
<li class="level3"><a href="#morph_graph_api">APIs</a></li>
<li class="level3"><a href="#lc_morph_graph">LC_Morph_Graph</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#insert_bag">Insert Bag</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="katana_graphs"></a>
Parallel Graphs</h1>
<p>For graph computation, Galois provides unified, standard APIs to access graph elements as well as a set of graph implementations optimized for NUMA-awareness, conflict detection and interoperability with the Galois runtime system. All graphs are in the namespace katana.</p>
<p> 
<style>div.image img[src="katana_parallel_graphs.png"]{width:70%}</style>
 </p><div class="image">
<img src="katana_parallel_graphs.png" alt=""/>
<div class="caption">
Galois Parallel Graphs</div></div>
<p>There are two types of graphs, summarized pictorially as the above hierarchy. </p><ol>
<li>
<a class="el" href="classkatana_1_1MorphGraph.html" title="A graph that can have new nodes and edges added to it.">katana::MorphGraph</a>: This graph type allows insertion and removal of nodes and edges. It is used in morph algorithms like Delaunay mesh refinement. A variation called <a class="el" href="classkatana_1_1LC__Morph__Graph.html" title="Local computation graph that allows addition of nodes (but not removals) if the maximum degree of a n...">katana::LC_Morph_Graph</a> can be used if (1) node removals are impossible, and (2) when a node is created, its maximum degree is known. </li>
<li>
<a class="el" href="classkatana_1_1LC__CSR__Graph.html" title="Local computation graph (i.e., graph structure does not change).">katana::LC_CSR_Graph</a>: This graph type disallows creation and removal of nodes and edges. Internally, it is implemented with compressed sparse row format, as shown in the following figure. Undirected edges must be represented as two directed edges. Galois also provides variants of this graph with different layouts in memory, e.g. <a class="el" href="classkatana_1_1LC__InlineEdge__Graph.html" title="Local computation graph (i.e., graph structure does not change).">katana::LC_InlineEdge_Graph</a>, <a class="el" href="classkatana_1_1LC__Linear__Graph.html" title="Local computation graph (i.e., graph structure does not change).">katana::LC_Linear_Graph</a>, <a class="el" href="classkatana_1_1LC__InOut__Graph.html" title="Modify a LC_Graph to have in and out edges.">katana::LC_InOut_Graph</a>. </li>
</ol>
<p> 
<style>div.image img[src="csr_format_example.png"]{width:70%}</style>
 </p><div class="image">
<img src="csr_format_example.png" alt=""/>
<div class="caption">
Graph in CSR Format</div></div>
<h2><a class="anchor" id="lc_graphs"></a>
Label-computation Graphs</h2>
<h3><a class="anchor" id="lc_graph_tparam"></a>
Template Parameters</h3>
<p>When defining a <a class="el" href="classkatana_1_1LC__CSR__Graph.html" title="Local computation graph (i.e., graph structure does not change).">katana::LC_CSR_Graph</a>, the following template parameters are required: </p><ol>
<li>
NodeTy: the type of data stored on each node. Use void when no data needs to be stored on nodes. </li>
<li>
EdgeTy: the type of data stored on each edge. Use void when no data needs to be stored on edges. </li>
</ol>
<p>The following features can be enabled using the corresponding graph member type definitions: </p><ol>
<li>
Use <a class="el" href="structkatana_1_1LC__CSR__Graph_1_1with__no__lockable.html#af8912398c391a6eb0470fb5e833f6263">katana::LC_CSR_Graph::with_no_lockable&lt; true &gt;::type</a> to remove abstract node locks and conflict detections. </li>
<li>
Use <a class="el" href="structkatana_1_1LC__CSR__Graph_1_1with__numa__alloc.html#ad5b2fb54a9b336ffe4cbb9697702d3aa">katana::LC_CSR_Graph::with_numa_alloc&lt; true &gt;::type</a> to enable NUMA-aware allocation. </li>
<li>
Use <a class="el" href="structkatana_1_1LC__CSR__Graph_1_1with__out__of__line__lockable.html#a1a0cd6b141474c0f1c1199886a61cbec">katana::LC_CSR_Graph::with_out_of_line_lockable&lt; true &gt;::type</a> to separate node locks from nodes. </li>
</ol>
<p>See <a class="el" href="classkatana_1_1LC__CSR__Graph.html" title="Local computation graph (i.e., graph structure does not change).">katana::LC_CSR_Graph</a> for more details on which template parameters are available and what they mean.</p>
<p>These member type definitions can be chained together to get a graph type with multiple options specified. Below is an example of defining an LC_CSR_Graph with node data of type std::atomic&lt;uint32_t&gt;, edge data of type uint32_t, node locks removed and NUMA-aware allocation enabled:</p>
<div class="fragment"></div><!-- fragment --> <h3><a class="anchor" id="lc_graph_api"></a>
APIs</h3>
<p>The following code snippet shows how to instantiate and read in a graph from a file (in binary gr format):</p>
<div class="fragment"><div class="line">  <a class="code" href="classkatana_1_1TypedPropertyGraph.html">Graph</a> g;</div>
<div class="line">  <a class="code" href="namespacekatana.html#acceb3be91f6608eb0b91434f86f883ce">katana::readGraph</a>(g, argv[1]);  <span class="comment">// argv[1] is the file name for graph</span></div>
<div class="ttc" id="aclasskatana_1_1TypedPropertyGraph_html"><div class="ttname"><a href="classkatana_1_1TypedPropertyGraph.html">katana::TypedPropertyGraph</a></div><div class="ttdoc">A property graph is a graph that has properties associated with its nodes and edges.</div><div class="ttdef"><b>Definition:</b> TypedPropertyGraph.h:33</div></div>
<div class="ttc" id="anamespacekatana_html_acceb3be91f6608eb0b91434f86f883ce"><div class="ttname"><a href="namespacekatana.html#acceb3be91f6608eb0b91434f86f883ce">katana::readGraph</a></div><div class="ttdeci">void readGraph(GraphTy &amp;graph, Args &amp;&amp;... args)</div><div class="ttdoc">Allocates and constructs a graph from a file.</div><div class="ttdef"><b>Definition:</b> ReadGraph.h:38</div></div>
</div><!-- fragment --><p> To access graph elements, use the following constructs. </p><ol>
<li>
Iteration over nodes: use the node iterator <a class="el" href="classkatana_1_1LC__CSR__Graph.html#a9a2fe97428fa80c5b4fbb8ab1812a51f">katana::LC_CSR_Graph::iterator</a> given by <a class="el" href="classkatana_1_1LC__CSR__Graph.html#a92934b1f446615caf918dec82bdffe5a">katana::LC_CSR_Graph::begin</a> and <a class="el" href="classkatana_1_1LC__CSR__Graph.html#a311e04c14a042cb9f4ae344b9a68d546">katana::LC_CSR_Graph::end</a>. </li>
<li>
Iteration over outgoing edges of a node: use the edge iterator <a class="el" href="classkatana_1_1LC__CSR__Graph.html#a40b9a2b53054c133a9f34e4ed892348d">katana::LC_CSR_Graph::edge_iterator</a> given by <a class="el" href="classkatana_1_1LC__CSR__Graph.html#a53081da2ffde97790ddcb85399e207d5">katana::LC_CSR_Graph::edge_begin</a> and <a class="el" href="classkatana_1_1LC__CSR__Graph.html#aa02ca335c90b8cd32b45ee84525a3bac">katana::LC_CSR_Graph::edge_end</a>. By default, the outgoing neighbors of the node are locked by these operations. </li>
<li>
To read/write a node's data: use <a class="el" href="classkatana_1_1LC__CSR__Graph.html#a8fdc3222a3ef4c4110fe7a64067bdb8e">katana::LC_CSR_Graph::getData</a>. By default, the node is locked by this operation. </li>
<li>
To read/write an edge's data: use <a class="el" href="classkatana_1_1LC__CSR__Graph.html#aa444831162fd4eaf8de80167ef7d29d6">katana::LC_CSR_Graph::getEdgeData</a>. </li>
<li>
To access the destination node of an outgoing edge: use <a class="el" href="classkatana_1_1LC__CSR__Graph.html#a43b47e1802691f4ddb30686ccb1f44bc">katana::LC_CSR_Graph::getEdgeDst</a>. </li>
<li>
To query the number of nodes: use <a class="el" href="classkatana_1_1LC__CSR__Graph.html#abed026054b8e80e0d2ffda7c8599eff9">katana::LC_CSR_Graph::size</a>. </li>
<li>
To query the number of outgoing edges: use <a class="el" href="classkatana_1_1LC__CSR__Graph.html#a8f82cc10476d5f1d1e80b6eea96ff1a4">katana::LC_CSR_Graph::sizeEdges</a>. </li>
</ol>
<p>See <a class="el" href="classkatana_1_1LC__CSR__Graph.html" title="Local computation graph (i.e., graph structure does not change).">katana::LC_CSR_Graph</a> for other available APIs, e.g. those for sorting edges for a node and searching for a specific edge.</p>
<p>The following example from <a class="el" href="lonestar_2tutorial_examples_2GraphTraversalSerial_8cpp-example.html">lonestar/tutorial_examples/GraphTraversalSerial.cpp</a> iterates through all nodes, and for each node, adds all outgoing edges' weights to the node data. This example is written in C++11 to avoid mentioning node iterators and edge iterators explicitly.</p>
<div class="fragment"><div class="line">  <span class="comment">// iterate over nodes</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> n : g) {</div>
<div class="line">    <span class="keyword">auto</span>&amp; sum = g.getData(n);  <span class="comment">// get node data of n</span></div>
<div class="line">    sum = 0;</div>
<div class="line">    <span class="comment">// iterate over edges from node n</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : g.edges(n)) {</div>
<div class="line">      sum += g.getEdgeData(e);  <span class="comment">// get edge data of e</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
</div><!-- fragment --><p> To avoid locking nodes and conflict detection, pass <a class="el" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246a937e6a98c210e6d3d0af5ed55de70d3b">katana::MethodFlag::UNPROTECTED</a> to getData(), edge_begin(), edge_end() or edges() as the following example from <a class="el" href="lonestar_2tutorial_examples_2ConflictAwareTorus_8cpp-example.html">lonestar/tutorial_examples/ConflictAwareTorus.cpp</a>:</p>
<div class="fragment"><div class="line">  <span class="comment">// serial verification, no conflict is possible</span></div>
<div class="line">  <span class="keywordtype">size_t</span> numWrongAnswer = 0;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> n : torus) {</div>
<div class="line">    <span class="comment">// use katana::MethodFlag::UNPROTECTED to notify Galois runtime</span></div>
<div class="line">    <span class="comment">// that do not acquire lock for this call</span></div>
<div class="line">    <span class="keywordflow">if</span> (torus.getData(n, <a class="code" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246a937e6a98c210e6d3d0af5ed55de70d3b">katana::MethodFlag::UNPROTECTED</a>) != 4) {</div>
<div class="line">      numWrongAnswer++;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;# nodes of wrong answer: &quot;</span> &lt;&lt; numWrongAnswer &lt;&lt; std::endl;</div>
<div class="ttc" id="anamespacekatana_html_a679ab3b4021187532d65e16ceb3fc246a937e6a98c210e6d3d0af5ed55de70d3b"><div class="ttname"><a href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246a937e6a98c210e6d3d0af5ed55de70d3b">katana::MethodFlag::UNPROTECTED</a></div><div class="ttdeci">@ UNPROTECTED</div></div>
</div><!-- fragment --> <h3><a class="anchor" id="lc_graph_storage"></a>
Different Storage Formats</h3>
<p>Galois provides two variants for <a class="el" href="classkatana_1_1LC__CSR__Graph.html" title="Local computation graph (i.e., graph structure does not change).">katana::LC_CSR_Graph</a>: <a class="el" href="classkatana_1_1LC__InlineEdge__Graph.html" title="Local computation graph (i.e., graph structure does not change).">katana::LC_InlineEdge_Graph</a> and <a class="el" href="classkatana_1_1LC__Linear__Graph.html" title="Local computation graph (i.e., graph structure does not change).">katana::LC_Linear_Graph</a>. They all support the same functionalities but with different storage formats, as shown in the following figure. The differences come from merging arrays in CSR format to enhance spatial locality for certain access patterns.</p>
<p> 
<style>div.image img[src="katana_lc_graphs_example.png"]{width:70%}</style>
 </p><div class="image">
<img src="katana_lc_graphs_example.png" alt=""/>
<div class="caption">
Differences of Galois label-computation graphs</div></div>
<h3><a class="anchor" id="lc_graph_in_edges"></a>
Tracking Incoming Edges</h3>
<p><a class="el" href="classkatana_1_1LC__InOut__Graph.html" title="Modify a LC_Graph to have in and out edges.">katana::LC_InOut_Graph</a> can be used if the desired computation needs to track incoming edges. Below is an example of defining a <a class="el" href="classkatana_1_1LC__InOut__Graph.html" title="Modify a LC_Graph to have in and out edges.">katana::LC_InOut_Graph</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> InnerGraph = <a class="code" href="structkatana_1_1LC__CSR__Graph_1_1with__no__lockable.html">katana::LC_CSR_Graph&lt;int, void&gt;::with_no_lockable</a>&lt; <span class="keyword">true</span> &gt;::type;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="classkatana_1_1TypedPropertyGraph.html">Graph</a> = <a class="code" href="classkatana_1_1LC__InOut__Graph.html">katana::LC_InOut_Graph&lt;InnerGraph&gt;</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="jaccard_8cpp.html#ac56cf62167e787bf1a4ff1e5b529e0b0">GNode</a> = Graph::GraphNode;</div>
<div class="ttc" id="aclasskatana_1_1LC__InOut__Graph_html"><div class="ttname"><a href="classkatana_1_1LC__InOut__Graph.html">katana::LC_InOut_Graph</a></div><div class="ttdoc">Modify a LC_Graph to have in and out edges.</div><div class="ttdef"><b>Definition:</b> LC_InOut_Graph.h:38</div></div>
<div class="ttc" id="ajaccard_8cpp_html_ac56cf62167e787bf1a4ff1e5b529e0b0"><div class="ttname"><a href="jaccard_8cpp.html#ac56cf62167e787bf1a4ff1e5b529e0b0">GNode</a></div><div class="ttdeci">Graph::Node GNode</div><div class="ttdef"><b>Definition:</b> jaccard.cpp:31</div></div>
<div class="ttc" id="astructkatana_1_1LC__CSR__Graph_1_1with__no__lockable_html"><div class="ttname"><a href="structkatana_1_1LC__CSR__Graph_1_1with__no__lockable.html">katana::LC_CSR_Graph::with_no_lockable</a></div><div class="ttdoc">If true, do not use abstract locks in graph.</div><div class="ttdef"><b>Definition:</b> LC_CSR_Graph.h:97</div></div>
</div><!-- fragment --><p>If the graph is not symmetric, then both the original and the transposed binary graphs are required to initialize a <a class="el" href="classkatana_1_1LC__InOut__Graph.html" title="Modify a LC_Graph to have in and out edges.">katana::LC_InOut_Graph</a>, as the following code snippet shows.</p>
<div class="fragment"><div class="line"><a class="code" href="classkatana_1_1TypedPropertyGraph.html">Graph</a> g;</div>
<div class="line"><a class="code" href="namespacekatana.html#acceb3be91f6608eb0b91434f86f883ce">katana::readGraph</a>(g, original_graph_name, transposed_graph_name);</div>
</div><!-- fragment --><p>The functionality of a <a class="el" href="classkatana_1_1LC__InOut__Graph.html" title="Modify a LC_Graph to have in and out edges.">katana::LC_InOut_Graph</a> is the same as the inner LC_Graph, e.g. <a class="el" href="classkatana_1_1LC__CSR__Graph.html" title="Local computation graph (i.e., graph structure does not change).">katana::LC_CSR_Graph</a>. Additionally, it is possible to iterate over incoming edges/neighbors with the following methods. </p><ol>
<li>
To iterate over the incoming edges of a node, use <a class="el" href="classkatana_1_1LC__InOut__Graph_1_1in__edge__iterator.html">katana::LC_InOut_Graph::in_edge_iterator</a> given by <a class="el" href="classkatana_1_1LC__InOut__Graph.html#a0c7573501e4a180d24901289a7347ca0">katana::LC_InOut_Graph::in_edge_begin</a> and <a class="el" href="classkatana_1_1LC__InOut__Graph.html#a52faa3942a86f1e90310f4dd7994cd9c">katana::LC_InOut_Graph::in_edge_end</a>. </li>
<li>
To get access to the destination of an incoming edge, use <a class="el" href="classkatana_1_1LC__InOut__Graph.html#a972cc5f0ae35749d9452eff517fa8254">katana::LC_InOut_Graph::getInEdgeDst</a>. </li>
<li>
To read/write an incoming edge's data, use <a class="el" href="classkatana_1_1LC__InOut__Graph.html#ab7f65d27821dda03bd3ba419093b6158">katana::LC_InOut_Graph::getInEdgeData</a>. </li>
</ol>
<p>The data for incoming edges are stored by value. Users are responsible for maintaining the consistency of outgoing edges and corresponding incoming edges.</p>
<h2><a class="anchor" id="morph_graphs"></a>
Morph Graphs</h2>
<p><a class="el" href="classkatana_1_1MorphGraph.html" title="A graph that can have new nodes and edges added to it.">katana::MorphGraph</a> can be used in cases where an application requires modifying graph topology.</p>
<h3><a class="anchor" id="morph_graph_tparam"></a>
Template Parameters</h3>
<p><a class="el" href="classkatana_1_1MorphGraph.html" title="A graph that can have new nodes and edges added to it.">katana::MorphGraph</a> takes the following template parameters: </p><ol>
<li>
NodeTy: the type of data stored on nodes. Use void if there is no data stored on nodes. </li>
<li>
EdgeTy: the type of data stored on edges. Use void if there is no data stored on edges. </li>
<li>
Directional: a boolean variable indicating whether this is a directed graph. If not, then each edges will have its symmetric counterpart, all represented as outgoing edges. </li>
<li>
InOut: a boolean variable indicating whether incoming edges are tracked. If Directional and InOut are both true, then each edge will have its incoming counterpart. This is default to false. </li>
</ol>
<p>Note that an edge and its symmetric/incoming counterpart share edge data.</p>
<p>The following features can be enabled using the corresponding graph member type definitions. </p><ol>
<li>
Use <a class="el" href="structkatana_1_1MorphGraph_1_1with__no__lockable.html#af73124db14f4ad3c172303e0c8c87cc6" title="Type with Lockable parameter set according to struct template arg.">katana::MorphGraph::with_no_lockable&lt; true &gt;::type</a> to remove node locks and turn off conflict detection. </li>
<li>
Use <a class="el" href="structkatana_1_1MorphGraph_1_1with__sorted__neighbors.html#a0e7d1a745fa793eb53586f098176d46a" title="Type with sort neighbor parameter set according to struct template arg.">katana::MorphGraph::with_sorted_neighbors&lt; true &gt;::type</a> to have the edge lists of nodes always sorted. </li>
</ol>
<p>Below is an example of defining a directed <a class="el" href="classkatana_1_1MorphGraph.html" title="A graph that can have new nodes and edges added to it.">katana::MorphGraph</a> with integer node data, no edge data, and no tracking incoming edges. Neighbors of each node are always sorted.</p>
<div class="fragment"><div class="line"><span class="comment">// Graph has int node data, void edge data and is directed w/o tracking incoming edges. Neighbors of each node are always sorted.</span></div>
<div class="line"><span class="keyword">using</span> <a class="code" href="classkatana_1_1TypedPropertyGraph.html">Graph</a> = <a class="code" href="structkatana_1_1MorphGraph_1_1with__sorted__neighbors.html">katana::MorphGraph&lt;int,void,true,false&gt;::with_sorted_neighbors</a>&lt;<span class="keyword">true</span>&gt;::type;</div>
<div class="line"><span class="comment">// typedef for graph nodes</span></div>
<div class="line"><span class="keyword">using</span> <a class="code" href="jaccard_8cpp.html#ac56cf62167e787bf1a4ff1e5b529e0b0">GNode</a> = Graph::GraphNode;</div>
<div class="ttc" id="astructkatana_1_1MorphGraph_1_1with__sorted__neighbors_html"><div class="ttname"><a href="structkatana_1_1MorphGraph_1_1with__sorted__neighbors.html">katana::MorphGraph::with_sorted_neighbors</a></div><div class="ttdoc">Struct used to define if neighbors are sorted or not in the graph.</div><div class="ttdef"><b>Definition:</b> MorphGraph.h:304</div></div>
</div><!-- fragment --><h3><a class="anchor" id="morph_graph_api"></a>
APIs</h3>
<p><a class="el" href="classkatana_1_1MorphGraph.html" title="A graph that can have new nodes and edges added to it.">katana::MorphGraph</a> supports all the functionalities in <a class="el" href="classkatana_1_1LC__CSR__Graph.html" title="Local computation graph (i.e., graph structure does not change).">katana::LC_CSR_Graph</a> except for size() and sizeEdges(). Additionally, <a class="el" href="classkatana_1_1MorphGraph.html" title="A graph that can have new nodes and edges added to it.">katana::MorphGraph</a> provides the following APIs to modify graph topology:</p>
<ol>
<li>
<a class="el" href="classkatana_1_1MorphGraph.html#a763a66b2f2042e35916b730ccfbcd784" title="Creates a new node holding the indicated data.">katana::MorphGraph::createNode</a> allocates space for node data, and <a class="el" href="classkatana_1_1MorphGraph.html#a4dda7ab5101878267789257c5d1eda03" title="Adds a node to the graph.">katana::MorphGraph::addNode</a> adds to a graph a node already allocated by <a class="el" href="classkatana_1_1MorphGraph.html#a763a66b2f2042e35916b730ccfbcd784" title="Creates a new node holding the indicated data.">katana::MorphGraph::createNode</a>. </li>
<li>
<a class="el" href="classkatana_1_1MorphGraph.html#a30eb71aa044800d42cc253fc38dc7a3b" title="Adds an edge to graph, replacing existing value if edge already exists.">katana::MorphGraph::addEdge</a> and <a class="el" href="classkatana_1_1MorphGraph.html#a31f169c21840aebfdb8874eb21697825" title="Adds and initializes an edge to graph but does not check for duplicate edges.">katana::MorphGraph::addMultiEdge</a> both add an edge between existing nodes in a graph. The former adds an edge only when the edge does not exist, while the latter always adds the edge. The incoming/symmetric counterpart of the edge will also be added if tracked. Lock for an edge's source node is always acquired, and that for the destination node is also acquired if incoming/symmetric edges are tracked. </li>
<li>
<a class="el" href="classkatana_1_1MorphGraph.html#a77f250ac12562b3d67ae47afefd7f7e3" title="Removes a node from the graph along with all its outgoing/incoming edges for undirected graphs or out...">katana::MorphGraph::removeNode</a> removes a node from a graph along with any incoming or outgoing edges associated with that node. Only the node being removed is locked. </li>
<li>
<a class="el" href="classkatana_1_1MorphGraph.html#ad8c54a164a8c819f3d780edde1409269" title="Removes an edge from the graph.">katana::MorphGraph::removeEdge</a> removes an edge from a graph along with its incoming/symmetric counterpart, if there is one. Nodes are locked in the same way as in <a class="el" href="classkatana_1_1MorphGraph.html#a30eb71aa044800d42cc253fc38dc7a3b" title="Adds an edge to graph, replacing existing value if edge already exists.">katana::MorphGraph::addEdge</a>. </li>
</ol>
<p>See <a class="el" href="classkatana_1_1MorphGraph.html" title="A graph that can have new nodes and edges added to it.">katana::MorphGraph</a> for other available APIs for things like sorting the edges of a node and searching for a specific edge.</p>
<p>The following code snippet shows how to add nodes and edges to a <a class="el" href="classkatana_1_1MorphGraph.html" title="A graph that can have new nodes and edges added to it.">katana::MorphGraph</a>. Note that the nodes must be created first, then added to a <a class="el" href="classkatana_1_1MorphGraph.html" title="A graph that can have new nodes and edges added to it.">katana::MorphGraph</a>. Once that is done, edges can be added between the nodes.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div>
<div class="line">constructTorus(<a class="code" href="classkatana_1_1TypedPropertyGraph.html">Graph</a>&amp; g, <span class="keywordtype">int</span> height, <span class="keywordtype">int</span> width) {</div>
<div class="line">  <span class="comment">// Construct set of nodes</span></div>
<div class="line">  <span class="keywordtype">int</span> numNodes = height * width;</div>
<div class="line">  std::vector&lt;GNode&gt; nodes(numNodes);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numNodes; ++i) {</div>
<div class="line">    <a class="code" href="jaccard_8cpp.html#ac56cf62167e787bf1a4ff1e5b529e0b0">GNode</a> n = g.createNode(</div>
<div class="line">        0);        <span class="comment">// allocate node data and initialize the node data with 0</span></div>
<div class="line">    g.addNode(n);  <span class="comment">// add n to g. from now on n can be located from g</span></div>
<div class="line">    nodes[i] = n;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Add edges</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; ++x) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height; ++y) {</div>
<div class="line">      <a class="code" href="jaccard_8cpp.html#ac56cf62167e787bf1a4ff1e5b529e0b0">GNode</a> c = nodes[x * height + y];</div>
<div class="line">      <a class="code" href="jaccard_8cpp.html#ac56cf62167e787bf1a4ff1e5b529e0b0">GNode</a> n = nodes[x * height + ((y + 1) % height)];</div>
<div class="line">      <a class="code" href="jaccard_8cpp.html#ac56cf62167e787bf1a4ff1e5b529e0b0">GNode</a> s = nodes[x * height + ((y - 1 + height) % height)];</div>
<div class="line">      <a class="code" href="jaccard_8cpp.html#ac56cf62167e787bf1a4ff1e5b529e0b0">GNode</a> e = nodes[((x + 1) % width) * height + y];</div>
<div class="line">      <a class="code" href="jaccard_8cpp.html#ac56cf62167e787bf1a4ff1e5b529e0b0">GNode</a> w = nodes[((x - 1 + width) % width) * height + y];</div>
<div class="line">      g.addEdge(c, n);  <span class="comment">// addEdge checks if the edge exists or not. nop if so.</span></div>
<div class="line">      g.addEdge(c, s);</div>
<div class="line">      g.addEdge(c, e);</div>
<div class="line">      g.addEdge(c, w);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p> See the full example at <a class="el" href="lonestar_2tutorial_examples_2TorusConstruction_8cpp-example.html">lonestar/tutorial_examples/TorusConstruction.cpp</a></p>
<h3><a class="anchor" id="lc_morph_graph"></a>
LC_Morph_Graph</h3>
<p>If node removals are not allowed and the maximum degree of a node is known when creating the node, then <a class="el" href="classkatana_1_1LC__Morph__Graph.html" title="Local computation graph that allows addition of nodes (but not removals) if the maximum degree of a n...">katana::LC_Morph_Graph</a> can be used.</p>
<p>The template parameters and features of <a class="el" href="classkatana_1_1LC__Morph__Graph.html" title="Local computation graph that allows addition of nodes (but not removals) if the maximum degree of a n...">katana::LC_Morph_Graph</a> are the same as those of <a class="el" href="classkatana_1_1LC__CSR__Graph.html" title="Local computation graph (i.e., graph structure does not change).">katana::LC_CSR_Graph</a>.</p>
<p>The APIs of <a class="el" href="classkatana_1_1LC__Morph__Graph.html" title="Local computation graph that allows addition of nodes (but not removals) if the maximum degree of a n...">katana::LC_Morph_Graph</a> are the same with those of <a class="el" href="classkatana_1_1MorphGraph.html" title="A graph that can have new nodes and edges added to it.">katana::MorphGraph</a> with the following exceptions. </p><ol>
<li>
<a class="el" href="classkatana_1_1LC__Morph__Graph.html" title="Local computation graph that allows addition of nodes (but not removals) if the maximum degree of a n...">katana::LC_Morph_Graph</a> has no method of removeNode. </li>
<li>
<a class="el" href="classkatana_1_1LC__Morph__Graph.html#ac23a4b7cfd54a8a61ce44bc85323b4da" title="Creates a new node with a cap on the number of edges.">katana::LC_Morph_Graph::createNode</a> will allocate node data and add the node to the graph. </li>
<li>
If a <a class="el" href="classkatana_1_1LC__Morph__Graph.html" title="Local computation graph that allows addition of nodes (but not removals) if the maximum degree of a n...">katana::LC_Morph_Graph</a> is meant to be symmetric, then the user is responsible for maintaining the symmetry. In particular, this matters when using the following functions: <ul>
<li>
<a class="el" href="classkatana_1_1LC__Morph__Graph.html#a7953b1301c8c8442fb595d7aeb37c842" title="Adds an edge if it doesn&#39;t already exist.">katana::LC_Morph_Graph::addEdge</a> </li>
<li>
<a class="el" href="classkatana_1_1LC__Morph__Graph.html#aefaad0b0260897b06a1499335b1febf5" title="Construct a new edge for a node.">katana::LC_Morph_Graph::addMultiEdge</a> </li>
<li>
<a class="el" href="classkatana_1_1LC__Morph__Graph.html#ab83bbac8f6c76ac5547e3cdda5c1541b" title="Remove an edge from the graph.">katana::LC_Morph_Graph::removeEdge</a> </li>
<li>
<a class="el" href="classkatana_1_1LC__Morph__Graph.html#ab741e37a6b188315bdd3c74889fb05f5" title="Get edge data of an edge given an iterator to the edge.">katana::LC_Morph_Graph::getEdgeData</a> for writes. </li>
</ul>
</li>
</ol>
<p>Since symmetry is maintained by the user, only the lock for the source node of an edge is acquired when calling <a class="el" href="classkatana_1_1LC__Morph__Graph.html#a7953b1301c8c8442fb595d7aeb37c842" title="Adds an edge if it doesn&#39;t already exist.">katana::LC_Morph_Graph::addEdge</a>, <a class="el" href="classkatana_1_1LC__Morph__Graph.html#aefaad0b0260897b06a1499335b1febf5" title="Construct a new edge for a node.">katana::LC_Morph_Graph::addMultiEdge</a>, and <a class="el" href="classkatana_1_1LC__Morph__Graph.html#ab83bbac8f6c76ac5547e3cdda5c1541b" title="Remove an edge from the graph.">katana::LC_Morph_Graph::removeEdge</a>.</p>
<h1><a class="anchor" id="insert_bag"></a>
Insert Bag</h1>
<p><a class="el" href="classkatana_1_1InsertBag.html" title="Unordered collection of elements.">katana::InsertBag</a> is an unordered collection that allows parallel insertions. It uses customized memory allocations to achieve scalable parallel insertions.</p>
<p><a class="el" href="classkatana_1_1InsertBag.html" title="Unordered collection of elements.">katana::InsertBag</a> expects a template parameter, T, for the type of elements that the <a class="el" href="classkatana_1_1InsertBag.html" title="Unordered collection of elements.">katana::InsertBag</a> contains. See <a class="el" href="classkatana_1_1InsertBag.html" title="Unordered collection of elements.">katana::InsertBag</a> for other optional template parameters.</p>
<p><br  />
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="Manual.html">Manual</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
