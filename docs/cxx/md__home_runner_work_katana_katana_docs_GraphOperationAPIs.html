<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Katana: Exposing Graph Operations to Users</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Katana
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__home_runner_work_katana_katana_docs_GraphOperationAPIs.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Exposing Graph Operations to Users </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Author:</b> Arthur Peters (arthurp, amp)</p>
<p><b>Note:</b> Due to doxygen processing things weirdly, this file has a backslash before every at-sign. This is visible on github, but not in the doxygen output. So whatever is shown here "\@" should be read as a single bare at-sign.</p>
<p>Operations are exposed in three steps:</p>
<ol type="1">
<li><a href="#Operation-Arguments">Determine the arguments the operation needs</a> and the properties of those arguments,</li>
<li><a href="#c-api">Define a C++ API for the operation</a> using a set of conventions defined below,</li>
<li><a href="#Cython-wrapper-for-Python">Wrap that API using Cython</a> to expose the operation to Python.</li>
</ol>
<p>The API uses a plan to represent the choice of algorithm and any parameters for that algorithm.</p>
<p>No part of the API uses templates because those make it difficult to access from Python.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Operation Arguments</h1>
<p>The operation arguments are split into two categories:</p>
<p><b>Plan arguments</b> which do not affect the result (beyond potentially returning a different valid result in the case of non-deterministic algorithms). For example, the tile size of an algorithm. These arguments will affect performance and are included in the plan.</p>
<p><b>Functional arguments</b> which specify the requested result. For example, the starting node for SSSP. Many operations will accept an output property name for the output data, and/or input property names to use in the algorithm (e.g., edge weights). These names should be passed as a <code>const std::string&amp;</code>. These arguments affect output values and are passed as normal argument to the operation.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
C++ API</h1>
<p>The C++ API for operations contains 4 components:</p>
<ol type="1">
<li>A <code>Plan</code> class that specifies the algorithm and any plan arguments associated with it.</li>
<li>The operation function itself, taking a <code>PropertyGraph*</code>, functional arguments, and a <code>Plan</code>.</li>
<li>Optionally, an <code>AssertValid</code> function, taking a <code>PropertyGraph*</code>, functional arguments, but no <code>Plan</code>.</li>
<li>Optionally, a <code>Statistics</code> struct that contains any notable graph wide statistics that can be computed from the result of the operation. It has a static <code>Compute</code> method taking a <code>PropertyGraph*</code>, functional arguments, but no <code>Plan</code>.</li>
</ol>
<p>All functions return <code><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb" title="A Result is a T or an ErrorInfo.">katana::Result</a></code> objects to handle errors. In general, the operation will not return any value itself and so will have return type <code>katana::Results&lt;void&gt;</code>.</p>
<p>The operation header and implementation files should be placed as you would other C++ files in the appropriate library. If the operation is going in <code>libgalois</code> the operations are placed in subdirectories. Look at <code>libgalois/{src,include}/katana/analytics</code> for examples.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Plan</h2>
<p>The Plan class should contain any enums or constants used in the plan arguments as public static members. It should have a zero-argument constructor which creates a reasonable default plan. Other constructors may exists to automatically create plans based on other information; for instance, a constructor may take a graph and make algorithm choices based on properties of that graph. Any plan arguments should be stored in private fields of the plan, and have public const accessors.</p>
<p>The Plan class should contain static constructor methods for each general algorithm. The methods should accept any plan arguments associated with that algorithm. All the arguments should have reasonable default values. The argument defaults should be public static constants on the class. "Automatic" plans (which make algorithmic choices at operation execution time) should not have a static constructor method and instead be created using the class constructor.</p>
<p>The Plan class should subclass <code>Plan</code>. To allow for easier future expansion to GPU and distributed execution, the base class <code>Plan</code> has a plan argument <code>architecture</code> which should be set to <code>kCPU</code> for the moment.</p>
<p>The outline of the C++ plan is as follows:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">class [Operation]Plan : public Plan {</div>
<div class="line">public:</div>
<div class="line">  enum Algorithm {</div>
<div class="line">    [Algo1],</div>
<div class="line">    [...]</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  static const int kDefault[plan argument] = [...];</div>
<div class="line">  [...]</div>
<div class="line"> </div>
<div class="line">private:</div>
<div class="line">  Algorithm algorithm_;</div>
<div class="line">  [... Other plan arguments ...]</div>
<div class="line"> </div>
<div class="line">  [Operation]Plan(</div>
<div class="line">      Architecture architecture, Algorithm algorithm, ...)</div>
<div class="line">      : Plan(architecture),</div>
<div class="line">        algorithm_(algorithm),</div>
<div class="line">        [...]</div>
<div class="line">        {}</div>
<div class="line"> </div>
<div class="line">public:</div>
<div class="line">  [Operation]Plan() : [Operation]Plan{kCPU, [default algo], kDefault[arg], ...} {}</div>
<div class="line"> </div>
<div class="line">  [Operation]Plan(const katana::PropertyGraph* pg) : Plan(kCPU) {</div>
<div class="line">    ...</div>
<div class="line">    if ([properties]) {</div>
<div class="line">      *this = [Algo1]();</div>
<div class="line">    } else {</div>
<div class="line">      *this = [Algo2]();</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  Algorithm algorithm() const { return algorithm_; }</div>
<div class="line">  [...]</div>
<div class="line"> </div>
<div class="line">  static [Operation]Plan [Algo1](</div>
<div class="line">      unsigned arg = kDefault[arg], [...]) {</div>
<div class="line">    return {kCPU, k[Algo1], arg, [...]};</div>
<div class="line">  }</div>
<div class="line">  [...]</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md4"></a>
Operation Function</h2>
<p>The operation function takes a graph, any functional arguments, and a plan. It should return <code>katana::Results&lt;void&gt;</code>. If there are graph wide results (such as, the triangle count), the function may replace <code>void</code> with an appropriate value.</p>
<p>The operation should not modify the graph except to add the output properties and to add/remove ephemeral properties used during the algorithm. If the algorithm must change the graph (for instance, to sort nodes or edges), it should copy the graph before making such changes and then copy any output property back to the original graph (with appropriate transformation) before it returns.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">KATANA_EXPORT Result&lt;void&gt; [Operation](</div>
<div class="line">    PropertyGraph* pg, [... functional arguments ...], [Operation]Plan plan = {});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md5"></a>
Validity checking function</h2>
<p>The <code>AssertValid</code> function should perform a fast check to see if the output of the operation is as expected. It will generally have false positives (cases where it could return no error when the data is in fact wrong).</p>
<p>It generally takes the same arguments as the operation except for the plan. It can omit some functional arguments if they can be inferred from the data being checked. It returns <code><a class="el" href="namespacekatana.html#a9d227598262d7bcbd17e8270fdc25d56ac7bca54dd788dd9a141de983df16916d">katana::ErrorCode::AssertionFailed</a></code> if the output is not as expected.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">KATANA_EXPORT Result&lt;void&gt; [Operation]AssertValid(</div>
<div class="line">    PropertyGraph* pg, [... functional arguments ...]);</div>
</div><!-- fragment --><p>This function can be omitted if there is no good way to check the results of the algorithm quickly.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Statistics</h2>
<p>The Statistics struct analyzes the output of the operation and produces useful statistics about the graph as a whole. The struct can <code>Print</code> itself (by default to <code>stdout</code> for debugging). The values are accessible directly as fields. Useful values computed from the fields can be included using small computed accessor methods.</p>
<p>The struct is created using a <code>Compute</code> static method on the struct. It generally takes the same arguments as the operation except for the plan. It can omit some functional arguments if they can be inferred from the data being checked.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">struct KATANA_EXPORT [Operation]Statistics {</div>
<div class="line">  [... statistics ...]</div>
<div class="line"> </div>
<div class="line">  [... computed statistics methods ...]</div>
<div class="line"> </div>
<div class="line">  /// Print the statistics in a human readable form.</div>
<div class="line">  void Print(std::ostream&amp; os = std::cout) const;</div>
<div class="line"> </div>
<div class="line">  static katana::Result&lt;[Operation]Statistics&gt; Compute(</div>
<div class="line">      PropertyGraph* pg, [... functional arguments ...]);</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md7"></a>
Documentation</h2>
<p>The following elements should be documented, but you can document other things of course.</p>
<ol type="1">
<li>Every constructor and static method constructor on the Plan.</li>
<li>The operation function.</li>
<li>Every member of the Statistics struct.</li>
</ol>
<h2><a class="anchor" id="autotoc_md8"></a>
Complete Example: SSSP</h2>
<p>See <a href="../libgalois/include/katana/analytics/sssp/sssp.h">libgalois/include/katana/analytics/sssp/sssp.h</a>.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Cython wrapper for Python</h1>
<p>We wrap the above API using Cython to expose it to Python. The Cython code has two sections: A description of the C++ API in Cython, and Python functions and classes written in Cython using that API.</p>
<p>The Python wrapper for your operation will go in the Python package (in either the open or enterprise). The operation should appear in a subpackage of <code>katana</code>. The analytics appear in <code><a class="el" href="namespacekatana_1_1analytics.html">katana.analytics</a></code>, and other categories of operation should consider the same convention. Though if there is a reason to place them elsewhere that is fine.</p>
<p><em>Note:</em> Python packages are often deeply nested and this does not have the problems associated with nested C++ namespaces. Python does not implicitly make enclosing package's contents visible.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
C++ API Description</h2>
<p>The description directly parallels the C++ header file (discussed above). It provides the Cython compiler the information it needs to generate C++ code that accesses the API.</p>
<p>To avoid name conflicts, the C++ classes are imported with a leading <code>_</code>. The Python classes have the name with no initial <code>_</code>. Functions do not need this treatment because the python versions are <code>snake_case</code> and do not conflict with the <code>CamelCase</code> C++ functions.</p>
<p>Many C++ types will need to be imported from the Cython <code>libc</code> and <code>libcpp</code> modules with statements like: <code>from libcpp.string cimport string</code> (note **c**import not just import). It may be useful to copy the imports from the <a href="#Complete-Example:-SSSP-Cython">example</a>. Make sure to remove any imports you do not actually use.</p>
<div class="fragment"><div class="line">cdef extern from &quot;[operation header]&quot; namespace &quot;[namespace]&quot; nogil:</div>
<div class="line">    cppclass _[Operation]Plan &quot;[namespace]::[Operation]Plan&quot; (_Plan):</div>
<div class="line">        enum Algorithm:</div>
<div class="line">            k[Algo] &quot;[namespace]::[Operation]Plan::k[Algo]&quot;</div>
<div class="line">            [...]</div>
<div class="line"> </div>
<div class="line">        _[Operation]Plan()</div>
<div class="line">        _[Operation]Plan(const _PropertyGraph * pg)</div>
<div class="line"> </div>
<div class="line">        _[Operation]Plan.Algorithm algorithm() const</div>
<div class="line">        [... Other plan arguments ...]</div>
<div class="line"> </div>
<div class="line">        \@staticmethod</div>
<div class="line">        _[Operation]Plan [Algo]([...])</div>
<div class="line">        [...]</div>
<div class="line"> </div>
<div class="line">    [type] kDefault[Arg] &quot;[namespace]::[Operation]Plan::kDefault[Arg]&quot;</div>
<div class="line">    [...]</div>
<div class="line"> </div>
<div class="line">    Result[void] [Operation](_PropertyGraph* pg, [...], _[Operation]Plan plan)</div>
<div class="line"> </div>
<div class="line">    Result[void] [Operation]AssertValid(_PropertyGraph* pg, [...])</div>
<div class="line"> </div>
<div class="line">    cppclass _[Operation]Statistics  &quot;[namespace]::[Operation]Statistics&quot;:</div>
<div class="line">        [type] [statistic_name]</div>
<div class="line">        [...]</div>
<div class="line"> </div>
<div class="line">        void Print(ostream os)</div>
<div class="line"> </div>
<div class="line">        \@staticmethod</div>
<div class="line">        Result[_[Operation]Statistics] Compute(_PropertyGraph* pg, [...])</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md11"></a>
Wrap the Plan</h2>
<p>First, we wrap any enums in the plan. Most plans will have an <code>Algorithm</code> enum, but the process is the same for any enum. Each enum is declared as a Python class derived from <code>Enum</code>. Each enum value is a member which is assigned the same value as the C++ enum. The Python enum must be declared at the top level because Cython does not support nested classes. Prefix it with <code>_</code> to mark it as internal. We will "export" it as a member of the Python Plan class below.</p>
<div class="fragment"><div class="line">class _[Operation]Algorithm(Enum):</div>
<div class="line">    [Algo1] = _[Operation]Plan.Algorithm.k[Algo1]</div>
<div class="line">    [...]</div>
</div><!-- fragment --><p>The Plan class is an extension class (<code>cdef class</code>) that contains a C++ value and methods that are compiled to native code. The class derives from a Cython base class <code>Plan</code> that parallels the C++ <code>Plan</code> class. It has a native member <code>underlying_</code> which is a C++ plan and a method <code>underlying</code> that returns a pointer to the C++ base class (called <code>_Plan</code> here to avoid name conflicts). We also have a class member <code>Algorithm</code> that is set to the actual algorithm Enum class (yes, classes are just value in Python so you can assign them to members).</p>
<p>The operation's Plan class has the following methods:</p>
<ul>
<li>A utility method <code>make</code> which constructs a Python Plan from a C++ Plan. This can be copied directly into your code, only providing the type name.</li>
<li>A Python property (<code>\@property</code>) for each plan argument. These may need to convert the C++ value to a Python form.</li>
<li>A constructor (<code>__init__</code>) handling all constructors of the C++ Plan. This may require conditionally calling different C++ constructors. Default arguments do not require overloading though, the default values are just provided to Python as well (this is why we make public constants for the defaults). The arguments may need to be converted from Python to C++.</li>
<li>A static constructor method for each such method in the C++ Plan. These will be similar to <code>__init__</code>.</li>
</ul>
<div class="fragment"><div class="line">cdef class [Operation]Plan(Plan):</div>
<div class="line">    cdef _[Operation]Plan underlying_</div>
<div class="line"> </div>
<div class="line">    cdef _Plan* underlying(self) except NULL:</div>
<div class="line">        return &amp;self.underlying_</div>
<div class="line"> </div>
<div class="line">    Algorithm = _[Operation]Algorithm</div>
<div class="line"> </div>
<div class="line">    \@staticmethod</div>
<div class="line">    cdef [Operation]Plan make(_[Operation]Plan u):</div>
<div class="line">        f = &lt;[Operation]Plan&gt;[Operation]Plan.__new__([Operation]Plan)</div>
<div class="line">        f.underlying_ = u</div>
<div class="line">        return f</div>
<div class="line"> </div>
<div class="line">    \@property</div>
<div class="line">    def algorithm(self):</div>
<div class="line">        return _[Operation]Algorithm(self.underlying_.algorithm())</div>
<div class="line">    \@property</div>
<div class="line">    def [plan argument](self):</div>
<div class="line">        return self.underlying_.[plan argument]()</div>
<div class="line">    [...]</div>
<div class="line"> </div>
<div class="line">    def __init__(self, graph = None):</div>
<div class="line">        if graph is None:</div>
<div class="line">            self.underlying_ = _[Operation]Plan()</div>
<div class="line">        else:</div>
<div class="line">            if not isinstance(graph, PropertyGraph):</div>
<div class="line">                raise TypeError(graph)</div>
<div class="line">            self.underlying_ = _[Operation]Plan((&lt;PropertyGraph&gt;graph).underlying.get())</div>
<div class="line"> </div>
<div class="line">    \@staticmethod</div>
<div class="line">    def delta_tile(unsigned [plan argument] = kDefault[plan argument], [...]) -&gt; [Operation]Plan:</div>
<div class="line">        return [Operation]Plan.make(_[Operation]Plan.DeltaTile([plan argument], [...]))</div>
<div class="line">    [...]</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md12"></a>
Functions</h2>
<p>There are two top-level functions per operation: the operation itself, and the validity check function. The operation takes a Python <code>PropertyGraph</code> (which is a wrapper around <code>_PropertyGraph</code>), the functional arguments, and a plan. The plan should have a default value being the default plan (the plan from the zero argument constructor). The function will unwrap the <code>PropertyGraph</code> and plan, and perform any conversions required for functional arguments. The function should use <code>with nogil:</code> in Cython to allow unlock the Global Interpreter Lock to allow the Python program to do parallel work. The validity check function is the same as the operation except that it does not take a plan.</p>
<p>Functions in Python are <code>snake_case</code>. If your operation returns a value then you will make need to create a <code>handle_result_</code> function similar to that in Statistics below.</p>
<div class="fragment"><div class="line">def [operation](PropertyGraph pg, [functional arguments],</div>
<div class="line">         [Operation]Plan plan = [Operation]Plan()):</div>
<div class="line">    with nogil:</div>
<div class="line">        handle_result_void([Operation](pg.underlying.get(), [functional arguments], plan.underlying_))</div>
<div class="line"> </div>
<div class="line">def [operation]_assert_valid(PropertyGraph pg, [functional arguments]):</div>
<div class="line">    with nogil:</div>
<div class="line">        handle_result_assert([Operation]AssertValid(pg.underlying.get(), [functional arguments]))</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md13"></a>
Statistics</h2>
<p>Due to limitations of Cython we need to create a wrapper function that converts C++ error codes into exceptions. In this case we call it <code>handle_result_[Operation]Statistics</code>.</p>
<div class="fragment"><div class="line">cdef _[Operation]Statistics handle_result_[Operation]Statistics(Result[_[Operation]Statistics] res) nogil except *:</div>
<div class="line">    if not res.has_value():</div>
<div class="line">        with gil:</div>
<div class="line">            raise_error_code(res.error())</div>
<div class="line">    return res.value()</div>
</div><!-- fragment --><p>The Statistics class is wrapped similarly to the plan. However, <code>__init__</code> creates the underlying object with <code>Compute</code> and converts errors into exceptions. (<code>Compute</code> in C++ could be a constructor except for error handling.) The <code>Print</code> method is wrapped into the <code>__str__</code> method in Python, to match Python conventions for printing objects. Statistics accessors are much the same as for the plan, except that the underlying values are fields instead of methods.</p>
<div class="fragment"><div class="line">cdef class [Operation]Statistics:</div>
<div class="line">    cdef _[Operation]Statistics underlying</div>
<div class="line"> </div>
<div class="line">    def __init__(self, PropertyGraph pg, [functional arguments]):</div>
<div class="line">        with nogil:</div>
<div class="line">            self.underlying = handle_result_[Operation]Statistics(_[Operation]Statistics.Compute(</div>
<div class="line">                pg.underlying.get(), [functional arguments]))</div>
<div class="line"> </div>
<div class="line">    \@property</div>
<div class="line">    def [statistic](self):</div>
<div class="line">        return self.underlying.[statistic]</div>
<div class="line">    [...]</div>
<div class="line"> </div>
<div class="line">    def __str__(self) -&gt; str:</div>
<div class="line">        cdef ostringstream ss</div>
<div class="line">        self.underlying.Print(ss)</div>
<div class="line">        return str(ss.str(), &quot;ascii&quot;)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14"></a>
Complete Example: SSSP Cython</h2>
<p>See <a href="../python/katana/analytics/_sssp.pyx">python/katana/analytics/_sssp.pyx</a>.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
Building the Cython code</h2>
<p>Your operation should be in a file called <code>_[operation].pyx</code> in the appropriate directory. In that directory's <code>CMakeLists.txt</code> add:</p>
<div class="fragment"><div class="line">add_cython_module(_[operation] _[operation].pyx</div>
<div class="line">    DEPENDS plan</div>
<div class="line">    LIBRARIES [libraries])</div>
</div><!-- fragment --><p><code>[libraries]</code> should be a list of native libraries required by the operation. For the analytics operations in the open repository this will be <code>Katana::galois</code>. Other operations may require additional libraries.</p>
<p>The <code>DEPENDS</code> line lists other Cython modules that the operation depends on. All operations will depend on <code>plan</code>, but some may also depend on other modules (e.g., a Cython wrapper for some data structure used in the operation's API).</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Exporting in Python</h2>
<p>To provide easy access to your operation, you should add it to a higher-level module. For instance, <code><a class="el" href="namespacekatana_1_1analytics.html">katana.analytics</a></code> in <code>katana/analytics/__init__.py</code>.</p>
<p>Add the following to the appropriate module:</p>
<div class="fragment"><div class="line">from [package containing the operation]._[operation] import [operation], [operation]_assert_valid, [Operation]Plan, [Operation]Statistics</div>
</div><!-- fragment --><p>You can export other values or types the same way if needed. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
