<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Katana: Memory Allocators</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Katana
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('mem_allocator.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Memory Allocators </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#mem_allocator-intro">The Need for Custom Memory Allocators</a></li>
<li class="level1"><a href="#katana_alloc">Memory Allocators in Galois</a><ul><li class="level2"><a href="#fixed-size-alloc">Fixed Size Allocator</a></li>
<li class="level2"><a href="#per-iter-alloc">Per-iteration Allocator</a></li>
<li class="level2"><a href="#Pow2allocator">Power-of-2 Allocator</a></li>
</ul>
</li>
<li class="level1"><a href="#low_level_mem">Low-level Memory Interface in Galois</a><ul><li class="level2"><a href="#heaps_in_galois">Types of Heaps in Galois</a></li>
<li class="level2"><a href="#build-custom-alloc">Building Custom Allocators</a></li>
<li class="level2"><a href="#plugin-other-alloc">Plugging in 3rd Party Allocators</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="mem_allocator-intro"></a>
The Need for Custom Memory Allocators</h1>
<p>Memory allocators are used by dynamic data structures whose size is either known at runtime or changes during execution, e.g. std::vector, std::set, to manage dynamically changing memory requirements. The default allocation operations (<em>"malloc"</em>, <em>"new"</em>, <em>"delete"</em>, etc.) provided by the C/C++ language and standard library are designed to be general-purpose. This generality comes at the cost of performance. For instance, your code could be single-threaded, but since <em>malloc</em> is designed to handle multi-threaded paradigms just as well, this extra functionality degrades the performance.</p>
<p>For thread-safe memory allocation, these functions often use a single lock on their internal heap, and, therefore, do not scale with multiple threads. As a result, parallel code that uses the default C/C++ allocators does not scale beyond a few threads. A good memory allocator is:</p>
<ul>
<li><b>Fast:</b> Dynamic allocation and de-allocation should not slow things down. They can be optimized for common allocation patterns.</li>
<li><b>Robust:</b> They should be able to handle all the cases possible in the code and avoid memory leaks.</li>
<li><b>User-friendly</b>: They should be easy to use.</li>
<li><b>Portable:</b> They should be easily portable across system architectures.</li>
</ul>
<p>Keeping these design goals in mind, in Galois, we have designed scalable parallel allocators for some of the common usage patterns. Some of them are described below.</p>
<h1><a class="anchor" id="katana_alloc"></a>
Memory Allocators in Galois</h1>
<h2><a class="anchor" id="fixed-size-alloc"></a>
Fixed Size Allocator</h2>
<p>A common usage pattern is to allocate objects of the same type inside a parallel loop. Such an allocator can be implemented easily in a scalable manner. Galois provides <a class="el" href="classkatana_1_1FixedSizeAllocator.html">katana::FixedSizeAllocator</a>, which takes a template parameter as the type of object to be allocated. It only supports objects of fixed size type and always allocates the chunk of memory required to store one element of that size. Therefore, it cannot be used with STL data structures like std::vector and std::deque, which may need to allocate variable sized chunks of memory in order to keep all the elements contiguous in memory.</p>
<p><a class="el" href="classkatana_1_1FixedSizeAllocator.html" title="Scalable fixed-sized allocator for T that conforms to STL allocator interface but does not support va...">katana::FixedSizeAllocator</a> can be used to allocate elements of STL data structures like std::set, and std::list, etc., which always allocate objects of fixed size type and elements are not required to be contiguous in memory. The source for <a class="el" href="classkatana_1_1ThreadSafeOrderedSet.html">katana::ThreadSafeOrderedSet</a> shows how a fixed size allocator can be passed to std::set. Below is an example of using <a class="el" href="classkatana_1_1FixedSizeAllocator.html" title="Scalable fixed-sized allocator for T that conforms to STL allocator interface but does not support va...">katana::FixedSizeAllocator</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> SetInt = std::set&lt;int, std::less&lt;int&gt;, <a class="code" href="classkatana_1_1FixedSizeAllocator.html">katana::FixedSizeAllocator&lt;int&gt;</a>&gt;;</div>
<div class="line">SetInt s;</div>
<div class="line"><span class="comment">// use of s afterwards</span></div>
<div class="ttc" id="aclasskatana_1_1FixedSizeAllocator_html"><div class="ttname"><a href="classkatana_1_1FixedSizeAllocator.html">katana::FixedSizeAllocator</a></div><div class="ttdoc">Scalable fixed-sized allocator for T that conforms to STL allocator interface but does not support va...</div><div class="ttdef"><b>Definition:</b> Allocators.h:680</div></div>
</div><!-- fragment --><h2><a class="anchor" id="per-iter-alloc"></a>
Per-iteration Allocator</h2>
<p>Per-iteration allocator <a class="el" href="namespacekatana.html#a2f52a31ff8a25ead3235efa1534724a3">katana::PerIterAllocTy</a> can be used when dynamic data structures are defined inside the parallel loop and live for only one iteration of the loop. This allocator can be used inside the operators for <a class="el" href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81" title="Galois unordered set iterator.">katana::for_each</a>. It can be used with STL data structures, e.g., std::vector and std::set etc., and supports variable size allocations.</p>
<p>To use per-iteration allocator, you need to pass <a class="el" href="structkatana_1_1per__iter__alloc.html">katana::per_iter_alloc</a> to <a class="el" href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81" title="Galois unordered set iterator.">katana::for_each</a>. Here is an example of how to use it: </p><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="classkatana_1_1TypedPropertyGraph.html">Graph</a> = <span class="comment">/* graph type definition */</span>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="jaccard_8cpp.html#ac56cf62167e787bf1a4ff1e5b529e0b0">GNode</a> = Graph::GraphNode;</div>
<div class="line"><a class="code" href="classkatana_1_1TypedPropertyGraph.html">Graph</a> g;</div>
<div class="line"><a class="code" href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81">katana::for_each</a>(</div>
<div class="line">    <a class="code" href="namespacekatana.html#a664a7f49a65e22807577f6cc809a7827">katana::iterate</a>(graph),</div>
<div class="line">    [&amp;] (<a class="code" href="jaccard_8cpp.html#ac56cf62167e787bf1a4ff1e5b529e0b0">GNode</a> n, <span class="keyword">auto</span>&amp; ctx) {</div>
<div class="line">      <span class="comment">// syntax for conforming to STL allocator interface</span></div>
<div class="line">      <span class="keyword">using</span> Alloc = katana::PerIterAllocTy::rebind&lt;GNode&gt;::other;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// fast, scalable allocation for v, a per-iteration vector</span></div>
<div class="line">      <span class="comment">// get per-iteration allocator from ctx to initialize the v</span></div>
<div class="line">      std::vector&lt;GNode, Alloc&gt; v(ctx.getPerIterAlloc());</div>
<div class="line"> </div>
<div class="line">      <span class="keyword">auto</span>&amp; d = graph.getData(n).data;</div>
<div class="line">      <a class="code" href="namespacekatana_1_1ParallelSTL.html#ab68734202099da31ff5a45b6aa828205">std::copy</a>(d.begin(), d.end(), std::back_inserter(v));</div>
<div class="line">      <span class="comment">// use of v below</span></div>
<div class="line">    }</div>
<div class="line">    , <a class="code" href="structkatana_1_1per__iter__alloc.html">katana::per_iter_alloc</a>()</div>
<div class="line">    , <a class="code" href="structkatana_1_1loopname.html">katana::loopname</a>(<span class="stringliteral">&quot;per_iter_alloc_example&quot;</span>)</div>
<div class="line">);</div>
<div class="ttc" id="aclasskatana_1_1TypedPropertyGraph_html"><div class="ttname"><a href="classkatana_1_1TypedPropertyGraph.html">katana::TypedPropertyGraph</a></div><div class="ttdoc">A property graph is a graph that has properties associated with its nodes and edges.</div><div class="ttdef"><b>Definition:</b> TypedPropertyGraph.h:33</div></div>
<div class="ttc" id="ajaccard_8cpp_html_ac56cf62167e787bf1a4ff1e5b529e0b0"><div class="ttname"><a href="jaccard_8cpp.html#ac56cf62167e787bf1a4ff1e5b529e0b0">GNode</a></div><div class="ttdeci">Graph::Node GNode</div><div class="ttdef"><b>Definition:</b> jaccard.cpp:31</div></div>
<div class="ttc" id="anamespacekatana_1_1ParallelSTL_html_ab68734202099da31ff5a45b6aa828205"><div class="ttname"><a href="namespacekatana_1_1ParallelSTL.html#ab68734202099da31ff5a45b6aa828205">katana::ParallelSTL::copy</a></div><div class="ttdeci">OutputIt copy(InputIt first, InputIt last, OutputIt d_first)</div><div class="ttdef"><b>Definition:</b> ParallelSTL.h:424</div></div>
<div class="ttc" id="anamespacekatana_html_a2eb855d38b5753d67def813f9a7edb81"><div class="ttname"><a href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81">katana::for_each</a></div><div class="ttdeci">void for_each(const Range &amp;range, FunctionTy &amp;&amp;fn, Args &amp;&amp;... args)</div><div class="ttdoc">Galois unordered set iterator.</div><div class="ttdef"><b>Definition:</b> Loops.h:52</div></div>
<div class="ttc" id="anamespacekatana_html_a664a7f49a65e22807577f6cc809a7827"><div class="ttname"><a href="namespacekatana.html#a664a7f49a65e22807577f6cc809a7827">katana::iterate</a></div><div class="ttdeci">auto iterate(T &amp;container)</div><div class="ttdoc">Iterate returns a specialized range object for various container-like objects:</div><div class="ttdef"><b>Definition:</b> Range.h:296</div></div>
<div class="ttc" id="astructkatana_1_1loopname_html"><div class="ttname"><a href="structkatana_1_1loopname.html">katana::loopname</a></div><div class="ttdef"><b>Definition:</b> Traits.h:211</div></div>
<div class="ttc" id="astructkatana_1_1per__iter__alloc_html"><div class="ttname"><a href="structkatana_1_1per__iter__alloc.html">katana::per_iter_alloc</a></div><div class="ttdef"><b>Definition:</b> Traits.h:256</div></div>
</div><!-- fragment --><h2><a class="anchor" id="Pow2allocator"></a>
Power-of-2 Allocator</h2>
<p>Power-of-2 allocator <a class="el" href="namespacekatana.html#aa2d8be731b9710b958cc5d394ef2f505">katana::Pow2VarSizeAlloc</a> is a scalable allocator for dynamic data structures that allocate objects with variable size. This is a suitable allocator for STL data structures such as std::vector, std::deque, etc. It allocates blocks of sizes in powers of 2 so that insertion operations on containers like std::vector get amortized over time.</p>
<p>The following snippet shows how to define and use a std::vector of integers using power-of-2 allocator:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> VectorInt = std::vector&lt;int, katana::Pow2VarSizeAlloc&lt;int&gt;&gt;;</div>
<div class="line">VectorInt v;</div>
<div class="line"><span class="comment">// use of v afterwards</span></div>
</div><!-- fragment --><h1><a class="anchor" id="low_level_mem"></a>
Low-level Memory Interface in Galois</h1>
<h2><a class="anchor" id="heaps_in_galois"></a>
Types of Heaps in Galois</h2>
<p>The allocators in Galois are implemented in a modular fashion. An allocator can take a heap implementation as its template argument. A heap implementation defines two functions:</p>
<ul>
<li><code>void* allocate(size_t)</code>, and</li>
<li><code>void deallocate(void*, size_t)</code>.</li>
</ul>
<p>Several heap implementations are just wrappers around another heap implementation to modify its interface in some way. In the following we list a few of them and show an example:</p>
<ul>
<li><a class="el" href="classkatana_1_1SystemHeap.html">katana::SystemHeap</a> defines the basic heap implementation used by Galois allocators, and is the source of all heap memory. It is implemented as a list of pages stored by each thread.</li>
<li><a class="el" href="classkatana_1_1FreeListHeap.html">katana::FreeListHeap</a> maintains a linked list of blocks of size <em>B</em>, where <em>B</em> is the size of the objects being allocated. This is a fixed size heap, and is a wrapper around a source heap implementation that is passed as a template argument.</li>
<li><a class="el" href="classkatana_1_1BumpHeap.html">katana::BumpHeap</a> allows allocating different size objects within a block of memory by simply moving a pointer within the block. The size of the block is determined by the source heap implementation provided as a template argument. The memory within a block cannot be freed; however, blocks are freed only at the end of the program when the BumpHeap's destructor is called.</li>
<li><a class="el" href="classkatana_1_1ThreadPrivateHeap.html">katana::ThreadPrivateHeap</a> creates a per-thread instance of a source heap provided as a template argument. This is used for defining some of the parallel allocators.</li>
</ul>
<h2><a class="anchor" id="build-custom-alloc"></a>
Building Custom Allocators</h2>
<p>Per-iteration allocator, from <a class="el" href="Mem_8h.html">include/katana/Mem.h</a>, shows how heap implementations can be combined together to form useful allocators: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classkatana_1_1BumpWithMallocHeap.html">katana::BumpWithMallocHeap&lt;katana::FreeListHeap&lt;katana::SystemHeap&gt;</a>&gt;</div>
<div class="line">    <a class="code" href="namespacekatana.html#a09329c9ae65444d361341095b0c0fb73">IterAllocBaseTy</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classkatana_1_1ExternalHeapAllocator.html">katana::ExternalHeapAllocator&lt;char, IterAllocBaseTy&gt;</a> <a class="code" href="namespacekatana.html#a2f52a31ff8a25ead3235efa1534724a3">PerIterAllocTy</a>;</div>
<div class="ttc" id="aclasskatana_1_1BumpWithMallocHeap_html"><div class="ttname"><a href="classkatana_1_1BumpWithMallocHeap.html">katana::BumpWithMallocHeap</a></div><div class="ttdoc">This implements a bump pointer though chunks of memory that falls back to malloc if the source heap c...</div><div class="ttdef"><b>Definition:</b> Allocators.h:426</div></div>
<div class="ttc" id="aclasskatana_1_1ExternalHeapAllocator_html"><div class="ttname"><a href="classkatana_1_1ExternalHeapAllocator.html">katana::ExternalHeapAllocator&lt; char, IterAllocBaseTy &gt;</a></div></div>
<div class="ttc" id="anamespacekatana_html_a09329c9ae65444d361341095b0c0fb73"><div class="ttname"><a href="namespacekatana.html#a09329c9ae65444d361341095b0c0fb73">katana::IterAllocBaseTy</a></div><div class="ttdeci">katana::BumpWithMallocHeap&lt; katana::FreeListHeap&lt; katana::SystemHeap &gt; &gt; IterAllocBaseTy</div><div class="ttdoc">[PerIterAllocTy example] Base allocator for per-iteration allocator</div><div class="ttdef"><b>Definition:</b> Mem.h:60</div></div>
<div class="ttc" id="anamespacekatana_html_a2f52a31ff8a25ead3235efa1534724a3"><div class="ttname"><a href="namespacekatana.html#a2f52a31ff8a25ead3235efa1534724a3">katana::PerIterAllocTy</a></div><div class="ttdeci">katana::ExternalHeapAllocator&lt; char, IterAllocBaseTy &gt; PerIterAllocTy</div><div class="ttdoc">Per-iteration allocator that conforms to STL allocator interface.</div><div class="ttdef"><b>Definition:</b> Mem.h:63</div></div>
</div><!-- fragment --><p> Another example, from <a class="el" href="Allocators_8h.html">include/katana/Allocators.h</a>, shows how the Fixed Size allocator is defined: </p><div class="fragment"><div class="line">  <span class="keyword">typedef</span> ThreadPrivateHeap&lt;FreeListHeap&lt;BumpHeap&lt;SystemHeap&gt;&gt;&gt; SizedHeap;</div>
</div><!-- fragment --> <h2><a class="anchor" id="plugin-other-alloc"></a>
Plugging in 3rd Party Allocators</h2>
<p><a class="el" href="classkatana_1_1ExternalHeapAllocator.html">katana::ExternalHeapAllocator</a> is a wrapper class that can be used to wrap any third-party heap implementation, and make it use-able by Galois and STL data structures. It takes the type-name of the heap implementation as a template parameter and a reference to it for instantiating the allocator object.</p>
<p>As an example, we can have a C++ memory allocator by wrapping <b>malloc</b> and <b>free</b>, from C, as follows (see file <a class="el" href="Allocators_8h.html">include/katana/Allocators.h</a>): </p><div class="fragment"><div class="line"><span class="keyword">class </span>MallocHeap {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">enum</span> { AllocSize = 0 };</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span>* allocate(<span class="keywordtype">size_t</span> size) { <span class="keywordflow">return</span> malloc(size); }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> deallocate(<span class="keywordtype">void</span>* ptr) { free(ptr); }</div>
<div class="line">};</div>
</div><!-- fragment --><p> Now we can wrap MallocHeap with <a class="el" href="classkatana_1_1ExternalHeapAllocator.html" title="Keep a reference to an external allocator.">katana::ExternalHeapAllocator</a>, and use the wrapped allocator with STL containers. Below shows an example from <a class="el" href="lonestar_2tutorial_examples_2ThirdPartyMalloc_8cpp-example.html">lonestar/tutorial_examples/ThirdPartyMalloc.cpp</a>: </p><div class="fragment"><div class="line">  <span class="comment">// Our 3rd-party heap</span></div>
<div class="line">  <span class="keyword">using</span> RealHeap = <a class="code" href="classkatana_1_1MallocHeap.html">katana::MallocHeap</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Wrap RealHeap to conform to STL allocators</span></div>
<div class="line">  <span class="keyword">using</span> WrappedHeap = <a class="code" href="classkatana_1_1ExternalHeapAllocator.html">katana::ExternalHeapAllocator&lt;int, RealHeap&gt;</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Instantiate heaps</span></div>
<div class="line">  RealHeap externalHeap;</div>
<div class="line">  WrappedHeap heap(&amp;externalHeap);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Use the wrapped heap</span></div>
<div class="line">  std::vector&lt;int, WrappedHeap&gt; v(heap);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 5; i++) {</div>
<div class="line">    v.push_back(i);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Use of a std::vector with a third-party allocator wrapped by &quot;</span></div>
<div class="line">               <span class="stringliteral">&quot;katana::ExternalHeapAllocator.\n&quot;</span>;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; j : v) {</div>
<div class="line">    std::cout &lt;&lt; j &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="ttc" id="aclasskatana_1_1MallocHeap_html"><div class="ttname"><a href="classkatana_1_1MallocHeap.html">katana::MallocHeap</a></div><div class="ttdoc">[Example Third Party Allocator]</div><div class="ttdef"><b>Definition:</b> Allocators.h:51</div></div>
</div><!-- fragment --><p> <br  />
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="Manual.html">Manual</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
