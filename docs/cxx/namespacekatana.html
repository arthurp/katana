<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Katana: katana Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Katana
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacekatana.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">katana Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Construct a <a class="el" href="classkatana_1_1PropertyGraph.html" title="A property graph is a graph that has properties associated with its nodes and edges.">PropertyGraph</a> in memory.  
<a href="namespacekatana.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacekatana_1_1analytics"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html">analytics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacekatana_1_1graphml"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1graphml.html">graphml</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacekatana_1_1gstl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1gstl.html">gstl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacekatana_1_1ParallelSTL"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1ParallelSTL.html">ParallelSTL</a></td></tr>
<tr class="memdesc:namespacekatana_1_1ParallelSTL"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel versions of STL library algorithms. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacekatana_1_1parameter"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1parameter.html">parameter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1MallocHeap.html">MallocHeap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">[Example Third Party Allocator]  <a href="classkatana_1_1MallocHeap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1ThreadPrivateHeap.html">ThreadPrivateHeap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">[Example Third Party Allocator]  <a href="classkatana_1_1ThreadPrivateHeap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1LockedHeap.html">LockedHeap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a lock to a heap.  <a href="classkatana_1_1LockedHeap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1ZeroOut.html">ZeroOut</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1AddHeader.html">AddHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a header to objects.  <a href="classkatana_1_1AddHeader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1OwnerTaggedHeap.html">OwnerTaggedHeap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow looking up parent heap pointers.  <a href="classkatana_1_1OwnerTaggedHeap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1FreeListHeap.html">FreeListHeap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintain a freelist.  <a href="classkatana_1_1FreeListHeap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1SelfLockFreeListHeap.html">SelfLockFreeListHeap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintain a freelist using a lock which doesn't cover SourceHeap.  <a href="classkatana_1_1SelfLockFreeListHeap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1BlockHeap.html">BlockHeap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1BumpHeap.html">BumpHeap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implements a bump pointer though chunks of memory.  <a href="classkatana_1_1BumpHeap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1BumpWithMallocHeap.html">BumpWithMallocHeap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implements a bump pointer though chunks of memory that falls back to malloc if the source heap cannot accommodate an allocation.  <a href="classkatana_1_1BumpWithMallocHeap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1SystemHeap.html">SystemHeap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base source of memory for all allocators.  <a href="classkatana_1_1SystemHeap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1StaticSingleInstance.html">StaticSingleInstance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1PageHeap.html">PageHeap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1SizedHeapFactory.html">SizedHeapFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1VariableSizeHeap.html">VariableSizeHeap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalable variable-size allocations.  <a href="structkatana_1_1VariableSizeHeap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1FixedSizeHeap.html">FixedSizeHeap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main scalable allocator in Galois.  <a href="classkatana_1_1FixedSizeHeap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1SerialNumaHeap.html">SerialNumaHeap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1FixedSizeAllocator.html">FixedSizeAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalable fixed-sized allocator for T that conforms to STL allocator interface but does not support variable sized allocations.  <a href="classkatana_1_1FixedSizeAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1FixedSizeAllocator_3_01void_01_4.html">FixedSizeAllocator&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1Pow2BlockHeap.html">Pow2BlockHeap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1Pow2BlockAllocator.html">Pow2BlockAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1Pow2BlockAllocator_3_01void_01_4.html">Pow2BlockAllocator&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1ExternalHeapAllocator.html">ExternalHeapAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep a reference to an external allocator.  <a href="classkatana_1_1ExternalHeapAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1ExternalHeapAllocator_3_01void_00_01HeapTy_01_4.html">ExternalHeapAllocator&lt; void, HeapTy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1SerialNumaAllocator.html">SerialNumaAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1CopyableArray.html">CopyableArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A subclass of std::array that is marked trivially copyable if the type is also memory copyable.  <a href="classkatana_1_1CopyableArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1ArrowRandomAccessBuilder.html">ArrowRandomAccessBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classkatana_1_1ArrowRandomAccessBuilder.html" title="ArrowRandomAccessBuilder encapsulates the concept of building an arrow::Array from &lt;index,...">ArrowRandomAccessBuilder</a> encapsulates the concept of building an arrow::Array from &lt;index, value&gt; pairs arriving in unknown order Functions as a wrapper for NullableBuilder currently, TODO(danielmawhirter)  <a href="classkatana_1_1ArrowRandomAccessBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1CopyableAtomic.html">CopyableAtomic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that inherits from std::atomic to make it copyable by defining a copy constructor.  <a href="classkatana_1_1CopyableAtomic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1InsertBag.html">InsertBag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unordered collection of elements.  <a href="classkatana_1_1InsertBag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1Barrier.html">Barrier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1BufferedGraph.html">BufferedGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that loads a portion of a Galois graph from disk directly into memory buffers for access.  <a href="classkatana_1_1BufferedGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1ImportData.html">ImportData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1PropertyKey.html">PropertyKey</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1LabelRule.html">LabelRule</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1PropertiesState.html">PropertiesState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1LabelsState.html">LabelsState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1TopologyState.html">TopologyState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1WriterProperties.html">WriterProperties</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1GraphComponent.html">GraphComponent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1GraphComponents.html">GraphComponents</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1PropertyGraphBuilder.html">PropertyGraphBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1BulkSynchronous.html">BulkSynchronous</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bulk-synchronous scheduling.  <a href="classkatana_1_1BulkSynchronous.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1CacheLineStorage.html">CacheLineStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1GChecked.html">GChecked</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conflict-checking wrapper for any type.  <a href="classkatana_1_1GChecked.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1GChecked_3_01void_01_4.html">GChecked&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1Lockable.html">Lockable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">All objects that may be locked (nodes primarily) must inherit from <a class="el" href="classkatana_1_1Lockable.html" title="All objects that may be locked (nodes primarily) must inherit from Lockable.">Lockable</a>.  <a href="classkatana_1_1Lockable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1LockManagerBase.html">LockManagerBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1SimpleRuntimeContext.html">SimpleRuntimeContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1AlwaysLockObj.html">AlwaysLockObj</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1CheckedLockObj.html">CheckedLockObj</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1Pair.html">Pair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct that contains 2 elements.  <a href="structkatana_1_1Pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1TupleOfThree.html">TupleOfThree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct that contains 3 elements.  <a href="structkatana_1_1TupleOfThree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1read__default__graph__tag.html">read_default_graph_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1read__with__aux__graph__tag.html">read_with_aux_graph_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1read__lc__inout__graph__tag.html">read_lc_inout_graph_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1read__with__aux__first__graph__tag.html">read_with_aux_first_graph_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1EdgeSortValue.html">EdgeSortValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy object for internal EdgeSortReference.  <a href="classkatana_1_1EdgeSortValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1DynamicBitset.html">DynamicBitset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concurrent dynamically allocated bitset.  <a href="classkatana_1_1DynamicBitset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1InvalidBitsetFn.html">InvalidBitsetFn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure representing an empty bitset.  <a href="structkatana_1_1InvalidBitsetFn.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1Deterministic.html">Deterministic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structkatana_1_1Deterministic.html" title="Deterministic execution.">Deterministic</a> execution.  <a href="structkatana_1_1Deterministic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1ForEachExecutor_3_01Deterministic_3_01T_01_4_00_01FunctionTy_00_01ArgsTy_01_4.html">ForEachExecutor&lt; Deterministic&lt; T &gt;, FunctionTy, ArgsTy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1AbortHandler.html">AbortHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal Galois functionality - Use at your own risk.  <a href="classkatana_1_1AbortHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1ForEachExecutor.html">ForEachExecutor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1reiterator.html">reiterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1reiterator_3_01WLTy_00_01IterTy_00_01typename_01std_1_1enable__if_3_01has__with_4074605c49f6ca5bb8f58c9b75e7199d.html">reiterator&lt; WLTy, IterTy, typename std::enable_if&lt; has_with_iterator&lt; WLTy &gt;(0)&gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1ParaMeter.html">ParaMeter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1ForEachExecutor_3_01katana_1_1ParaMeter_3_01T_01_4_00_01FunctionTy_00_01ArgsTy_01_4.html">ForEachExecutor&lt; katana::ParaMeter&lt; T &gt;, FunctionTy, ArgsTy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1ExternalReference.html">ExternalReference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1has__serialize.html">has_serialize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if T has the serialize trait.  <a href="structkatana_1_1has__serialize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1is__copyable.html">is_copyable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if T is trivially copyable.  <a href="structkatana_1_1is__copyable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1is__memory__copyable.html">is_memory_copyable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if T is memory copyable.  <a href="structkatana_1_1is__memory__copyable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1is__serializable.html">is_serializable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if T is serializable.  <a href="structkatana_1_1is__serializable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1FileGraph.html">FileGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Graph that mmaps Galois gr files for access.  <a href="classkatana_1_1FileGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1FileGraphWriter.html">FileGraphWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies writing graphs.  <a href="classkatana_1_1FileGraphWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1FixedSizeBagBase.html">FixedSizeBagBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unordered collection of bounded size.  <a href="classkatana_1_1FixedSizeBagBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1FixedSizeRing.html">FixedSizeRing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordered collection of bounded size.  <a href="classkatana_1_1FixedSizeRing.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1flat__map.html">flat_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple map data structure, based off a single array.  <a href="classkatana_1_1flat__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1gdeque.html">gdeque</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like std::deque but use Galois memory management functionality.  <a href="classkatana_1_1gdeque.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1debug.html">debug</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1debug_3_010_01_4.html">debug&lt; 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1gslist__base.html">gslist_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1IterRange.html">IterRange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1SerFIFO.html">SerFIFO</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1SerStack.html">SerStack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1ThreadTopoInfo.html">ThreadTopoInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1MachineTopoInfo.html">MachineTopoInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1HWTopoInfo.html">HWTopoInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1HyperGraph.html">HyperGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1LargeArray.html">LargeArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Large array of objects with proper specialization for void type and supporting various allocation and construction policies.  <a href="classkatana_1_1LargeArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1LargeArray_3_01void_01_4.html">LargeArray&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Void specialization.  <a href="classkatana_1_1LargeArray_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1LazyArray.html">LazyArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a container that encapsulates space for a constant size array.  <a href="classkatana_1_1LazyArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1StrictObject.html">StrictObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single object with specialization for void type.  <a href="classkatana_1_1StrictObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1StrictObject_3_01void_01_4.html">StrictObject&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1LazyObject.html">LazyObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single (uninitialized) object with specialization for void type.  <a href="classkatana_1_1LazyObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1LazyObject_3_01void_01_4.html">LazyObject&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1LC__CSR__CSC__Graph.html">LC_CSR_CSC_Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An bidirectional <a class="el" href="classkatana_1_1LC__CSR__Graph.html" title="Local computation graph (i.e., graph structure does not change).">LC_CSR_Graph</a> that allows the construction of in-edges from its outedges.  <a href="classkatana_1_1LC__CSR__CSC__Graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1LC__CSR__CSC__Labeled__Graph.html">LC_CSR_CSC_Labeled_Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classkatana_1_1LC__CSR__CSC__Graph.html" title="An bidirectional LC_CSR_Graph that allows the construction of in-edges from its outedges.">LC_CSR_CSC_Graph</a> specialized for edge labels.  <a href="classkatana_1_1LC__CSR__CSC__Labeled__Graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1LC__CSR__Graph.html">LC_CSR_Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local computation graph (i.e., graph structure does not change).  <a href="classkatana_1_1LC__CSR__Graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1LC__InlineEdge__Graph.html">LC_InlineEdge_Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local computation graph (i.e., graph structure does not change).  <a href="classkatana_1_1LC__InlineEdge__Graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1LC__InOut__Graph.html">LC_InOut_Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify a LC_Graph to have in and out edges.  <a href="classkatana_1_1LC__InOut__Graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1LC__Linear__Graph.html">LC_Linear_Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local computation graph (i.e., graph structure does not change).  <a href="classkatana_1_1LC__Linear__Graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1LC__Morph__Graph.html">LC_Morph_Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local computation graph that allows addition of nodes (but not removals) if the maximum degree of a node is known at the time it is added.  <a href="classkatana_1_1LC__Morph__Graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1NoGlobalQueue.html">NoGlobalQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1LocalQueue.html">LocalQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1DoAll.html">DoAll</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functor class to invoke <a class="el" href="namespacekatana.html#ab9ea3b9de54b0c2f223eb585f4aefaff" title="Standard do-all loop.">katana::do_all</a> on provided args Can be used to choose between <a class="el" href="namespacekatana.html#ab9ea3b9de54b0c2f223eb585f4aefaff" title="Standard do-all loop.">katana::do_all</a> and other equivalents such as std::for_each.  <a href="structkatana_1_1DoAll.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1StdForEach.html">StdForEach</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functor to invoke std::for_each with the same interface as <a class="el" href="namespacekatana.html#ab9ea3b9de54b0c2f223eb585f4aefaff" title="Standard do-all loop.">katana::do_all</a>.  <a href="structkatana_1_1StdForEach.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1ForEach.html">ForEach</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1WhileQ.html">WhileQ</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1LoopStatistics.html">LoopStatistics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1LoopStatistics_3_01false_01_4.html">LoopStatistics&lt; false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1Morph__SepInOut__Graph.html">Morph_SepInOut_Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Graph.  <a href="classkatana_1_1Morph__SepInOut__Graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1MorphGraph.html">MorphGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A graph that can have new nodes and edges added to it.  <a href="classkatana_1_1MorphGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1NoDerefIterator.html">NoDerefIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify an iterator so that *it == it.  <a href="structkatana_1_1NoDerefIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1OrderedByIntegerMetric.html">OrderedByIntegerMetric</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate priority scheduling.  <a href="structkatana_1_1OrderedByIntegerMetric.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1BindSegmentGraph.html">BindSegmentGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the segment parameter of an out-of-core graph so that it can be used in place of a non out-of-core graph.  <a href="classkatana_1_1BindSegmentGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1OCFileGraph.html">OCFileGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="classkatana_1_1FileGraph.html">FileGraph</a> but allows partial loading of the graph.  <a href="classkatana_1_1OCFileGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1read__oc__immutable__edge__graph__tag.html">read_oc_immutable_edge_graph_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1OCImmutableEdgeGraph.html">OCImmutableEdgeGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1OfflineGraph.html">OfflineGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1OfflineGraphWriter.html">OfflineGraphWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1OrderedList.html">OrderedList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1OwnerComputes.html">OwnerComputes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1PaddedLock.html">PaddedLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classkatana_1_1PaddedLock.html" title="PaddedLock is a spinlock.">PaddedLock</a> is a spinlock.  <a href="classkatana_1_1PaddedLock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1PaddedLock_3_01true_01_4.html">PaddedLock&lt; true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1PaddedLock_3_01false_01_4.html">PaddedLock&lt; false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1ChunkHeader.html">ChunkHeader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1PerThreadChunkQueue.html">PerThreadChunkQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1PerThreadChunkStack.html">PerThreadChunkStack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1StealingQueue.html">StealingQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1PerThreadChunkMaster.html">PerThreadChunkMaster</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1PerBackend.html">PerBackend</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1PerThreadStorage.html">PerThreadStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1PerSocketStorage.html">PerSocketStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1PODResizeableArray.html">PODResizeableArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a container that encapsulates a resizeable array of plain-old-datatype (POD) elements.  <a href="classkatana_1_1PODResizeableArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1ThreadSafeOrderedSet.html">ThreadSafeOrderedSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-safe ordered set.  <a href="classkatana_1_1ThreadSafeOrderedSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1MinHeap.html">MinHeap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1ThreadSafeMinHeap.html">ThreadSafeMinHeap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-safe min heap.  <a href="classkatana_1_1ThreadSafeMinHeap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1PropertyTraits.html">PropertyTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A property is a value associated with a node or edge of a graph.  <a href="structkatana_1_1PropertyTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1PODPropertyView.html">PODPropertyView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classkatana_1_1PODPropertyView.html" title="PODPropertyView provides a property view over arrow::Arrays of elements with trivial constructors (st...">PODPropertyView</a> provides a property view over arrow::Arrays of elements with trivial constructors (std::is_trivial) and standard layout (std::is_standard_layout).  <a href="classkatana_1_1PODPropertyView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1BooleanPropertyReadOnlyView.html">BooleanPropertyReadOnlyView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classkatana_1_1BooleanPropertyReadOnlyView.html" title="BooleanPropertyReadOnlyView provides a read-only property view over arrow::Arrays of boolean elements...">BooleanPropertyReadOnlyView</a> provides a read-only property view over arrow::Arrays of boolean elements.  <a href="classkatana_1_1BooleanPropertyReadOnlyView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1StringPropertyReadOnlyView.html">StringPropertyReadOnlyView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classkatana_1_1StringPropertyReadOnlyView.html" title="StringPropertyReadOnlyView provides a read-only property view over arrow::Arrays of string elements (...">StringPropertyReadOnlyView</a> provides a read-only property view over arrow::Arrays of string elements (i.e., arrow::StringArray or arrow::LargeStringArray).  <a href="classkatana_1_1StringPropertyReadOnlyView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1PODProperty.html">PODProperty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1UInt8Property.html">UInt8Property</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1UInt16Property.html">UInt16Property</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1UInt32Property.html">UInt32Property</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1UInt64Property.html">UInt64Property</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1BooleanReadOnlyProperty.html">BooleanReadOnlyProperty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1StringReadOnlyProperty.html">StringReadOnlyProperty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1LargeStringReadOnlyProperty.html">LargeStringReadOnlyProperty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1GraphTopology.html">GraphTopology</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A graph topology represents the adjacency information for a graph in CSR format.  <a href="structkatana_1_1GraphTopology.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A property graph is a graph that has properties associated with its nodes and edges.  <a href="classkatana_1_1PropertyGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1PtrLock.html">PtrLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classkatana_1_1PtrLock.html" title="PtrLock is a spinlock and a pointer.">PtrLock</a> is a spinlock and a pointer.  <a href="classkatana_1_1PtrLock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1DummyPtrLock.html">DummyPtrLock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1LocalRange.html">LocalRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classkatana_1_1LocalRange.html" title="A LocalRange is a range specialized to containers that have a concept of local ranges (i....">LocalRange</a> is a range specialized to containers that have a concept of local ranges (i.e., local_begin and local_end).  <a href="classkatana_1_1LocalRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1LocalTwoLevelRange.html">LocalTwoLevelRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classkatana_1_1LocalTwoLevelRange.html" title="A LocalTwoLevelRange is a range over a container (outer) of containers (inner) where the outer contai...">LocalTwoLevelRange</a> is a range over a container (outer) of containers (inner) where the outer container has local ranges and the overall range should be over elements of the inner container.  <a href="classkatana_1_1LocalTwoLevelRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1StandardRange.html">StandardRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classkatana_1_1StandardRange.html" title="A StandardRange is a range over standard C++ begin and end iterators.">StandardRange</a> is a range over standard C++ begin and end iterators.  <a href="classkatana_1_1StandardRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1SpecificRange.html">SpecificRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classkatana_1_1SpecificRange.html" title="SpecificRange is a range type where a threads range is specified by an int array that gives where eac...">SpecificRange</a> is a range type where a threads range is specified by an int array that gives where each thread should begin its iteration.  <a href="classkatana_1_1SpecificRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1has__local__iterator.html">has_local_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1ReadGraphConstructFrom.html">ReadGraphConstructFrom</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1ReadGraphConstructNodesFrom.html">ReadGraphConstructNodesFrom</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1ReadGraphConstructEdgesFrom.html">ReadGraphConstructEdgesFrom</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1ReadGraphConstructOutEdgesFrom.html">ReadGraphConstructOutEdgesFrom</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1ReadGraphConstructInEdgesFrom.html">ReadGraphConstructInEdgesFrom</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1Reducible.html">Reducible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classkatana_1_1Reducible.html" title="A Reducible stores per-thread values of a variable of type T and merges multiple values into one.">Reducible</a> stores per-thread values of a variable of type T and merges multiple values into one.  <a href="classkatana_1_1Reducible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1gmax.html">gmax</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">gmax is the functional form of std::max  <a href="structkatana_1_1gmax.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1gmin.html">gmin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">gmax is the functional form of std::max  <a href="structkatana_1_1gmin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1identity__value.html">identity_value</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1identity__value__zero.html">identity_value_zero</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1identity__value__min.html">identity_value_min</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1identity__value__max.html">identity_value_max</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1GAccumulator.html">GAccumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulator for T where accumulation is plus.  <a href="classkatana_1_1GAccumulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1GReduceMax.html">GReduceMax</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulator for T where accumulation is max.  <a href="classkatana_1_1GReduceMax.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1GReduceMin.html">GReduceMin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulator for T where accumulation is min.  <a href="classkatana_1_1GReduceMin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1GReduceLogicalAnd.html">GReduceLogicalAnd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">logical AND reduction  <a href="classkatana_1_1GReduceLogicalAnd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1GReduceLogicalOr.html">GReduceLogicalOr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">logical OR reduction  <a href="classkatana_1_1GReduceLogicalOr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1SharedMem.html">SharedMem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classkatana_1_1SharedMem.html" title="A SharedMem represents global initialization required for the shared memory subsystem,...">SharedMem</a> represents global initialization required for the shared memory subsystem, i.e., thread pools and barriers.  <a href="classkatana_1_1SharedMem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1SharedMemSys.html">SharedMemSys</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classkatana_1_1SharedMemSys.html" title="SharedMemSys initializes the Galois library for shared memory.">SharedMemSys</a> initializes the Galois library for shared memory.  <a href="classkatana_1_1SharedMemSys.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1Wrapper.html">Wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple Container <a class="el" href="classkatana_1_1Wrapper.html" title="Simple Container Wrapper worklist (not scalable).">Wrapper</a> worklist (not scalable).  <a href="classkatana_1_1Wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1SimpleLock.html">SimpleLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classkatana_1_1SimpleLock.html" title="SimpleLock is a spinlock.">SimpleLock</a> is a spinlock.  <a href="classkatana_1_1SimpleLock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1SpatialTree2d.html">SpatialTree2d</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores sets of objects at specific spatial coordinates in a quad tree.  <a href="classkatana_1_1SpatialTree2d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1StableIterator.html">StableIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-overhead worklist when initial range is not invalidated by the operator.  <a href="structkatana_1_1StableIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1StaticInstance.html">StaticInstance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1RunningMin.html">RunningMin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1RunningMax.html">RunningMax</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1RunningSum.html">RunningSum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1RunningVec.html">RunningVec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1NamedStat.html">NamedStat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1AggregStat.html">AggregStat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1StatTotal.html">StatTotal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1StatManager.html">StatManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1TerminationDetection.html">TerminationDetection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Termination detection is the process of determining whether multiple threads can safely stop executing because no worker has done any work.  <a href="classkatana_1_1TerminationDetection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1ThreadPool.html">ThreadPool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1ThreadRWlock.html">ThreadRWlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1ThreadTimer.html">ThreadTimer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1ThreadTimers.html">ThreadTimers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1PerThreadTimer.html">PerThreadTimer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1PerThreadTimer_3_01false_01_4.html">PerThreadTimer&lt; false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1Fixed2DGraphTiledExecutor.html">Fixed2DGraphTiledExecutor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1Timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple timer.  <a href="classkatana_1_1Timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1TimeAccumulator.html">TimeAccumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-start time accumulator.  <a href="classkatana_1_1TimeAccumulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1StatTimer.html">StatTimer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Galois <a class="el" href="classkatana_1_1Timer.html" title="A simple timer.">Timer</a> that automatically reports stats upon destruction Provides statistic interface around timer.  <a href="classkatana_1_1StatTimer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1CondStatTimer.html">CondStatTimer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1CondStatTimer_3_01false_01_4.html">CondStatTimer&lt; false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1TimerGuard.html">TimerGuard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start and stop a <a class="el" href="classkatana_1_1TimeAccumulator.html" title="A multi-start time accumulator.">TimeAccumulator</a> in the scope of the guard.  <a href="classkatana_1_1TimerGuard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1trait__has__type.html">trait_has_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1trait__has__value.html">trait_has_value</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1trait__has__svalue.html">trait_has_svalue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1trait__type.html">trait_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type associated with the given trait in a tuple.  <a href="structkatana_1_1trait__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1has__function__traits.html">has_function_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1function__traits.html">function_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1function__traits_3_01T_00_01typename_01std_1_1enable__if__t_3_01has__function__traits__v_3_01T_01_4_01_4_01_4.html">function_traits&lt; T, typename std::enable_if_t&lt; has_function_traits_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1loopname__tag.html">loopname_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate name to appear in statistics.  <a href="structkatana_1_1loopname__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1loopname.html">loopname</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1steal__tag.html">steal_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate whetherlink <a class="el" href="namespacekatana.html#ab9ea3b9de54b0c2f223eb585f4aefaff" title="Standard do-all loop.">do_all()</a>} loops should perform work-stealing.  <a href="structkatana_1_1steal__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1steal.html">steal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1wl__tag.html">wl_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates worklist to use.  <a href="structkatana_1_1wl__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1s__wl.html">s_wl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1parallel__break__tag.html">parallel_break_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the operator may request the parallel loop to be suspended and a given function run in serial.  <a href="structkatana_1_1parallel__break__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1parallel__break.html">parallel_break</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1no__pushes__tag.html">no_pushes_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the operator does not generate new work and push it on the worklist.  <a href="structkatana_1_1no__pushes__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1no__pushes.html">no_pushes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1per__iter__alloc__tag.html">per_iter_alloc_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the operator may request the access to a per-iteration allocator.  <a href="structkatana_1_1per__iter__alloc__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1per__iter__alloc.html">per_iter_alloc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1no__stats__tag.html">no_stats_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the operator doesn't need its execution stats recorded.  <a href="structkatana_1_1no__stats__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1no__stats.html">no_stats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1more__stats__tag.html">more_stats_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the operator needs detailed stats Must provide loopname to enable this flag.  <a href="structkatana_1_1more__stats__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1more__stats.html">more_stats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1disable__conflict__detection__tag.html">disable_conflict_detection_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the operator doesn't need abort support.  <a href="structkatana_1_1disable__conflict__detection__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1disable__conflict__detection.html">disable_conflict_detection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1fixed__neighborhood__tag.html">fixed_neighborhood_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that the neighborhood set does not change through out i.e.  <a href="structkatana_1_1fixed__neighborhood__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1fixed__neighborhood.html">fixed_neighborhood</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1intent__to__read__tag.html">intent_to_read_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that the operator uses the intent to read flag.  <a href="structkatana_1_1intent__to__read__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1intent__to__read.html">intent_to_read</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1neighborhood__visitor__tag.html">neighborhood_visitor_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the operator has a function that visits the neighborhood of the operator without modifying it.  <a href="structkatana_1_1neighborhood__visitor__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1neighborhood__visitor.html">neighborhood_visitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1det__parallel__break__tag.html">det_parallel_break_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the operator has a function that allows a <a class="el" href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81">katana::for_each</a> loop to be exited deterministically.  <a href="structkatana_1_1det__parallel__break__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1det__parallel__break.html">det_parallel_break</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1det__id__tag.html">det_id_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the operator has a function that optimizes the generation of unique ids for active elements.  <a href="structkatana_1_1det__id__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1det__id.html">det_id</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1local__state__tag.html">local_state_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the operator has a type that encapsulates state that is passed between the suspension and resumpsion of an operator during deterministic scheduling.  <a href="structkatana_1_1local__state__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1local__state.html">local_state</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1op__tag.html">op_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For distributed Galois.  <a href="structkatana_1_1op__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1chunk__size__tag.html">chunk_size_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1chunk__size.html">chunk_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify chunk size for do_all_coupled &amp; do_all_choice at compile time or at runtime.  <a href="structkatana_1_1chunk__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1GetBegin.html">GetBegin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functor, returns <code>t.end()</code>  <a href="structkatana_1_1GetBegin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1GetEnd.html">GetEnd</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functor, returns <code>t.end()</code>  <a href="structkatana_1_1GetEnd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1TwoLevelIterator.html">TwoLevelIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classkatana_1_1TwoLevelIterator.html" title="A TwoLevelIterator is an iterator over a container (outer) of containers (inner) in which the element...">TwoLevelIterator</a> is an iterator over a container (outer) of containers (inner) in which the elements are the elements of the inner container.  <a href="classkatana_1_1TwoLevelIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1TypedPropertyGraph.html">TypedPropertyGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A property graph is a graph that has properties associated with its nodes and edges.  <a href="classkatana_1_1TypedPropertyGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1is__segmented.html">is_segmented</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1UnionFindNode.html">UnionFindNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intrusive union-find implementation.  <a href="classkatana_1_1UnionFindNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1UserContext.html">UserContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the object passed to the user's parallel loop.  <a href="classkatana_1_1UserContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1UserContextAccess.html">UserContextAccess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backdoor to allow runtime methods to access private data in <a class="el" href="classkatana_1_1UserContext.html" title="This is the object passed to the user&#39;s parallel loop.">UserContext</a>.  <a href="classkatana_1_1UserContextAccess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1ConExtListNode.html">ConExtListNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1ConExtIterator.html">ConExtIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1ConExtLinkedStack.html">ConExtLinkedStack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1ConExtLinkedQueue.html">ConExtLinkedQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1DummyIndexer.html">DummyIndexer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1ColumnOptions.html">ColumnOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1TableBuilder.html">TableBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classkatana_1_1TableBuilder.html" title="TableBuilder builds tables with various data types but with a fixed value distribution.">TableBuilder</a> builds tables with various data types but with a fixed value distribution.  <a href="classkatana_1_1TableBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1AppendScalarToBuilder.html">AppendScalarToBuilder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1CommBackend.html">CommBackend</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1NullCommBackend.html">NullCommBackend</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1OpaqueID.html">OpaqueID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for opaque ID types.  <a href="structkatana_1_1OpaqueID.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1OpaqueIDOrdered.html">OpaqueIDOrdered</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An ordered ID.  <a href="structkatana_1_1OpaqueIDOrdered.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1OpaqueIDOrderedWithValue.html">OpaqueIDOrderedWithValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow order comparison of IDs with their value type.  <a href="structkatana_1_1OpaqueIDOrderedWithValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1OpaqueIDLinear.html">OpaqueIDLinear</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear ID.  <a href="structkatana_1_1OpaqueIDLinear.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1OpaqueIDHashable.html">OpaqueIDHashable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide hashing for IDs to allow them to be used in unordered maps.  <a href="structkatana_1_1OpaqueIDHashable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1OpaqueIDLess.html">OpaqueIDLess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide ordering for "unordered" IDs to allow them to be used in ordered maps.  <a href="structkatana_1_1OpaqueIDLess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1ErrorInfo.html">ErrorInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classkatana_1_1ErrorInfo.html" title="An ErrorInfo contains additional context about an error in addition to an error code.">ErrorInfo</a> contains additional context about an error in addition to an error code.  <a href="classkatana_1_1ErrorInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1CopyableErrorInfo.html">CopyableErrorInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classkatana_1_1CopyableErrorInfo.html" title="A CopyableErrorInfo is a variant of ErrorInfo that can be used outside a thread&#39;s error stack.">CopyableErrorInfo</a> is a variant of <a class="el" href="classkatana_1_1ErrorInfo.html" title="An ErrorInfo contains additional context about an error in addition to an error code.">ErrorInfo</a> that can be used outside a thread's error stack.  <a href="classkatana_1_1CopyableErrorInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1Uri.html">Uri</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a34052bd67465277c5c0f1566150f7778"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a34052bd67465277c5c0f1566150f7778">ArrayBuilders</a> = std::vector&lt; std::shared_ptr&lt; arrow::ArrayBuilder &gt; &gt;</td></tr>
<tr class="separator:a34052bd67465277c5c0f1566150f7778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd207c3d84560c4872ffb3daa1ce963"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a1bd207c3d84560c4872ffb3daa1ce963">BooleanBuilders</a> = std::vector&lt; std::shared_ptr&lt; arrow::BooleanBuilder &gt; &gt;</td></tr>
<tr class="separator:a1bd207c3d84560c4872ffb3daa1ce963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac153ba2085dd5c0be210d19e2b0e2e32"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ac153ba2085dd5c0be210d19e2b0e2e32">ArrowArrays</a> = std::vector&lt; std::shared_ptr&lt; arrow::Array &gt; &gt;</td></tr>
<tr class="separator:ac153ba2085dd5c0be210d19e2b0e2e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377a12a6c4d2af8f936d7b1ff9e5fc3e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a377a12a6c4d2af8f936d7b1ff9e5fc3e">ArrowFields</a> = std::vector&lt; std::shared_ptr&lt; arrow::Field &gt; &gt;</td></tr>
<tr class="separator:a377a12a6c4d2af8f936d7b1ff9e5fc3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeccde14111dee36ee879ea833929193"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aaeccde14111dee36ee879ea833929193">NullMaps</a> = std::pair&lt; std::unordered_map&lt; int, std::shared_ptr&lt; arrow::Array &gt; &gt;, std::unordered_map&lt; int, std::shared_ptr&lt; arrow::Array &gt; &gt;&gt;</td></tr>
<tr class="separator:aaeccde14111dee36ee879ea833929193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c790c9b26b98e164abc2c5e0449d45"><td class="memTemplParams" colspan="2">template&lt;int ChunkSize = 64, typename T  = int, bool Concurrent = true&gt; </td></tr>
<tr class="memitem:ab7c790c9b26b98e164abc2c5e0449d45"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ab7c790c9b26b98e164abc2c5e0449d45">ChunkFIFO</a> = internal::ChunkMaster&lt; T, <a class="el" href="classkatana_1_1ConExtLinkedQueue.html">ConExtLinkedQueue</a>, false, false, ChunkSize, Concurrent &gt;</td></tr>
<tr class="memdesc:ab7c790c9b26b98e164abc2c5e0449d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chunk FIFO.  <a href="namespacekatana.html#ab7c790c9b26b98e164abc2c5e0449d45">More...</a><br /></td></tr>
<tr class="separator:ab7c790c9b26b98e164abc2c5e0449d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952ae2d2b3b5f99d90b6e04700c435a3"><td class="memTemplParams" colspan="2">template&lt;int ChunkSize = 64, typename T  = int, bool Concurrent = true&gt; </td></tr>
<tr class="memitem:a952ae2d2b3b5f99d90b6e04700c435a3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a952ae2d2b3b5f99d90b6e04700c435a3">ChunkLIFO</a> = internal::ChunkMaster&lt; T, <a class="el" href="classkatana_1_1ConExtLinkedStack.html">ConExtLinkedStack</a>, false, true, ChunkSize, Concurrent &gt;</td></tr>
<tr class="memdesc:a952ae2d2b3b5f99d90b6e04700c435a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chunk LIFO.  <a href="namespacekatana.html#a952ae2d2b3b5f99d90b6e04700c435a3">More...</a><br /></td></tr>
<tr class="separator:a952ae2d2b3b5f99d90b6e04700c435a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab846f7bdd2bd0cecf06708c1806a668f"><td class="memTemplParams" colspan="2">template&lt;int ChunkSize = 64, typename T  = int, bool Concurrent = true&gt; </td></tr>
<tr class="memitem:ab846f7bdd2bd0cecf06708c1806a668f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ab846f7bdd2bd0cecf06708c1806a668f">PerSocketChunkFIFO</a> = internal::ChunkMaster&lt; T, <a class="el" href="classkatana_1_1ConExtLinkedQueue.html">ConExtLinkedQueue</a>, true, false, ChunkSize, Concurrent &gt;</td></tr>
<tr class="memdesc:ab846f7bdd2bd0cecf06708c1806a668f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributed chunked FIFO.  <a href="namespacekatana.html#ab846f7bdd2bd0cecf06708c1806a668f">More...</a><br /></td></tr>
<tr class="separator:ab846f7bdd2bd0cecf06708c1806a668f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ae784a4e1b6a4885f4a32d144938ec"><td class="memTemplParams" colspan="2">template&lt;int ChunkSize = 64, typename T  = int, bool Concurrent = true&gt; </td></tr>
<tr class="memitem:a61ae784a4e1b6a4885f4a32d144938ec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a61ae784a4e1b6a4885f4a32d144938ec">PerSocketChunkLIFO</a> = internal::ChunkMaster&lt; T, <a class="el" href="classkatana_1_1ConExtLinkedStack.html">ConExtLinkedStack</a>, true, true, ChunkSize, Concurrent &gt;</td></tr>
<tr class="memdesc:a61ae784a4e1b6a4885f4a32d144938ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributed chunked LIFO.  <a href="namespacekatana.html#a61ae784a4e1b6a4885f4a32d144938ec">More...</a><br /></td></tr>
<tr class="separator:a61ae784a4e1b6a4885f4a32d144938ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe2e583b3a2f54a658c08932110f18e"><td class="memTemplParams" colspan="2">template&lt;int ChunkSize = 64, typename T  = int, bool Concurrent = true&gt; </td></tr>
<tr class="memitem:afbe2e583b3a2f54a658c08932110f18e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#afbe2e583b3a2f54a658c08932110f18e">PerSocketChunkBag</a> = internal::ChunkMaster&lt; T, <a class="el" href="classkatana_1_1ConExtLinkedQueue.html">ConExtLinkedQueue</a>, true, true, ChunkSize, Concurrent &gt;</td></tr>
<tr class="memdesc:afbe2e583b3a2f54a658c08932110f18e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributed chunked bag.  <a href="namespacekatana.html#afbe2e583b3a2f54a658c08932110f18e">More...</a><br /></td></tr>
<tr class="separator:afbe2e583b3a2f54a658c08932110f18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1dfda6e2830fcd2bb12d0164fd1608"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned ChunkSize = 64&gt; </td></tr>
<tr class="memitem:aaa1dfda6e2830fcd2bb12d0164fd1608"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aaa1dfda6e2830fcd2bb12d0164fd1608">FixedSizeBag</a> = <a class="el" href="classkatana_1_1FixedSizeBagBase.html">FixedSizeBagBase</a>&lt; T, ChunkSize, false &gt;</td></tr>
<tr class="memdesc:aaa1dfda6e2830fcd2bb12d0164fd1608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unordered collection of bounded size.  <a href="namespacekatana.html#aaa1dfda6e2830fcd2bb12d0164fd1608">More...</a><br /></td></tr>
<tr class="separator:aaa1dfda6e2830fcd2bb12d0164fd1608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f289119101acc7d05a6fca24ba8f607"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned ChunkSize = 64&gt; </td></tr>
<tr class="memitem:a7f289119101acc7d05a6fca24ba8f607"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a7f289119101acc7d05a6fca24ba8f607">ConcurrentFixedSizeBag</a> = <a class="el" href="classkatana_1_1FixedSizeBagBase.html">FixedSizeBagBase</a>&lt; T, ChunkSize, true &gt;</td></tr>
<tr class="memdesc:a7f289119101acc7d05a6fca24ba8f607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unordered collection of bounded size with concurrent insertion or deletion but not both simultaneously.  <a href="namespacekatana.html#a7f289119101acc7d05a6fca24ba8f607">More...</a><br /></td></tr>
<tr class="separator:a7f289119101acc7d05a6fca24ba8f607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45c0b8fb3f5a82a6f96c2d50258a1d3"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned chunksize = 16&gt; </td></tr>
<tr class="memitem:aa45c0b8fb3f5a82a6f96c2d50258a1d3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aa45c0b8fb3f5a82a6f96c2d50258a1d3">gslist</a> = <a class="el" href="classkatana_1_1gslist__base.html">gslist_base</a>&lt; T, chunksize, false &gt;</td></tr>
<tr class="memdesc:aa45c0b8fb3f5a82a6f96c2d50258a1d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singly linked list.  <a href="namespacekatana.html#aa45c0b8fb3f5a82a6f96c2d50258a1d3">More...</a><br /></td></tr>
<tr class="separator:aa45c0b8fb3f5a82a6f96c2d50258a1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0f205d2f588c9e6eee5e93c02bc5d6"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned chunksize = 16&gt; </td></tr>
<tr class="memitem:abb0f205d2f588c9e6eee5e93c02bc5d6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#abb0f205d2f588c9e6eee5e93c02bc5d6">concurrent_gslist</a> = <a class="el" href="classkatana_1_1gslist__base.html">gslist_base</a>&lt; T, chunksize, true &gt;</td></tr>
<tr class="memdesc:abb0f205d2f588c9e6eee5e93c02bc5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concurrent linked list.  <a href="namespacekatana.html#abb0f205d2f588c9e6eee5e93c02bc5d6">More...</a><br /></td></tr>
<tr class="separator:abb0f205d2f588c9e6eee5e93c02bc5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09329c9ae65444d361341095b0c0fb73"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classkatana_1_1BumpWithMallocHeap.html">katana::BumpWithMallocHeap</a>&lt; <a class="el" href="classkatana_1_1FreeListHeap.html">katana::FreeListHeap</a>&lt; <a class="el" href="classkatana_1_1SystemHeap.html">katana::SystemHeap</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a09329c9ae65444d361341095b0c0fb73">IterAllocBaseTy</a></td></tr>
<tr class="memdesc:a09329c9ae65444d361341095b0c0fb73"><td class="mdescLeft">&#160;</td><td class="mdescRight">[PerIterAllocTy example] Base allocator for per-iteration allocator  <a href="namespacekatana.html#a09329c9ae65444d361341095b0c0fb73">More...</a><br /></td></tr>
<tr class="separator:a09329c9ae65444d361341095b0c0fb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f52a31ff8a25ead3235efa1534724a3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classkatana_1_1ExternalHeapAllocator.html">katana::ExternalHeapAllocator</a>&lt; char, <a class="el" href="namespacekatana.html#a09329c9ae65444d361341095b0c0fb73">IterAllocBaseTy</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a2f52a31ff8a25ead3235efa1534724a3">PerIterAllocTy</a></td></tr>
<tr class="memdesc:a2f52a31ff8a25ead3235efa1534724a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Per-iteration allocator that conforms to STL allocator interface.  <a href="namespacekatana.html#a2f52a31ff8a25ead3235efa1534724a3">More...</a><br /></td></tr>
<tr class="separator:a2f52a31ff8a25ead3235efa1534724a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d8be731b9710b958cc5d394ef2f505"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa2d8be731b9710b958cc5d394ef2f505"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aa2d8be731b9710b958cc5d394ef2f505">Pow2VarSizeAlloc</a> = <a class="el" href="classkatana_1_1Pow2BlockAllocator.html">Pow2BlockAllocator</a>&lt; T &gt;</td></tr>
<tr class="memdesc:aa2d8be731b9710b958cc5d394ef2f505"><td class="mdescLeft">&#160;</td><td class="mdescRight">[PerIterAllocTy example]  <a href="namespacekatana.html#aa2d8be731b9710b958cc5d394ef2f505">More...</a><br /></td></tr>
<tr class="separator:aa2d8be731b9710b958cc5d394ef2f505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35860f323cd4a2faf392c984e77ba618"><td class="memItemLeft" align="right" valign="top">typedef std::unique_ptr&lt; void, internal::largeFreer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a35860f323cd4a2faf392c984e77ba618">LAptr</a></td></tr>
<tr class="separator:a35860f323cd4a2faf392c984e77ba618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7456f5718807adfd1dafa96512a3bf5f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7456f5718807adfd1dafa96512a3bf5f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a7456f5718807adfd1dafa96512a3bf5f">OperatorReferenceType</a> = typename internal::OperatorReferenceType_impl&lt; T &gt;::type</td></tr>
<tr class="separator:a7456f5718807adfd1dafa96512a3bf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2f492fc05abc037f021bfef430f3f1"><td class="memTemplParams" colspan="2">template&lt;int ChunkSize = 64, typename T  = int&gt; </td></tr>
<tr class="memitem:a4a2f492fc05abc037f021bfef430f3f1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a4a2f492fc05abc037f021bfef430f3f1">PerThreadChunkLIFO</a> = <a class="el" href="structkatana_1_1PerThreadChunkMaster.html">PerThreadChunkMaster</a>&lt; true, ChunkSize, <a class="el" href="classkatana_1_1StealingQueue.html">StealingQueue</a>&lt; <a class="el" href="classkatana_1_1PerThreadChunkStack.html">PerThreadChunkStack</a> &gt;, T &gt;</td></tr>
<tr class="separator:a4a2f492fc05abc037f021bfef430f3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2871917f6d0efc6dbe0207c6baa2429"><td class="memTemplParams" colspan="2">template&lt;int ChunkSize = 64, typename T  = int&gt; </td></tr>
<tr class="memitem:ae2871917f6d0efc6dbe0207c6baa2429"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ae2871917f6d0efc6dbe0207c6baa2429">PerThreadChunkFIFO</a> = <a class="el" href="structkatana_1_1PerThreadChunkMaster.html">PerThreadChunkMaster</a>&lt; false, ChunkSize, <a class="el" href="classkatana_1_1StealingQueue.html">StealingQueue</a>&lt; <a class="el" href="classkatana_1_1PerThreadChunkQueue.html">PerThreadChunkQueue</a> &gt;, T &gt;</td></tr>
<tr class="separator:ae2871917f6d0efc6dbe0207c6baa2429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96891e61fe2d373acae3b4a9a206791"><td class="memTemplParams" colspan="2">template&lt;typename Prop &gt; </td></tr>
<tr class="memitem:ae96891e61fe2d373acae3b4a9a206791"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ae96891e61fe2d373acae3b4a9a206791">PropertyArrowType</a> = typename <a class="el" href="structkatana_1_1PropertyTraits.html">PropertyTraits</a>&lt; Prop &gt;::ArrowType</td></tr>
<tr class="separator:ae96891e61fe2d373acae3b4a9a206791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4b21fee4699f8130e3178ba8f67bf7"><td class="memTemplParams" colspan="2">template&lt;typename Prop &gt; </td></tr>
<tr class="memitem:aaf4b21fee4699f8130e3178ba8f67bf7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aaf4b21fee4699f8130e3178ba8f67bf7">PropertyViewType</a> = typename <a class="el" href="structkatana_1_1PropertyTraits.html">PropertyTraits</a>&lt; Prop &gt;::ViewType</td></tr>
<tr class="separator:aaf4b21fee4699f8130e3178ba8f67bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c45912870ebf83f7455304855c5aeb"><td class="memTemplParams" colspan="2">template&lt;typename Prop &gt; </td></tr>
<tr class="memitem:a82c45912870ebf83f7455304855c5aeb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a82c45912870ebf83f7455304855c5aeb">PropertyArrowArrayType</a> = typename arrow::TypeTraits&lt; <a class="el" href="namespacekatana.html#ae96891e61fe2d373acae3b4a9a206791">PropertyArrowType</a>&lt; Prop &gt; &gt;::ArrayType</td></tr>
<tr class="separator:a82c45912870ebf83f7455304855c5aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ce8aaa410efd9dbfd1eb814700c2ca"><td class="memTemplParams" colspan="2">template&lt;typename Prop &gt; </td></tr>
<tr class="memitem:a53ce8aaa410efd9dbfd1eb814700c2ca"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a53ce8aaa410efd9dbfd1eb814700c2ca">PropertyReferenceType</a> = typename <a class="el" href="namespacekatana.html#aaf4b21fee4699f8130e3178ba8f67bf7">PropertyViewType</a>&lt; Prop &gt;::reference</td></tr>
<tr class="separator:a53ce8aaa410efd9dbfd1eb814700c2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1bee45602998c333b50fc73a6d5498"><td class="memTemplParams" colspan="2">template&lt;typename Prop &gt; </td></tr>
<tr class="memitem:aaa1bee45602998c333b50fc73a6d5498"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aaa1bee45602998c333b50fc73a6d5498">PropertyConstReferenceType</a> = typename <a class="el" href="namespacekatana.html#aaf4b21fee4699f8130e3178ba8f67bf7">PropertyViewType</a>&lt; Prop &gt;::const_reference</td></tr>
<tr class="separator:aaa1bee45602998c333b50fc73a6d5498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ca3836521e1363b4681229b26bacb7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa4ca3836521e1363b4681229b26bacb7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aa4ca3836521e1363b4681229b26bacb7">PropertyViewTuple</a> = typename internal::PropertyViewTuple&lt; T &gt;::type</td></tr>
<tr class="memdesc:aa4ca3836521e1363b4681229b26bacb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">PropertyViewTuple applies PropertyViewType to a tuple of properties.  <a href="namespacekatana.html#aa4ca3836521e1363b4681229b26bacb7">More...</a><br /></td></tr>
<tr class="separator:aa4ca3836521e1363b4681229b26bacb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfdff467f47dfe8a2ab1cc597d7584f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afbfdff467f47dfe8a2ab1cc597d7584f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#afbfdff467f47dfe8a2ab1cc597d7584f">PropertyArrowTuple</a> = typename internal::PropertyArrowTuple&lt; T &gt;::type</td></tr>
<tr class="memdesc:afbfdff467f47dfe8a2ab1cc597d7584f"><td class="mdescLeft">&#160;</td><td class="mdescRight">PropertyArrowTuple applies arrow::TypeTraits&lt;T::ArrowType&gt;::CType to a tuple of properties.  <a href="namespacekatana.html#afbfdff467f47dfe8a2ab1cc597d7584f">More...</a><br /></td></tr>
<tr class="separator:afbfdff467f47dfe8a2ab1cc597d7584f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada32e492c7349b1893be8f4849e76852"><td class="memTemplParams" colspan="2">template&lt;typename Tuple , size_t... indices&gt; </td></tr>
<tr class="memitem:ada32e492c7349b1893be8f4849e76852"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ada32e492c7349b1893be8f4849e76852">TupleElements</a> = std::tuple&lt; std::tuple_element_t&lt; indices, Tuple &gt;... &gt;</td></tr>
<tr class="memdesc:ada32e492c7349b1893be8f4849e76852"><td class="mdescLeft">&#160;</td><td class="mdescRight">TupleElements selects the tuple elements at the given indices.  <a href="namespacekatana.html#ada32e492c7349b1893be8f4849e76852">More...</a><br /></td></tr>
<tr class="separator:ada32e492c7349b1893be8f4849e76852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84226ce246b0237245e6bb9069c7d092"><td class="memTemplParams" colspan="2">template&lt;typename T  = int&gt; </td></tr>
<tr class="memitem:a84226ce246b0237245e6bb9069c7d092"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a84226ce246b0237245e6bb9069c7d092">FIFO</a> = <a class="el" href="classkatana_1_1Wrapper.html">Wrapper</a>&lt; T, std::deque&lt; T &gt;, false &gt;</td></tr>
<tr class="separator:a84226ce246b0237245e6bb9069c7d092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714ec5bc951d6ab1ff98a1f15dd9bc4a"><td class="memTemplParams" colspan="2">template&lt;typename T  = int&gt; </td></tr>
<tr class="memitem:a714ec5bc951d6ab1ff98a1f15dd9bc4a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a714ec5bc951d6ab1ff98a1f15dd9bc4a">GFIFO</a> = <a class="el" href="classkatana_1_1Wrapper.html">Wrapper</a>&lt; T, <a class="el" href="classkatana_1_1gdeque.html">katana::gdeque</a>&lt; T &gt;, false &gt;</td></tr>
<tr class="separator:a714ec5bc951d6ab1ff98a1f15dd9bc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7993944566434d2c819d10213374ee"><td class="memTemplParams" colspan="2">template&lt;typename T  = int&gt; </td></tr>
<tr class="memitem:acf7993944566434d2c819d10213374ee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#acf7993944566434d2c819d10213374ee">LIFO</a> = <a class="el" href="classkatana_1_1Wrapper.html">Wrapper</a>&lt; T, std::deque&lt; T &gt;, true &gt;</td></tr>
<tr class="separator:acf7993944566434d2c819d10213374ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fd2c9cd3d14cdd7c06906939080006"><td class="memTemplParams" colspan="2">template&lt;typename T  = int&gt; </td></tr>
<tr class="memitem:a38fd2c9cd3d14cdd7c06906939080006"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a38fd2c9cd3d14cdd7c06906939080006">GLIFO</a> = <a class="el" href="classkatana_1_1Wrapper.html">Wrapper</a>&lt; T, <a class="el" href="classkatana_1_1gdeque.html">katana::gdeque</a>&lt; T &gt;, true &gt;</td></tr>
<tr class="separator:a38fd2c9cd3d14cdd7c06906939080006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4969f8e91adb1b78e697a9cff98d9bd3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Tuple &gt; </td></tr>
<tr class="memitem:a4969f8e91adb1b78e697a9cff98d9bd3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a4969f8e91adb1b78e697a9cff98d9bd3">trait_type_t</a> = typename std::tuple_element&lt; <a class="el" href="namespacekatana.html#a8c11c7e97215b2746292a3df68e88c9f">find_trait</a>&lt; T, Tuple &gt;(), Tuple &gt;::type</td></tr>
<tr class="separator:a4969f8e91adb1b78e697a9cff98d9bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48505b29fc3b758864a6798815f38afc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a48505b29fc3b758864a6798815f38afc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a48505b29fc3b758864a6798815f38afc">is_list_type_patched</a> = std::integral_constant&lt; bool, std::is_same&lt; T, arrow::ListType &gt;::value||std::is_same&lt; T, arrow::LargeListType &gt;::value||std::is_same&lt; T, arrow::FixedSizeListType &gt;::value &gt;</td></tr>
<tr class="memdesc:a48505b29fc3b758864a6798815f38afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enables Arrow visitors of the form: class Visitor { using ReturnType = void; // configurable.  <a href="namespacekatana.html#a48505b29fc3b758864a6798815f38afc">More...</a><br /></td></tr>
<tr class="separator:a48505b29fc3b758864a6798815f38afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93efdbdcf28e687428900efeda73ba4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:ad93efdbdcf28e687428900efeda73ba4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ad93efdbdcf28e687428900efeda73ba4">enable_if_list_type_patched</a> = arrow::enable_if_t&lt; <a class="el" href="namespacekatana.html#a48505b29fc3b758864a6798815f38afc">is_list_type_patched</a>&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:ad93efdbdcf28e687428900efeda73ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482e28ae619c1a2de9364752b2848ec3"><td class="memTemplParams" colspan="2">template&lt;typename OpaqueIDType &gt; </td></tr>
<tr class="memitem:a482e28ae619c1a2de9364752b2848ec3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a482e28ae619c1a2de9364752b2848ec3">opaque_id_value_type</a> = decltype(<a class="el" href="namespacekatana.html#ac5038f4364fb63fb47b2f5b984e716f0">must_be_OpaqueID_subclass</a>(std::declval&lt; OpaqueIDType &gt;()))</td></tr>
<tr class="memdesc:a482e28ae619c1a2de9364752b2848ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value type of an <a class="el" href="structkatana_1_1OpaqueID.html" title="Base class for opaque ID types.">OpaqueID</a> subclass.  <a href="namespacekatana.html#a482e28ae619c1a2de9364752b2848ec3">More...</a><br /></td></tr>
<tr class="separator:a482e28ae619c1a2de9364752b2848ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f4c6b4c41224bdb87892b16e067340"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a90f4c6b4c41224bdb87892b16e067340">RandGenerator</a> = std::mt19937</td></tr>
<tr class="separator:a90f4c6b4c41224bdb87892b16e067340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef5f54fe30dfc7b2cf9294ac744d6bb"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7ef5f54fe30dfc7b2cf9294ac744d6bb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a> = BOOST_OUTCOME_V2_NAMESPACE::std_result&lt; T, <a class="el" href="classkatana_1_1ErrorInfo.html">ErrorInfo</a>, internal::abort_policy &gt;</td></tr>
<tr class="memdesc:a7ef5f54fe30dfc7b2cf9294ac744d6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Result is a T or an <a class="el" href="classkatana_1_1ErrorInfo.html" title="An ErrorInfo contains additional context about an error in addition to an error code.">ErrorInfo</a>.  <a href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">More...</a><br /></td></tr>
<tr class="separator:a7ef5f54fe30dfc7b2cf9294ac744d6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95b9b34a27cfd81202928e7698e9653"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aa95b9b34a27cfd81202928e7698e9653">Clock</a> = std::chrono::high_resolution_clock</td></tr>
<tr class="separator:aa95b9b34a27cfd81202928e7698e9653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53d5a0919afb768f3ad0304893c5925"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ad53d5a0919afb768f3ad0304893c5925">TimePoint</a> = std::chrono::time_point&lt; <a class="el" href="namespacekatana.html#aa95b9b34a27cfd81202928e7698e9653">Clock</a> &gt;</td></tr>
<tr class="separator:ad53d5a0919afb768f3ad0304893c5925"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ada19d9d708b680e28f2c232679afcae2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ada19d9d708b680e28f2c232679afcae2">SourceType</a> { <a class="el" href="namespacekatana.html#ada19d9d708b680e28f2c232679afcae2a6a17a3f48e2bdd78e6ecb0613efc4eb8">kGraphml</a>
, <a class="el" href="namespacekatana.html#ada19d9d708b680e28f2c232679afcae2a84b36fcfbd942093ad27034be0eccfc4">kKatana</a>
 }</td></tr>
<tr class="separator:ada19d9d708b680e28f2c232679afcae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85815a5455e9140c17d581c3c4247c57"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a85815a5455e9140c17d581c3c4247c57">SourceDatabase</a> { <a class="el" href="namespacekatana.html#a85815a5455e9140c17d581c3c4247c57a4306bbd219bb4a3321a31d2ba2082245">kNone</a>
, <a class="el" href="namespacekatana.html#a85815a5455e9140c17d581c3c4247c57ae509d183b8082e02d13724db4aef2283">kNeo4j</a>
, <a class="el" href="namespacekatana.html#a85815a5455e9140c17d581c3c4247c57ab18dc51293ec490624d3bda40d1fe7ed">kMongodb</a>
, <a class="el" href="namespacekatana.html#a85815a5455e9140c17d581c3c4247c57acb840e7e4ee5d9993194c4adba189880">kMysql</a>
 }</td></tr>
<tr class="separator:a85815a5455e9140c17d581c3c4247c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaddb70632c03509301eb162e81515bff"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aaddb70632c03509301eb162e81515bff">ImportDataType</a> { <br />
&#160;&#160;<a class="el" href="namespacekatana.html#aaddb70632c03509301eb162e81515bffa26d2ec82db964954b2ebd0106c88dcc8">kString</a>
, <a class="el" href="namespacekatana.html#aaddb70632c03509301eb162e81515bffabd2b9300b3cd517af047c9a65900ea1d">kInt64</a>
, <a class="el" href="namespacekatana.html#aaddb70632c03509301eb162e81515bffa9f185c15cba6a31c303b3154ac5f9bc6">kInt32</a>
, <a class="el" href="namespacekatana.html#aaddb70632c03509301eb162e81515bffa254d3ee3a61879dc26b0b3c546cd6a86">kUInt32</a>
, <br />
&#160;&#160;<a class="el" href="namespacekatana.html#aaddb70632c03509301eb162e81515bffacf897f4aaf961485c08defb713e9880c">kDouble</a>
, <a class="el" href="namespacekatana.html#aaddb70632c03509301eb162e81515bffa65a34000c0df856063234b8ace7d58f7">kFloat</a>
, <a class="el" href="namespacekatana.html#aaddb70632c03509301eb162e81515bffa8688601c5df2549b8c6cc93ac69a880a">kBoolean</a>
, <a class="el" href="namespacekatana.html#aaddb70632c03509301eb162e81515bffa0e78936e27a277998a6951ad61f400d5">kTimestampMilli</a>
, <br />
&#160;&#160;<a class="el" href="namespacekatana.html#aaddb70632c03509301eb162e81515bffaf32daeddef66bda7ba962b18098da5be">kStruct</a>
, <a class="el" href="namespacekatana.html#aaddb70632c03509301eb162e81515bffa79361bb29fe1d25f1d13d8e7ae7be766">kUnsupported</a>
<br />
 }</td></tr>
<tr class="separator:aaddb70632c03509301eb162e81515bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe87e3fefa44cdaf3f6d806d46167ceb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#abe87e3fefa44cdaf3f6d806d46167ceb">ConflictFlag</a> { <a class="el" href="namespacekatana.html#abe87e3fefa44cdaf3f6d806d46167cebaca0fecc4da9701e8eaab62ade337374f">CONFLICT</a> = -1
, <a class="el" href="namespacekatana.html#abe87e3fefa44cdaf3f6d806d46167ceba3e2d012f862ac17b595fbfbf1843e09d">NO_CONFLICT</a> = 0
, <a class="el" href="namespacekatana.html#abe87e3fefa44cdaf3f6d806d46167ceba905c201c162afcb055518e360d92ad86">REACHED_FAILSAFE</a> = 1
, <a class="el" href="namespacekatana.html#abe87e3fefa44cdaf3f6d806d46167cebaeb06e23a71a7949f857b8d198ac687dd">BREAK</a> = 2
 }</td></tr>
<tr class="separator:abe87e3fefa44cdaf3f6d806d46167ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679ab3b4021187532d65e16ceb3fc246"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246">MethodFlag</a> : char { <br />
&#160;&#160;<a class="el" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246a937e6a98c210e6d3d0af5ed55de70d3b">UNPROTECTED</a> = 0
, <a class="el" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246ad4b9e47f65b6e79b010582f15785867e">WRITE</a> = 1
, <a class="el" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246a3466fab4975481651940ed328aa990e4">READ</a> = 2
, <a class="el" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246a82109e7d807e8a6ffa3ff3648e1ff809">INTERNAL_MASK</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246a315ba7a868d45a9cb131c8dca3166b51">PREVIOUS</a> = 4
<br />
 }</td></tr>
<tr class="memdesc:a679ab3b4021187532d65e16ceb3fc246"><td class="mdescLeft">&#160;</td><td class="mdescRight">What should the runtime do when executing a method.  <a href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246">More...</a><br /></td></tr>
<tr class="separator:a679ab3b4021187532d65e16ceb3fc246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d227598262d7bcbd17e8270fdc25d56"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a9d227598262d7bcbd17e8270fdc25d56">ErrorCode</a> { <br />
&#160;&#160;<a class="el" href="namespacekatana.html#a9d227598262d7bcbd17e8270fdc25d56a253ca7dd096ee0956cccee4d376cab8b">InvalidArgument</a> = 1
, <a class="el" href="namespacekatana.html#a9d227598262d7bcbd17e8270fdc25d56a997ca4ce119685f40f03a9a8a6c5346e">NotImplemented</a> = 2
, <a class="el" href="namespacekatana.html#a9d227598262d7bcbd17e8270fdc25d56a38c300f4fc9ce8a77aad4a30de05cad8">NotFound</a> = 3
, <a class="el" href="namespacekatana.html#a9d227598262d7bcbd17e8270fdc25d56a23c92beca28d9939df06c7a804e5fe81">ArrowError</a> = 4
, <br />
&#160;&#160;<a class="el" href="namespacekatana.html#a9d227598262d7bcbd17e8270fdc25d56ac9f577ac2188250a8a440c25109b4129">JsonParseFailed</a> = 5
, <a class="el" href="namespacekatana.html#a9d227598262d7bcbd17e8270fdc25d56aefa880dac8d229e8d19b697841563f05">JsonDumpFailed</a> = 6
, <a class="el" href="namespacekatana.html#a9d227598262d7bcbd17e8270fdc25d56a2feb6ea3db3fd8eb9ec285f21f1ef868">HttpError</a> = 7
, <a class="el" href="namespacekatana.html#a9d227598262d7bcbd17e8270fdc25d56ab7b1e314614cf326c6e2b6eba1540682">TODO</a> = 8
, <br />
&#160;&#160;<a class="el" href="namespacekatana.html#a9d227598262d7bcbd17e8270fdc25d56ab90705e8d1c51a36cdcf8e4daf3be564">PropertyNotFound</a> = 9
, <a class="el" href="namespacekatana.html#a9d227598262d7bcbd17e8270fdc25d56a89b69484680b18e9179e826c6e023805">AlreadyExists</a> = 10
, <a class="el" href="namespacekatana.html#a9d227598262d7bcbd17e8270fdc25d56a137bf8cff2d59f0883c600f9524b3eed">TypeError</a> = 11
, <a class="el" href="namespacekatana.html#a9d227598262d7bcbd17e8270fdc25d56ac7bca54dd788dd9a141de983df16916d">AssertionFailed</a> = 12
, <br />
&#160;&#160;<a class="el" href="namespacekatana.html#a9d227598262d7bcbd17e8270fdc25d56ab65c0861ac72bbaa6339c76132fda8d9">GraphUpdateFailed</a> = 13
, <a class="el" href="namespacekatana.html#a9d227598262d7bcbd17e8270fdc25d56a1e8a2f742b0e2bf8256ebb89f095dfc5">FeatureNotEnabled</a> = 14
<br />
 }</td></tr>
<tr class="separator:a9d227598262d7bcbd17e8270fdc25d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c012a5bda211a6470b9e8424c14e7b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ab1c012a5bda211a6470b9e8424c14e7b">LogLevel</a> { <a class="el" href="namespacekatana.html#ab1c012a5bda211a6470b9e8424c14e7baa603905470e2a5b8c13e96b579ef0dba">Debug</a> = 0
, <a class="el" href="namespacekatana.html#ab1c012a5bda211a6470b9e8424c14e7bad4a9fa383ab700c5bdd6f31cf7df0faf">Verbose</a> = 1
, <a class="el" href="namespacekatana.html#ab1c012a5bda211a6470b9e8424c14e7ba0eaadb4fcb48a0a0ed7bc9868be9fbaa">Warning</a> = 3
, <a class="el" href="namespacekatana.html#ab1c012a5bda211a6470b9e8424c14e7ba902b0d55fddef6f8d651fe1035b7d4bd">Error</a> = 4
 }</td></tr>
<tr class="separator:ab1c012a5bda211a6470b9e8424c14e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0a15d8fd6f923c1ec191b44afc93c1c7"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a0a15d8fd6f923c1ec191b44afc93c1c7">pageIn</a> (void *buf, size_t len, size_t stride)</td></tr>
<tr class="memdesc:a0a15d8fd6f923c1ec191b44afc93c1c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the given block to be paged into physical memory.  <a href="namespacekatana.html#a0a15d8fd6f923c1ec191b44afc93c1c7">More...</a><br /></td></tr>
<tr class="separator:a0a15d8fd6f923c1ec191b44afc93c1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44eef90a442ccc2bddcc5878dadcd712"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a44eef90a442ccc2bddcc5878dadcd712"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a44eef90a442ccc2bddcc5878dadcd712">atomicMax</a> (std::atomic&lt; T &gt; &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a44eef90a442ccc2bddcc5878dadcd712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07d172fe8abf6b293db153ca1700131"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad07d172fe8abf6b293db153ca1700131"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ad07d172fe8abf6b293db153ca1700131">atomicMin</a> (std::atomic&lt; T &gt; &amp;a, const T &amp;b)</td></tr>
<tr class="separator:ad07d172fe8abf6b293db153ca1700131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef794a8be1062171ff176b4b2b37931d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aef794a8be1062171ff176b4b2b37931d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aef794a8be1062171ff176b4b2b37931d">atomicAdd</a> (std::atomic&lt; T &gt; &amp;a, const T &amp;b, std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &gt; *=nullptr)</td></tr>
<tr class="separator:aef794a8be1062171ff176b4b2b37931d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1b28c2c66d52c79ee4db904b631c9d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1c1b28c2c66d52c79ee4db904b631c9d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a1c1b28c2c66d52c79ee4db904b631c9d">atomicAdd</a> (std::atomic&lt; T &gt; &amp;a, const T &amp;b, std::enable_if_t&lt;!std::is_integral_v&lt; T &gt; &gt; *=nullptr)</td></tr>
<tr class="separator:a1c1b28c2c66d52c79ee4db904b631c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5c06554a539e9ba834cd4099e58564"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7e5c06554a539e9ba834cd4099e58564"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a7e5c06554a539e9ba834cd4099e58564">atomicSub</a> (std::atomic&lt; T &gt; &amp;a, const T &amp;b, std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &gt; *=nullptr)</td></tr>
<tr class="separator:a7e5c06554a539e9ba834cd4099e58564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0014b18f0cd2aae01375d6139ecc2660"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0014b18f0cd2aae01375d6139ecc2660"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a0014b18f0cd2aae01375d6139ecc2660">atomicSub</a> (std::atomic&lt; T &gt; &amp;a, const T &amp;b, std::enable_if_t&lt;!std::is_integral_v&lt; T &gt; &gt; *=nullptr)</td></tr>
<tr class="separator:a0014b18f0cd2aae01375d6139ecc2660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab473e662b3aed5db12ebd185fca76f11"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="classkatana_1_1Barrier.html">Barrier</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ab473e662b3aed5db12ebd185fca76f11">GetBarrier</a> (unsigned active_threads)</td></tr>
<tr class="memdesc:ab473e662b3aed5db12ebd185fca76f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to system barrier.  <a href="namespacekatana.html#ab473e662b3aed5db12ebd185fca76f11">More...</a><br /></td></tr>
<tr class="separator:ab473e662b3aed5db12ebd185fca76f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90464688cec2043a116bcdd6eba61b78"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT std::unique_ptr&lt; <a class="el" href="classkatana_1_1Barrier.html">Barrier</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a90464688cec2043a116bcdd6eba61b78">CreateMCSBarrier</a> (unsigned)</td></tr>
<tr class="memdesc:a90464688cec2043a116bcdd6eba61b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create specific types of barriers.  <a href="namespacekatana.html#a90464688cec2043a116bcdd6eba61b78">More...</a><br /></td></tr>
<tr class="separator:a90464688cec2043a116bcdd6eba61b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af030ab004a8288eb76f0ef66834c1c02"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT std::unique_ptr&lt; <a class="el" href="classkatana_1_1Barrier.html">Barrier</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#af030ab004a8288eb76f0ef66834c1c02">CreateTopoBarrier</a> (unsigned)</td></tr>
<tr class="separator:af030ab004a8288eb76f0ef66834c1c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1412ef1a9aae93857afd724ed8a1b7"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT std::unique_ptr&lt; <a class="el" href="classkatana_1_1Barrier.html">Barrier</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aea1412ef1a9aae93857afd724ed8a1b7">CreateCountingBarrier</a> (unsigned)</td></tr>
<tr class="separator:aea1412ef1a9aae93857afd724ed8a1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b230a1d5e98eebb129da3fdff8f3963"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT std::unique_ptr&lt; <a class="el" href="classkatana_1_1Barrier.html">Barrier</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a1b230a1d5e98eebb129da3fdff8f3963">CreateDisseminationBarrier</a> (unsigned)</td></tr>
<tr class="separator:a1b230a1d5e98eebb129da3fdff8f3963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427f77208349841b073228fd4a28022d"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT std::unique_ptr&lt; <a class="el" href="classkatana_1_1Barrier.html">Barrier</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a427f77208349841b073228fd4a28022d">CreateSimpleBarrier</a> (unsigned)</td></tr>
<tr class="memdesc:a427f77208349841b073228fd4a28022d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new simple barrier.  <a href="namespacekatana.html#a427f77208349841b073228fd4a28022d">More...</a><br /></td></tr>
<tr class="separator:a427f77208349841b073228fd4a28022d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a29993f22074dde5cfcfaa0d500c0c"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a09a29993f22074dde5cfcfaa0d500c0c">WritePropertyGraph</a> (const <a class="el" href="structkatana_1_1GraphComponents.html">GraphComponents</a> &amp;graph_comps, const std::string &amp;dir)</td></tr>
<tr class="memdesc:a09a29993f22074dde5cfcfaa0d500c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">WritePropertyGraph writes an RDG from the provided.  <a href="namespacekatana.html#a09a29993f22074dde5cfcfaa0d500c0c">More...</a><br /></td></tr>
<tr class="separator:a09a29993f22074dde5cfcfaa0d500c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad689f7fed45edd01461b6ccc9f7fd8e4"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ad689f7fed45edd01461b6ccc9f7fd8e4">WritePropertyGraph</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> prop_graph, const std::string &amp;dir)</td></tr>
<tr class="separator:ad689f7fed45edd01461b6ccc9f7fd8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1230aa54a2f09d6eef51d0ef55f28f1e"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT std::vector&lt; <a class="el" href="structkatana_1_1ImportData.html">ImportData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a1230aa54a2f09d6eef51d0ef55f28f1e">ArrowToImport</a> (const std::shared_ptr&lt; arrow::ChunkedArray &gt; &amp;arr)</td></tr>
<tr class="memdesc:a1230aa54a2f09d6eef51d0ef55f28f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Arrow chunked array to/from a vector of <a class="el" href="structkatana_1_1ImportData.html">ImportData</a>.  <a href="namespacekatana.html#a1230aa54a2f09d6eef51d0ef55f28f1e">More...</a><br /></td></tr>
<tr class="separator:a1230aa54a2f09d6eef51d0ef55f28f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fb96a271f2783315e394cd576d9a82"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; std::shared_ptr&lt; arrow::ChunkedArray &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#af3fb96a271f2783315e394cd576d9a82">ImportToArrow</a> (arrow::Type::type arrow_type, const std::vector&lt; <a class="el" href="structkatana_1_1ImportData.html">ImportData</a> &gt; &amp;import_src)</td></tr>
<tr class="separator:af3fb96a271f2783315e394cd576d9a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff9b9f83da21711106f1edba7c00d0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a2ff9b9f83da21711106f1edba7c00d0f">signalConflict</a> (<a class="el" href="classkatana_1_1Lockable.html">Lockable</a> *=nullptr)</td></tr>
<tr class="separator:a2ff9b9f83da21711106f1edba7c00d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558ccee2a8c1ffe3bef91fe5c6b67478"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a558ccee2a8c1ffe3bef91fe5c6b67478">signalFailSafe</a> (void)</td></tr>
<tr class="separator:a558ccee2a8c1ffe3bef91fe5c6b67478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b2b56d9557fc8ceefef836895765a7"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="classkatana_1_1SimpleRuntimeContext.html">SimpleRuntimeContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ab3b2b56d9557fc8ceefef836895765a7">getThreadContext</a> ()</td></tr>
<tr class="memdesc:ab3b2b56d9557fc8ceefef836895765a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the current conflict detection class, may be null if not in parallel region  <a href="namespacekatana.html#ab3b2b56d9557fc8ceefef836895765a7">More...</a><br /></td></tr>
<tr class="separator:ab3b2b56d9557fc8ceefef836895765a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4ffca2ccdc1c54f45f94808aac9306"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aad4ffca2ccdc1c54f45f94808aac9306">setThreadContext</a> (<a class="el" href="classkatana_1_1SimpleRuntimeContext.html">SimpleRuntimeContext</a> *n)</td></tr>
<tr class="memdesc:aad4ffca2ccdc1c54f45f94808aac9306"><td class="mdescLeft">&#160;</td><td class="mdescRight">used by the parallel code to set up conflict detection per thread  <a href="namespacekatana.html#aad4ffca2ccdc1c54f45f94808aac9306">More...</a><br /></td></tr>
<tr class="separator:aad4ffca2ccdc1c54f45f94808aac9306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55a084718d23d24da3e0fa3d2e4a75e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aa55a084718d23d24da3e0fa3d2e4a75e">shouldLock</a> (const <a class="el" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246">katana::MethodFlag</a> g)</td></tr>
<tr class="memdesc:aa55a084718d23d24da3e0fa3d2e4a75e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to decide if the conflict detection lock should be taken.  <a href="namespacekatana.html#aa55a084718d23d24da3e0fa3d2e4a75e">More...</a><br /></td></tr>
<tr class="separator:aa55a084718d23d24da3e0fa3d2e4a75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803887bcce7f07a73115db324810d629"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a803887bcce7f07a73115db324810d629">doAcquire</a> (<a class="el" href="classkatana_1_1Lockable.html">Lockable</a> *lockable, <a class="el" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246">katana::MethodFlag</a> m)</td></tr>
<tr class="memdesc:a803887bcce7f07a73115db324810d629"><td class="mdescLeft">&#160;</td><td class="mdescRight">actual locking function. Will always lock.  <a href="namespacekatana.html#a803887bcce7f07a73115db324810d629">More...</a><br /></td></tr>
<tr class="separator:a803887bcce7f07a73115db324810d629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d59247a304c083855ea74a9cd24205"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a79d59247a304c083855ea74a9cd24205">acquire</a> (<a class="el" href="classkatana_1_1Lockable.html">Lockable</a> *lockable, <a class="el" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246">katana::MethodFlag</a> m)</td></tr>
<tr class="memdesc:a79d59247a304c083855ea74a9cd24205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Master function which handles conflict detection used to acquire a lockable thing.  <a href="namespacekatana.html#a79d59247a304c083855ea74a9cd24205">More...</a><br /></td></tr>
<tr class="separator:a79d59247a304c083855ea74a9cd24205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014df3be01efa8912d944df28bdf9079"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a014df3be01efa8912d944df28bdf9079">EnvCheck</a> (const char *varName)</td></tr>
<tr class="memdesc:a014df3be01efa8912d944df28bdf9079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the Enviroment variable is set.  <a href="namespacekatana.html#a014df3be01efa8912d944df28bdf9079">More...</a><br /></td></tr>
<tr class="separator:a014df3be01efa8912d944df28bdf9079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2562dde224ecf03d557e61f0e43b45f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a2562dde224ecf03d557e61f0e43b45f7">EnvCheck</a> (const std::string &amp;varName)</td></tr>
<tr class="separator:a2562dde224ecf03d557e61f0e43b45f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3dd97ad6b73068f9718c1d9a68adb8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4d3dd97ad6b73068f9718c1d9a68adb8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a4d3dd97ad6b73068f9718c1d9a68adb8">EnvCheck</a> (const char *varName, T &amp;retVal)</td></tr>
<tr class="memdesc:a4d3dd97ad6b73068f9718c1d9a68adb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if Enviroment variable is set, and extract its value into 'retVal' parameter.  <a href="namespacekatana.html#a4d3dd97ad6b73068f9718c1d9a68adb8">More...</a><br /></td></tr>
<tr class="separator:a4d3dd97ad6b73068f9718c1d9a68adb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc7595978b215ac8411ffac375155f0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abcc7595978b215ac8411ffac375155f0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#abcc7595978b215ac8411ffac375155f0">EnvCheck</a> (const std::string &amp;varName, T &amp;retVal)</td></tr>
<tr class="separator:abcc7595978b215ac8411ffac375155f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ff620616f4ea17557e618f51f7d7f7"><td class="memTemplParams" colspan="2">template&lt;typename R , typename F , typename ArgsTuple &gt; </td></tr>
<tr class="memitem:a23ff620616f4ea17557e618f51f7d7f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a23ff620616f4ea17557e618f51f7d7f7">do_all_gen</a> (const R &amp;range, F &amp;&amp;func, const ArgsTuple &amp;argsTuple)</td></tr>
<tr class="separator:a23ff620616f4ea17557e618f51f7d7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442cf800869fdedc926894feecc5df21"><td class="memTemplParams" colspan="2">template&lt;typename WLTy &gt; </td></tr>
<tr class="memitem:a442cf800869fdedc926894feecc5df21"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a442cf800869fdedc926894feecc5df21">has_with_iterator</a> (int) -&gt; decltype(std::declval&lt; typename WLTy::template with_iterator&lt; int * &gt;::type &gt;(), bool())</td></tr>
<tr class="separator:a442cf800869fdedc926894feecc5df21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6887981974026f0de7127ee8bdd290ca"><td class="memTemplParams" colspan="2">template&lt;typename &gt; </td></tr>
<tr class="memitem:a6887981974026f0de7127ee8bdd290ca"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a6887981974026f0de7127ee8bdd290ca">has_with_iterator</a> (...) -&gt; bool</td></tr>
<tr class="separator:a6887981974026f0de7127ee8bdd290ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1bb8b9db99383005c03685212ceeac"><td class="memTemplParams" colspan="2">template&lt;typename RangeTy , typename FunctionTy , typename ArgsTy &gt; </td></tr>
<tr class="memitem:a7f1bb8b9db99383005c03685212ceeac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a7f1bb8b9db99383005c03685212ceeac">for_each_impl</a> (const RangeTy &amp;range, FunctionTy &amp;&amp;fn, const ArgsTy &amp;args)</td></tr>
<tr class="separator:a7f1bb8b9db99383005c03685212ceeac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cdf1268c8feb6ae8c3a2ecd81e7a92"><td class="memTemplParams" colspan="2">template&lt;typename RangeTy , typename FunctionTy , typename TupleTy &gt; </td></tr>
<tr class="memitem:a07cdf1268c8feb6ae8c3a2ecd81e7a92"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a07cdf1268c8feb6ae8c3a2ecd81e7a92">for_each_gen</a> (const RangeTy &amp;r, FunctionTy &amp;&amp;fn, const TupleTy &amp;tpl)</td></tr>
<tr class="memdesc:a07cdf1268c8feb6ae8c3a2ecd81e7a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize arguments to for_each.  <a href="namespacekatana.html#a07cdf1268c8feb6ae8c3a2ecd81e7a92">More...</a><br /></td></tr>
<tr class="separator:a07cdf1268c8feb6ae8c3a2ecd81e7a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac585b92d00974dfa0ed6125b0de1edd3"><td class="memTemplParams" colspan="2">template&lt;typename FunctionTy , typename TupleTy &gt; </td></tr>
<tr class="memitem:ac585b92d00974dfa0ed6125b0de1edd3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ac585b92d00974dfa0ed6125b0de1edd3">on_each_gen</a> (FunctionTy &amp;&amp;fn, const TupleTy &amp;tpl)</td></tr>
<tr class="separator:ac585b92d00974dfa0ed6125b0de1edd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2407e5b93c52b1c6be5107580fb0fcba"><td class="memTemplParams" colspan="2">template&lt;typename Iter , typename Cmp , typename NhFunc , typename OpFunc &gt; </td></tr>
<tr class="memitem:a2407e5b93c52b1c6be5107580fb0fcba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a2407e5b93c52b1c6be5107580fb0fcba">for_each_ordered_impl</a> ([[maybe_unused]] Iter beg, [[maybe_unused]] Iter end, [[maybe_unused]] const Cmp &amp;cmp, [[maybe_unused]] const NhFunc &amp;nhFunc, [[maybe_unused]] const OpFunc &amp;opFunc, [[maybe_unused]] const char *<a class="el" href="structkatana_1_1loopname.html">loopname</a>)</td></tr>
<tr class="separator:a2407e5b93c52b1c6be5107580fb0fcba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088d4fa047c30338d94d9380ffe0cc9a"><td class="memTemplParams" colspan="2">template&lt;typename Iter , typename Cmp , typename NhFunc , typename OpFunc , typename StableTest &gt; </td></tr>
<tr class="memitem:a088d4fa047c30338d94d9380ffe0cc9a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a088d4fa047c30338d94d9380ffe0cc9a">for_each_ordered_impl</a> ([[maybe_unused]] Iter beg, [[maybe_unused]] Iter end, [[maybe_unused]] const Cmp &amp;cmp, [[maybe_unused]] const NhFunc &amp;nhFunc, [[maybe_unused]] const OpFunc &amp;opFunc, [[maybe_unused]] const StableTest &amp;stabilityTest, [[maybe_unused]] const char *<a class="el" href="structkatana_1_1loopname.html">loopname</a>)</td></tr>
<tr class="separator:a088d4fa047c30338d94d9380ffe0cc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52dd4ebbf1e2af362f49bd230c2ef11e"><td class="memTemplParams" colspan="2">template&lt;typename R , typename F , typename ArgsTuple &gt; </td></tr>
<tr class="memitem:a52dd4ebbf1e2af362f49bd230c2ef11e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a52dd4ebbf1e2af362f49bd230c2ef11e">for_each_ParaMeter</a> (const R &amp;range, const F &amp;func, const ArgsTuple &amp;argsTuple)</td></tr>
<tr class="memdesc:a52dd4ebbf1e2af362f49bd230c2ef11e"><td class="mdescLeft">&#160;</td><td class="mdescRight">invoke <a class="el" href="classkatana_1_1ParaMeter.html">ParaMeter</a> tool to execute a for_each style loop  <a href="namespacekatana.html#a52dd4ebbf1e2af362f49bd230c2ef11e">More...</a><br /></td></tr>
<tr class="separator:a52dd4ebbf1e2af362f49bd230c2ef11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cace38383289e96c798eae2910607ba"><td class="memTemplParams" colspan="2">template&lt;typename EdgeTy &gt; </td></tr>
<tr class="memitem:a3cace38383289e96c798eae2910607ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a3cace38383289e96c798eae2910607ba">makeSymmetric</a> (<a class="el" href="classkatana_1_1FileGraph.html">FileGraph</a> &amp;in_graph, <a class="el" href="classkatana_1_1FileGraph.html">FileGraph</a> &amp;out)</td></tr>
<tr class="memdesc:a3cace38383289e96c798eae2910607ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds reverse edges to a graph.  <a href="namespacekatana.html#a3cace38383289e96c798eae2910607ba">More...</a><br /></td></tr>
<tr class="separator:a3cace38383289e96c798eae2910607ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c51e3da13cd969a7739672414ff782"><td class="memTemplParams" colspan="2">template&lt;typename EdgeTy , typename PTy &gt; </td></tr>
<tr class="memitem:ad0c51e3da13cd969a7739672414ff782"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ad0c51e3da13cd969a7739672414ff782">permute</a> (<a class="el" href="classkatana_1_1FileGraph.html">FileGraph</a> &amp;in_graph, const PTy &amp;p, <a class="el" href="classkatana_1_1FileGraph.html">FileGraph</a> &amp;out)</td></tr>
<tr class="memdesc:ad0c51e3da13cd969a7739672414ff782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutes a graph.  <a href="namespacekatana.html#ad0c51e3da13cd969a7739672414ff782">More...</a><br /></td></tr>
<tr class="separator:ad0c51e3da13cd969a7739672414ff782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fcec56089b5a660692cb46edf8dc752"><td class="memTemplParams" colspan="2">template&lt;typename _Key , typename _Tp , typename _Compare , typename _Alloc &gt; </td></tr>
<tr class="memitem:a2fcec56089b5a660692cb46edf8dc752"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a2fcec56089b5a660692cb46edf8dc752">operator==</a> (const <a class="el" href="classkatana_1_1flat__map.html">flat_map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;__x, const <a class="el" href="classkatana_1_1flat__map.html">flat_map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;__y)</td></tr>
<tr class="separator:a2fcec56089b5a660692cb46edf8dc752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afa875499adf7ad280de4db979e0d9c"><td class="memTemplParams" colspan="2">template&lt;typename _Key , typename _Tp , typename _Compare , typename _Alloc &gt; </td></tr>
<tr class="memitem:a2afa875499adf7ad280de4db979e0d9c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a2afa875499adf7ad280de4db979e0d9c">operator&lt;</a> (const <a class="el" href="classkatana_1_1flat__map.html">flat_map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;__x, const <a class="el" href="classkatana_1_1flat__map.html">flat_map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;__y)</td></tr>
<tr class="separator:a2afa875499adf7ad280de4db979e0d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6c952f5532ec6da9758747964fcb40"><td class="memTemplParams" colspan="2">template&lt;typename _Key , typename _Tp , typename _Compare , typename _Alloc &gt; </td></tr>
<tr class="memitem:a4b6c952f5532ec6da9758747964fcb40"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a4b6c952f5532ec6da9758747964fcb40">operator!=</a> (const <a class="el" href="classkatana_1_1flat__map.html">flat_map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;__x, const <a class="el" href="classkatana_1_1flat__map.html">flat_map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;__y)</td></tr>
<tr class="memdesc:a4b6c952f5532ec6da9758747964fcb40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Based on operator==.  <a href="namespacekatana.html#a4b6c952f5532ec6da9758747964fcb40">More...</a><br /></td></tr>
<tr class="separator:a4b6c952f5532ec6da9758747964fcb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e02e7ae665499588153f5e5d7d2b058"><td class="memTemplParams" colspan="2">template&lt;typename _Key , typename _Tp , typename _Compare , typename _Alloc &gt; </td></tr>
<tr class="memitem:a9e02e7ae665499588153f5e5d7d2b058"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a9e02e7ae665499588153f5e5d7d2b058">operator&gt;</a> (const <a class="el" href="classkatana_1_1flat__map.html">flat_map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;__x, const <a class="el" href="classkatana_1_1flat__map.html">flat_map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;__y)</td></tr>
<tr class="memdesc:a9e02e7ae665499588153f5e5d7d2b058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Based on operator&lt;.  <a href="namespacekatana.html#a9e02e7ae665499588153f5e5d7d2b058">More...</a><br /></td></tr>
<tr class="separator:a9e02e7ae665499588153f5e5d7d2b058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289d560dd3972a6de16cf3012aad4abc"><td class="memTemplParams" colspan="2">template&lt;typename _Key , typename _Tp , typename _Compare , typename _Alloc &gt; </td></tr>
<tr class="memitem:a289d560dd3972a6de16cf3012aad4abc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a289d560dd3972a6de16cf3012aad4abc">operator&lt;=</a> (const <a class="el" href="classkatana_1_1flat__map.html">flat_map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;__x, const <a class="el" href="classkatana_1_1flat__map.html">flat_map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;__y)</td></tr>
<tr class="memdesc:a289d560dd3972a6de16cf3012aad4abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Based on operator&lt;.  <a href="namespacekatana.html#a289d560dd3972a6de16cf3012aad4abc">More...</a><br /></td></tr>
<tr class="separator:a289d560dd3972a6de16cf3012aad4abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27cce37579812e3a0630215786153a35"><td class="memTemplParams" colspan="2">template&lt;typename _Key , typename _Tp , typename _Compare , typename _Alloc &gt; </td></tr>
<tr class="memitem:a27cce37579812e3a0630215786153a35"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a27cce37579812e3a0630215786153a35">operator&gt;=</a> (const <a class="el" href="classkatana_1_1flat__map.html">flat_map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;__x, const <a class="el" href="classkatana_1_1flat__map.html">flat_map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;__y)</td></tr>
<tr class="memdesc:a27cce37579812e3a0630215786153a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Based on operator&lt;.  <a href="namespacekatana.html#a27cce37579812e3a0630215786153a35">More...</a><br /></td></tr>
<tr class="separator:a27cce37579812e3a0630215786153a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8448775f95d8f5f84f67fc3543c986aa"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a8448775f95d8f5f84f67fc3543c986aa">gPrintStr</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a8448775f95d8f5f84f67fc3543c986aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a string.  <a href="namespacekatana.html#a8448775f95d8f5f84f67fc3543c986aa">More...</a><br /></td></tr>
<tr class="separator:a8448775f95d8f5f84f67fc3543c986aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34b94357c92675be0e31ad0fb116ae3"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#af34b94357c92675be0e31ad0fb116ae3">gInfoStr</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:af34b94357c92675be0e31ad0fb116ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints an info string (for easy parsing)  <a href="namespacekatana.html#af34b94357c92675be0e31ad0fb116ae3">More...</a><br /></td></tr>
<tr class="separator:af34b94357c92675be0e31ad0fb116ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef56b3b4315cd5dc1fee0f54cf1ab1c"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#afef56b3b4315cd5dc1fee0f54cf1ab1c">gWarnStr</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:afef56b3b4315cd5dc1fee0f54cf1ab1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a warning string (for easy parsing)  <a href="namespacekatana.html#afef56b3b4315cd5dc1fee0f54cf1ab1c">More...</a><br /></td></tr>
<tr class="separator:afef56b3b4315cd5dc1fee0f54cf1ab1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8b891e19c866ef156a1cabcea8be9c"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a8d8b891e19c866ef156a1cabcea8be9c">gDebugStr</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a8d8b891e19c866ef156a1cabcea8be9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a debug string (for easy parsing)  <a href="namespacekatana.html#a8d8b891e19c866ef156a1cabcea8be9c">More...</a><br /></td></tr>
<tr class="separator:a8d8b891e19c866ef156a1cabcea8be9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f49903b7bc8262326131192fd549f5c"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a6f49903b7bc8262326131192fd549f5c">gErrorStr</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a6f49903b7bc8262326131192fd549f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints an error string (for easy parsing)  <a href="namespacekatana.html#a6f49903b7bc8262326131192fd549f5c">More...</a><br /></td></tr>
<tr class="separator:a6f49903b7bc8262326131192fd549f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a037b52985c7525482de34e3b824cb3"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a2a037b52985c7525482de34e3b824cb3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a2a037b52985c7525482de34e3b824cb3">gPrint</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a2a037b52985c7525482de34e3b824cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a sequence of things.  <a href="namespacekatana.html#a2a037b52985c7525482de34e3b824cb3">More...</a><br /></td></tr>
<tr class="separator:a2a037b52985c7525482de34e3b824cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f23e8a11feacf0fd0703a147a832d42"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a4f23e8a11feacf0fd0703a147a832d42"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a4f23e8a11feacf0fd0703a147a832d42">gInfo</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a4f23e8a11feacf0fd0703a147a832d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints an info string from a sequence of things.  <a href="namespacekatana.html#a4f23e8a11feacf0fd0703a147a832d42">More...</a><br /></td></tr>
<tr class="separator:a4f23e8a11feacf0fd0703a147a832d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a8080a1591799040110afb3ea8e126"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a48a8080a1591799040110afb3ea8e126"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a48a8080a1591799040110afb3ea8e126">gWarn</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a48a8080a1591799040110afb3ea8e126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a warning string from a sequence of things.  <a href="namespacekatana.html#a48a8080a1591799040110afb3ea8e126">More...</a><br /></td></tr>
<tr class="separator:a48a8080a1591799040110afb3ea8e126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6602e81c46161e71a631d2c035c91f6"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ae6602e81c46161e71a631d2c035c91f6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ae6602e81c46161e71a631d2c035c91f6">gDebug</a> ([[maybe_unused]] Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ae6602e81c46161e71a631d2c035c91f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a debug string from a sequence of things; prints nothing if NDEBUG is defined.  <a href="namespacekatana.html#ae6602e81c46161e71a631d2c035c91f6">More...</a><br /></td></tr>
<tr class="separator:ae6602e81c46161e71a631d2c035c91f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b1ae9ac161220e35ed86fddb6e7463"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a42b1ae9ac161220e35ed86fddb6e7463"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a42b1ae9ac161220e35ed86fddb6e7463">gError</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a42b1ae9ac161220e35ed86fddb6e7463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints error message.  <a href="namespacekatana.html#a42b1ae9ac161220e35ed86fddb6e7463">More...</a><br /></td></tr>
<tr class="separator:a42b1ae9ac161220e35ed86fddb6e7463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff847e10bab466e217c9fe4c0020ec00"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aff847e10bab466e217c9fe4c0020ec00">gFlush</a> ()</td></tr>
<tr class="separator:aff847e10bab466e217c9fe4c0020ec00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9556696505c9936a648c93a1c9d80b6"><td class="memTemplParams" colspan="2">template&lt;typename PrefixSumType , typename NodeType  = uint64_t&gt; </td></tr>
<tr class="memitem:aa9556696505c9936a648c93a1c9d80b6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aa9556696505c9936a648c93a1c9d80b6">divideNodesBinarySearch</a> (<a class="el" href="async_8cpp.html#ab77c64e1d2710678e2f5d9918ff2f8ea">NodeType</a> numNodes, uint64_t numEdges, size_t nodeWeight, size_t edgeWeight, size_t id, size_t total, PrefixSumType &amp;edgePrefixSum, std::vector&lt; unsigned &gt; scaleFactor=std::vector&lt; unsigned &gt;(), uint64_t edgeOffset=0, uint64_t nodeOffset=0)</td></tr>
<tr class="memdesc:aa9556696505c9936a648c93a1c9d80b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 2 ranges (one for nodes, one for edges) for a particular division.  <a href="namespacekatana.html#aa9556696505c9936a648c93a1c9d80b6">More...</a><br /></td></tr>
<tr class="separator:aa9556696505c9936a648c93a1c9d80b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8637bfb06d4ed0899eb6ec2090f3129d"><td class="memTemplParams" colspan="2">template&lt;typename GraphTy &gt; </td></tr>
<tr class="memitem:a8637bfb06d4ed0899eb6ec2090f3129d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint32_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a8637bfb06d4ed0899eb6ec2090f3129d">determineUnitRangesFromGraph</a> (GraphTy &amp;graph, uint32_t unitsToSplit, uint32_t nodeAlpha=0)</td></tr>
<tr class="memdesc:a8637bfb06d4ed0899eb6ec2090f3129d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines node division ranges for all nodes in a graph and returns it in an offset vector.  <a href="namespacekatana.html#a8637bfb06d4ed0899eb6ec2090f3129d">More...</a><br /></td></tr>
<tr class="separator:a8637bfb06d4ed0899eb6ec2090f3129d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df01f742edb20057d834294ccab02c2"><td class="memTemplParams" colspan="2">template&lt;typename GraphTy &gt; </td></tr>
<tr class="memitem:a9df01f742edb20057d834294ccab02c2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint32_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a9df01f742edb20057d834294ccab02c2">determineUnitRangesFromGraph</a> (GraphTy &amp;graph, uint32_t unitsToSplit, uint32_t beginNode, uint32_t endNode, uint32_t nodeAlpha=0)</td></tr>
<tr class="memdesc:a9df01f742edb20057d834294ccab02c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines node division ranges for a given range of nodes and returns it as an offset vector.  <a href="namespacekatana.html#a9df01f742edb20057d834294ccab02c2">More...</a><br /></td></tr>
<tr class="separator:a9df01f742edb20057d834294ccab02c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49ce4076f90629479d086480527eb3c"><td class="memTemplParams" colspan="2">template&lt;typename VectorTy &gt; </td></tr>
<tr class="memitem:ae49ce4076f90629479d086480527eb3c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint32_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ae49ce4076f90629479d086480527eb3c">determineUnitRangesFromPrefixSum</a> (uint32_t unitsToSplit, VectorTy &amp;edgePrefixSum, uint64_t numNodes, uint32_t nodeAlpha=0)</td></tr>
<tr class="memdesc:ae49ce4076f90629479d086480527eb3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the divideByNode function (which is binary search based) to divide nodes among units using a provided prefix sum.  <a href="namespacekatana.html#ae49ce4076f90629479d086480527eb3c">More...</a><br /></td></tr>
<tr class="separator:ae49ce4076f90629479d086480527eb3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5333d119c05232d54b6534f1ac505726"><td class="memTemplParams" colspan="2">template&lt;typename VectorTy &gt; </td></tr>
<tr class="memitem:a5333d119c05232d54b6534f1ac505726"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint32_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a5333d119c05232d54b6534f1ac505726">determineUnitRangesFromPrefixSum</a> (uint32_t unitsToSplit, VectorTy &amp;edgePrefixSum, uint32_t beginNode, uint32_t endNode, uint32_t nodeAlpha=0)</td></tr>
<tr class="memdesc:a5333d119c05232d54b6534f1ac505726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the divideByNode function (which is binary search based) to divide nodes among units using a provided prefix sum.  <a href="namespacekatana.html#a5333d119c05232d54b6534f1ac505726">More...</a><br /></td></tr>
<tr class="separator:a5333d119c05232d54b6534f1ac505726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a384c411cf25b6d8cf613fba36d7155"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; <a class="el" href="structkatana_1_1GraphComponents.html">katana::GraphComponents</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a9a384c411cf25b6d8cf613fba36d7155">ConvertGraphML</a> (const std::string &amp;infilename, size_t <a class="el" href="structkatana_1_1chunk__size.html">chunk_size</a>=25000, bool verbose=false)</td></tr>
<tr class="memdesc:a9a384c411cf25b6d8cf613fba36d7155"><td class="mdescLeft">&#160;</td><td class="mdescRight">ConvertGraphML converts a GraphML file into katana form.  <a href="namespacekatana.html#a9a384c411cf25b6d8cf613fba36d7155">More...</a><br /></td></tr>
<tr class="separator:a9a384c411cf25b6d8cf613fba36d7155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aae0060c80a59049d4b9d1f357c5e35"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:a9aae0060c80a59049d4b9d1f357c5e35"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a9aae0060c80a59049d4b9d1f357c5e35">makeIterRange</a> (const I &amp;beg, const I &amp;end)</td></tr>
<tr class="separator:a9aae0060c80a59049d4b9d1f357c5e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c17b5ead43129af22d05193c8cb662"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:aa0c17b5ead43129af22d05193c8cb662"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aa0c17b5ead43129af22d05193c8cb662">makeIterRange</a> (C &amp;&amp;cont)</td></tr>
<tr class="separator:aa0c17b5ead43129af22d05193c8cb662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad210855f190f658eb311b71f9d7b20c1"><td class="memTemplParams" colspan="2">template&lt;typename IterTy , class Distance &gt; </td></tr>
<tr class="memitem:ad210855f190f658eb311b71f9d7b20c1"><td class="memTemplItemLeft" align="right" valign="top">IterTy&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ad210855f190f658eb311b71f9d7b20c1">safe_advance_dispatch</a> (IterTy b, IterTy e, Distance n, std::random_access_iterator_tag)</td></tr>
<tr class="separator:ad210855f190f658eb311b71f9d7b20c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6c6ce37bb694723f64f2ff07d7d9c2"><td class="memTemplParams" colspan="2">template&lt;typename IterTy , class Distance &gt; </td></tr>
<tr class="memitem:a8e6c6ce37bb694723f64f2ff07d7d9c2"><td class="memTemplItemLeft" align="right" valign="top">IterTy&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a8e6c6ce37bb694723f64f2ff07d7d9c2">safe_advance_dispatch</a> (IterTy b, IterTy e, Distance n, std::input_iterator_tag)</td></tr>
<tr class="separator:a8e6c6ce37bb694723f64f2ff07d7d9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffe512028c1d9966fe6c33faed802e0"><td class="memTemplParams" colspan="2">template&lt;typename IterTy , class Distance &gt; </td></tr>
<tr class="memitem:afffe512028c1d9966fe6c33faed802e0"><td class="memTemplItemLeft" align="right" valign="top">IterTy&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#afffe512028c1d9966fe6c33faed802e0">safe_advance</a> (IterTy b, IterTy e, Distance n)</td></tr>
<tr class="memdesc:afffe512028c1d9966fe6c33faed802e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like std::advance but returns end if end is closer than the advance amount.  <a href="namespacekatana.html#afffe512028c1d9966fe6c33faed802e0">More...</a><br /></td></tr>
<tr class="separator:afffe512028c1d9966fe6c33faed802e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a93b4e45b04e6893ddacadc06dd9837"><td class="memTemplParams" colspan="2">template&lt;typename IterTy &gt; </td></tr>
<tr class="memitem:a4a93b4e45b04e6893ddacadc06dd9837"><td class="memTemplItemLeft" align="right" valign="top">IterTy&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a4a93b4e45b04e6893ddacadc06dd9837">split_range</a> (IterTy b, IterTy e)</td></tr>
<tr class="memdesc:a4a93b4e45b04e6893ddacadc06dd9837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the midpoint of a range.  <a href="namespacekatana.html#a4a93b4e45b04e6893ddacadc06dd9837">More...</a><br /></td></tr>
<tr class="separator:a4a93b4e45b04e6893ddacadc06dd9837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345761715af2a1d97b495d52aa46cc59"><td class="memTemplParams" colspan="2">template&lt;typename IterTy , typename std::enable_if&lt;!std::is_integral&lt; IterTy &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a345761715af2a1d97b495d52aa46cc59"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; IterTy, IterTy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a345761715af2a1d97b495d52aa46cc59">block_range</a> (IterTy b, IterTy e, unsigned id, unsigned num)</td></tr>
<tr class="memdesc:a345761715af2a1d97b495d52aa46cc59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a continuous block from the range based on the number of divisions and the id of the block requested.  <a href="namespacekatana.html#a345761715af2a1d97b495d52aa46cc59">More...</a><br /></td></tr>
<tr class="separator:a345761715af2a1d97b495d52aa46cc59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35d4fcb06589c0877a7ee1868e69be9"><td class="memTemplParams" colspan="2">template&lt;typename IntTy , typename std::enable_if&lt; std::is_integral&lt; IntTy &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:aa35d4fcb06589c0877a7ee1868e69be9"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; IntTy, IntTy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aa35d4fcb06589c0877a7ee1868e69be9">block_range</a> (IntTy b, IntTy e, unsigned id, unsigned num)</td></tr>
<tr class="separator:aa35d4fcb06589c0877a7ee1868e69be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdef1706a232c3c2422532fe231ffaf2"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:acdef1706a232c3c2422532fe231ffaf2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!std::is_scalar&lt; internal::Val_ty&lt; I &gt; &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#acdef1706a232c3c2422532fe231ffaf2">uninitialized_destroy</a> (I first, I last)</td></tr>
<tr class="memdesc:acdef1706a232c3c2422532fe231ffaf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a range.  <a href="namespacekatana.html#acdef1706a232c3c2422532fe231ffaf2">More...</a><br /></td></tr>
<tr class="separator:acdef1706a232c3c2422532fe231ffaf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8399d55ebc826ebe4e776fda5f3e7cb6"><td class="memTemplParams" colspan="2">template&lt;class I &gt; </td></tr>
<tr class="memitem:a8399d55ebc826ebe4e776fda5f3e7cb6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_scalar&lt; internal::Val_ty&lt; I &gt; &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a8399d55ebc826ebe4e776fda5f3e7cb6">uninitialized_destroy</a> (I, I)</td></tr>
<tr class="separator:a8399d55ebc826ebe4e776fda5f3e7cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442d543c6af5016fde65ba7dcdfa45e6"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="structkatana_1_1HWTopoInfo.html">HWTopoInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a442d543c6af5016fde65ba7dcdfa45e6">getHWTopo</a> ()</td></tr>
<tr class="memdesc:a442d543c6af5016fde65ba7dcdfa45e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">getHWTopo determines the machine topology from the process information exposed in /proc and /dev filesystems.  <a href="namespacekatana.html#a442d543c6af5016fde65ba7dcdfa45e6">More...</a><br /></td></tr>
<tr class="separator:a442d543c6af5016fde65ba7dcdfa45e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3836d9769215bd4dbf66eec37e1f646d"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a3836d9769215bd4dbf66eec37e1f646d">parseCPUList</a> (const std::string &amp;in)</td></tr>
<tr class="memdesc:a3836d9769215bd4dbf66eec37e1f646d"><td class="mdescLeft">&#160;</td><td class="mdescRight">parseCPUList parses cpuset information in "List format" as described in cpuset(7) and available under /proc/self/status  <a href="namespacekatana.html#a3836d9769215bd4dbf66eec37e1f646d">More...</a><br /></td></tr>
<tr class="separator:a3836d9769215bd4dbf66eec37e1f646d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ea5b7e9709ae81e07009f6575fe062"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a70ea5b7e9709ae81e07009f6575fe062">bindThreadSelf</a> ([[maybe_unused]] unsigned osContext)</td></tr>
<tr class="memdesc:a70ea5b7e9709ae81e07009f6575fe062"><td class="mdescLeft">&#160;</td><td class="mdescRight">bindThreadSelf binds a thread to an osContext as returned by getHWTopo.  <a href="namespacekatana.html#a70ea5b7e9709ae81e07009f6575fe062">More...</a><br /></td></tr>
<tr class="separator:a70ea5b7e9709ae81e07009f6575fe062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb855d38b5753d67def813f9a7edb81"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename FunctionTy , typename... Args&gt; </td></tr>
<tr class="memitem:a2eb855d38b5753d67def813f9a7edb81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81">for_each</a> (const Range &amp;range, FunctionTy &amp;&amp;fn, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a2eb855d38b5753d67def813f9a7edb81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Galois unordered set iterator.  <a href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81">More...</a><br /></td></tr>
<tr class="separator:a2eb855d38b5753d67def813f9a7edb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ea3b9de54b0c2f223eb585f4aefaff"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename FunctionTy , typename... Args&gt; </td></tr>
<tr class="memitem:ab9ea3b9de54b0c2f223eb585f4aefaff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ab9ea3b9de54b0c2f223eb585f4aefaff">do_all</a> (const Range &amp;range, FunctionTy &amp;&amp;fn, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab9ea3b9de54b0c2f223eb585f4aefaff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard do-all loop.  <a href="namespacekatana.html#ab9ea3b9de54b0c2f223eb585f4aefaff">More...</a><br /></td></tr>
<tr class="separator:ab9ea3b9de54b0c2f223eb585f4aefaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59063ef456c98bb4731b6ec5d9655d9"><td class="memTemplParams" colspan="2">template&lt;typename FunctionTy , typename... Args&gt; </td></tr>
<tr class="memitem:ae59063ef456c98bb4731b6ec5d9655d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ae59063ef456c98bb4731b6ec5d9655d9">on_each</a> (FunctionTy &amp;&amp;fn, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ae59063ef456c98bb4731b6ec5d9655d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level parallel loop.  <a href="namespacekatana.html#ae59063ef456c98bb4731b6ec5d9655d9">More...</a><br /></td></tr>
<tr class="separator:ae59063ef456c98bb4731b6ec5d9655d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e366c6edef650208b3372cb9ddabb05"><td class="memTemplParams" colspan="2">template&lt;typename Iter , typename Cmp , typename NhFunc , typename OpFunc &gt; </td></tr>
<tr class="memitem:a3e366c6edef650208b3372cb9ddabb05"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a3e366c6edef650208b3372cb9ddabb05">for_each_ordered</a> (Iter b, Iter e, const Cmp &amp;cmp, const NhFunc &amp;nhFunc, const OpFunc &amp;fn, const char *<a class="el" href="structkatana_1_1loopname.html">loopname</a>=0)</td></tr>
<tr class="memdesc:a3e366c6edef650208b3372cb9ddabb05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Galois ordered set iterator for stable source algorithms.  <a href="namespacekatana.html#a3e366c6edef650208b3372cb9ddabb05">More...</a><br /></td></tr>
<tr class="separator:a3e366c6edef650208b3372cb9ddabb05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad685991c897c0ec679acb4f752f5e203"><td class="memTemplParams" colspan="2">template&lt;typename Iter , typename Cmp , typename NhFunc , typename OpFunc , typename StableTest &gt; </td></tr>
<tr class="memitem:ad685991c897c0ec679acb4f752f5e203"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ad685991c897c0ec679acb4f752f5e203">for_each_ordered</a> (Iter b, Iter e, const Cmp &amp;cmp, const NhFunc &amp;nhFunc, const OpFunc &amp;fn, const StableTest &amp;stabilityTest, const char *<a class="el" href="structkatana_1_1loopname.html">loopname</a>=0)</td></tr>
<tr class="memdesc:ad685991c897c0ec679acb4f752f5e203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Galois ordered set iterator for unstable source algorithms.  <a href="namespacekatana.html#ad685991c897c0ec679acb4f752f5e203">More...</a><br /></td></tr>
<tr class="separator:ad685991c897c0ec679acb4f752f5e203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0246abc6c31e1172dc6533bcade08a"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#adf0246abc6c31e1172dc6533bcade08a">Prealloc</a> (size_t pagesPerThread, size_t bytes)</td></tr>
<tr class="memdesc:adf0246abc6c31e1172dc6533bcade08a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preallocates memory on each thread.  <a href="namespacekatana.html#adf0246abc6c31e1172dc6533bcade08a">More...</a><br /></td></tr>
<tr class="separator:adf0246abc6c31e1172dc6533bcade08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bdbb926af9a6d1a39e18d323a269386"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a7bdbb926af9a6d1a39e18d323a269386">Prealloc</a> (size_t pages)</td></tr>
<tr class="memdesc:a7bdbb926af9a6d1a39e18d323a269386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preallocates memory on each thread.  <a href="namespacekatana.html#a7bdbb926af9a6d1a39e18d323a269386">More...</a><br /></td></tr>
<tr class="separator:a7bdbb926af9a6d1a39e18d323a269386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037533772cd984719ae5476ee6a591d1"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a037533772cd984719ae5476ee6a591d1">EnsurePreallocated</a> (size_t pagesPerThread, size_t bytes)</td></tr>
<tr class="memdesc:a037533772cd984719ae5476ee6a591d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures an amount of memory be free on each thread.  <a href="namespacekatana.html#a037533772cd984719ae5476ee6a591d1">More...</a><br /></td></tr>
<tr class="separator:a037533772cd984719ae5476ee6a591d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1583134ee5266ec9d809fcf71fb8f7"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aee1583134ee5266ec9d809fcf71fb8f7">EnsurePreallocated</a> (size_t pages)</td></tr>
<tr class="memdesc:aee1583134ee5266ec9d809fcf71fb8f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures an amount of memory be free on each thread.  <a href="namespacekatana.html#aee1583134ee5266ec9d809fcf71fb8f7">More...</a><br /></td></tr>
<tr class="separator:aee1583134ee5266ec9d809fcf71fb8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ec431ab657dd2dae035358cb521f93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246">MethodFlag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a47ec431ab657dd2dae035358cb521f93">operator&amp;</a> (<a class="el" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246">MethodFlag</a> x, <a class="el" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246">MethodFlag</a> y)</td></tr>
<tr class="memdesc:a47ec431ab657dd2dae035358cb521f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise &amp; for method flags.  <a href="namespacekatana.html#a47ec431ab657dd2dae035358cb521f93">More...</a><br /></td></tr>
<tr class="separator:a47ec431ab657dd2dae035358cb521f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f097b8ee9ae3d62df8df4b421e58da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246">MethodFlag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a75f097b8ee9ae3d62df8df4b421e58da">operator|</a> (<a class="el" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246">MethodFlag</a> x, <a class="el" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246">MethodFlag</a> y)</td></tr>
<tr class="memdesc:a75f097b8ee9ae3d62df8df4b421e58da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise | for method flags.  <a href="namespacekatana.html#a75f097b8ee9ae3d62df8df4b421e58da">More...</a><br /></td></tr>
<tr class="separator:a75f097b8ee9ae3d62df8df4b421e58da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c4f58f277633fd887a386c2f4541dd"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a30c4f58f277633fd887a386c2f4541dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structkatana_1_1NoDerefIterator.html">NoDerefIterator</a>&lt; Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a30c4f58f277633fd887a386c2f4541dd">make_no_deref_iterator</a> (Iterator it)</td></tr>
<tr class="memdesc:a30c4f58f277633fd887a386c2f4541dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to create <a class="el" href="structkatana_1_1NoDerefIterator.html">NoDerefIterator</a>.  <a href="namespacekatana.html#a30c4f58f277633fd887a386c2f4541dd">More...</a><br /></td></tr>
<tr class="separator:a30c4f58f277633fd887a386c2f4541dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c14eb15c7de9cf907f6efe3318370c"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a35860f323cd4a2faf392c984e77ba618">LAptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ab8c14eb15c7de9cf907f6efe3318370c">largeMallocLocal</a> (size_t bytes)</td></tr>
<tr class="separator:ab8c14eb15c7de9cf907f6efe3318370c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967c41866a283f207458f1e2e4132d84"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a35860f323cd4a2faf392c984e77ba618">LAptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a967c41866a283f207458f1e2e4132d84">largeMallocFloating</a> (size_t bytes)</td></tr>
<tr class="separator:a967c41866a283f207458f1e2e4132d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd7ceb017df5d99dd3625300788bf36"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a35860f323cd4a2faf392c984e77ba618">LAptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a4cd7ceb017df5d99dd3625300788bf36">largeMallocInterleaved</a> (size_t bytes, unsigned numThreads)</td></tr>
<tr class="separator:a4cd7ceb017df5d99dd3625300788bf36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b1cc97c338a2607fab2d4c736dc4f0"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a35860f323cd4a2faf392c984e77ba618">LAptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ad9b1cc97c338a2607fab2d4c736dc4f0">largeMallocBlocked</a> (size_t bytes, unsigned numThreads)</td></tr>
<tr class="separator:ad9b1cc97c338a2607fab2d4c736dc4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72e3908a3e1dfe17e4c7f3d2b0fd70e"><td class="memTemplParams" colspan="2">template&lt;typename RangeArrayTy &gt; </td></tr>
<tr class="memitem:ae72e3908a3e1dfe17e4c7f3d2b0fd70e"><td class="memTemplItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a35860f323cd4a2faf392c984e77ba618">LAptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ae72e3908a3e1dfe17e4c7f3d2b0fd70e">largeMallocSpecified</a> (size_t bytes, uint32_t numThreads, RangeArrayTy &amp;threadRanges, size_t elementSize)</td></tr>
<tr class="memdesc:ae72e3908a3e1dfe17e4c7f3d2b0fd70e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates pages for some specified number of bytes, then does NUMA page faulting based on a specified distribution of elements among threads.  <a href="namespacekatana.html#ae72e3908a3e1dfe17e4c7f3d2b0fd70e">More...</a><br /></td></tr>
<tr class="separator:ae72e3908a3e1dfe17e4c7f3d2b0fd70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6aceb321ad842cc715abdbedf90665"><td class="memTemplParams" colspan="2">template&lt;typename GraphTy , typename... Args&gt; </td></tr>
<tr class="memitem:aec6aceb321ad842cc715abdbedf90665"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aec6aceb321ad842cc715abdbedf90665">readGraphDispatch</a> (GraphTy &amp;graph, <a class="el" href="structkatana_1_1read__oc__immutable__edge__graph__tag.html">read_oc_immutable_edge_graph_tag</a>, Args &amp;&amp;... args)</td></tr>
<tr class="separator:aec6aceb321ad842cc715abdbedf90665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7466f513f15c02ef5f9601f7cd40d370"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a7466f513f15c02ef5f9601f7cd40d370">allocSize</a> ()</td></tr>
<tr class="separator:a7466f513f15c02ef5f9601f7cd40d370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7940de2bae2976ddc9328f7fef9cf93b"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a7940de2bae2976ddc9328f7fef9cf93b">allocPages</a> (unsigned num, bool preFault)</td></tr>
<tr class="separator:a7940de2bae2976ddc9328f7fef9cf93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb6c47e78ad4854b7c68c14c2abd1b4"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#afcb6c47e78ad4854b7c68c14c2abd1b4">freePages</a> (void *ptr, unsigned num)</td></tr>
<tr class="separator:afcb6c47e78ad4854b7c68c14c2abd1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c8744364d257c6a5b8fac5bb264d1b"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a81c8744364d257c6a5b8fac5bb264d1b">pagePoolAlloc</a> ()</td></tr>
<tr class="memdesc:a81c8744364d257c6a5b8fac5bb264d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low level page pool (individual pages, use largeMalloc for large blocks)  <a href="namespacekatana.html#a81c8744364d257c6a5b8fac5bb264d1b">More...</a><br /></td></tr>
<tr class="separator:a81c8744364d257c6a5b8fac5bb264d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1d0d58b17cf84d1242bf128e390c43"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a5b1d0d58b17cf84d1242bf128e390c43">pagePoolFree</a> (void *)</td></tr>
<tr class="separator:a5b1d0d58b17cf84d1242bf128e390c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa938af62a145a49f37131b59ad9fe5e7"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aa938af62a145a49f37131b59ad9fe5e7">pagePoolPreAlloc</a> (unsigned)</td></tr>
<tr class="separator:aa938af62a145a49f37131b59ad9fe5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2d13303dc5a2b096784d47f173baca"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#abe2d13303dc5a2b096784d47f173baca">pagePoolEnsurePreallocated</a> (unsigned num)</td></tr>
<tr class="separator:abe2d13303dc5a2b096784d47f173baca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73caf8a4d244b5fcea67a4a39d6e4694"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a73caf8a4d244b5fcea67a4a39d6e4694">numPagePoolAllocTotal</a> ()</td></tr>
<tr class="memdesc:a73caf8a4d244b5fcea67a4a39d6e4694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns total large pages allocated by Galois memory management subsystem.  <a href="namespacekatana.html#a73caf8a4d244b5fcea67a4a39d6e4694">More...</a><br /></td></tr>
<tr class="separator:a73caf8a4d244b5fcea67a4a39d6e4694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618f26ad811ecbf556c183d92da75826"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a618f26ad811ecbf556c183d92da75826">numPagePoolAllocForThread</a> (unsigned tid)</td></tr>
<tr class="memdesc:a618f26ad811ecbf556c183d92da75826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns total large pages allocated for thread by Galois memory management subsystem.  <a href="namespacekatana.html#a618f26ad811ecbf556c183d92da75826">More...</a><br /></td></tr>
<tr class="separator:a618f26ad811ecbf556c183d92da75826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85a067a34f40d110114c041c079ab28"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="classkatana_1_1PerBackend.html">PerBackend</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aa85a067a34f40d110114c041c079ab28">getPTSBackend</a> ()</td></tr>
<tr class="separator:aa85a067a34f40d110114c041c079ab28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffbd5bd8ef554916a893b0b95ce2cf7"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="classkatana_1_1PerBackend.html">PerBackend</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a5ffbd5bd8ef554916a893b0b95ce2cf7">getPPSBackend</a> ()</td></tr>
<tr class="separator:a5ffbd5bd8ef554916a893b0b95ce2cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c87e9d7ccc6d22edbd8b77b5bd5c1bb"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a6c87e9d7ccc6d22edbd8b77b5bd5c1bb">initPTS</a> (unsigned maxT)</td></tr>
<tr class="separator:a6c87e9d7ccc6d22edbd8b77b5bd5c1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1acae7c4c5982885cb541db7faa5f22f"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a1acae7c4c5982885cb541db7faa5f22f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a1acae7c4c5982885cb541db7faa5f22f">profileVtune</a> (const F &amp;func, const char *region)</td></tr>
<tr class="separator:a1acae7c4c5982885cb541db7faa5f22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd798540cfe7c5d97e689d9502c1c639"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:abd798540cfe7c5d97e689d9502c1c639"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#abd798540cfe7c5d97e689d9502c1c639">profilePapi</a> (const F &amp;func, const char *region)</td></tr>
<tr class="separator:abd798540cfe7c5d97e689d9502c1c639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d3d3094b541b09751e28b4f60ca2ca"><td class="memTemplParams" colspan="2">template&lt;typename Prop &gt; </td></tr>
<tr class="memitem:a13d3d3094b541b09751e28b4f60ca2ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; <a class="el" href="namespacekatana.html#aaf4b21fee4699f8130e3178ba8f67bf7">PropertyViewType</a>&lt; Prop &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a13d3d3094b541b09751e28b4f60ca2ca">ConstructPropertyView</a> (arrow::Array *array)</td></tr>
<tr class="memdesc:a13d3d3094b541b09751e28b4f60ca2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">ConstructPropertyView applies a property view to an arrow::Array.  <a href="namespacekatana.html#a13d3d3094b541b09751e28b4f60ca2ca">More...</a><br /></td></tr>
<tr class="separator:a13d3d3094b541b09751e28b4f60ca2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6066d13104ba2b718938aefa9760a334"><td class="memTemplParams" colspan="2">template&lt;typename PropTuple &gt; </td></tr>
<tr class="memitem:a6066d13104ba2b718938aefa9760a334"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; std::tuple&lt;&gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a6066d13104ba2b718938aefa9760a334">ConstructPropertyViews</a> (const std::vector&lt; arrow::Array * &gt; &amp;, std::index_sequence&lt;&gt;)</td></tr>
<tr class="memdesc:a6066d13104ba2b718938aefa9760a334"><td class="mdescLeft">&#160;</td><td class="mdescRight">ConstructPropertyViews applies ConstructPropertyView to a tuple of properties.  <a href="namespacekatana.html#a6066d13104ba2b718938aefa9760a334">More...</a><br /></td></tr>
<tr class="separator:a6066d13104ba2b718938aefa9760a334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52d589eb252be44211be38ce54309ec"><td class="memTemplParams" colspan="2">template&lt;typename PropTuple , size_t head, size_t... tail&gt; </td></tr>
<tr class="memitem:aa52d589eb252be44211be38ce54309ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; <a class="el" href="namespacekatana.html#ada32e492c7349b1893be8f4849e76852">TupleElements</a>&lt; <a class="el" href="namespacekatana.html#aa4ca3836521e1363b4681229b26bacb7">PropertyViewTuple</a>&lt; PropTuple &gt;, head, tail... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aa52d589eb252be44211be38ce54309ec">ConstructPropertyViews</a> (const std::vector&lt; arrow::Array * &gt; &amp;arrays, std::index_sequence&lt; head, tail... &gt;)</td></tr>
<tr class="separator:aa52d589eb252be44211be38ce54309ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5723542ab0fdcf05904dca7ece0804"><td class="memTemplParams" colspan="2">template&lt;typename PropTuple &gt; </td></tr>
<tr class="memitem:afc5723542ab0fdcf05904dca7ece0804"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; <a class="el" href="namespacekatana.html#aa4ca3836521e1363b4681229b26bacb7">PropertyViewTuple</a>&lt; PropTuple &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#afc5723542ab0fdcf05904dca7ece0804">ConstructPropertyViews</a> (const std::vector&lt; arrow::Array * &gt; &amp;arrays)</td></tr>
<tr class="separator:afc5723542ab0fdcf05904dca7ece0804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90a91526675c58912fc6775b5263a15"><td class="memTemplParams" colspan="2">template&lt;typename Props &gt; </td></tr>
<tr class="memitem:ab90a91526675c58912fc6775b5263a15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; std::shared_ptr&lt; arrow::Table &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ab90a91526675c58912fc6775b5263a15">AllocateTable</a> (uint64_t num_rows, const std::vector&lt; std::string &gt; &amp;names)</td></tr>
<tr class="separator:ab90a91526675c58912fc6775b5263a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574511388fed50f51d53c9a39dee18d8"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; std::shared_ptr&lt; arrow::UInt64Array &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a574511388fed50f51d53c9a39dee18d8">SortAllEdgesByDest</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *pg)</td></tr>
<tr class="memdesc:a574511388fed50f51d53c9a39dee18d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SortAllEdgesByDest sorts edges for each node by destination IDs (ascending order).  <a href="namespacekatana.html#a574511388fed50f51d53c9a39dee18d8">More...</a><br /></td></tr>
<tr class="separator:a574511388fed50f51d53c9a39dee18d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35441d15d64a1c339c2e384e7304439d"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="structkatana_1_1GraphTopology.html#ae1eb7d9b4835715f0133d6ef61d67397">GraphTopology::Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a35441d15d64a1c339c2e384e7304439d">FindEdgeSortedByDest</a> (const <a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *graph, <a class="el" href="structkatana_1_1GraphTopology.html#acde93f565f18bcd70e5afcb0e0266317">GraphTopology::Node</a> node, <a class="el" href="structkatana_1_1GraphTopology.html#acde93f565f18bcd70e5afcb0e0266317">GraphTopology::Node</a> node_to_find)</td></tr>
<tr class="memdesc:a35441d15d64a1c339c2e384e7304439d"><td class="mdescLeft">&#160;</td><td class="mdescRight">FindEdgeSortedByDest finds the "node_to_find" id in the sorted edgelist of the "node" using binary search.  <a href="namespacekatana.html#a35441d15d64a1c339c2e384e7304439d">More...</a><br /></td></tr>
<tr class="separator:a35441d15d64a1c339c2e384e7304439d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2abe07e0439f427c32b1ecd8ce498c"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#abc2abe07e0439f427c32b1ecd8ce498c">SortNodesByDegree</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *pg)</td></tr>
<tr class="memdesc:abc2abe07e0439f427c32b1ecd8ce498c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relabel all nodes in the graph by sorting in the descending order by node degree.  <a href="namespacekatana.html#abc2abe07e0439f427c32b1ecd8ce498c">More...</a><br /></td></tr>
<tr class="separator:abc2abe07e0439f427c32b1ecd8ce498c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67acb78e8d11ff97f818977c58ed8ea5"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; std::unique_ptr&lt; <a class="el" href="classkatana_1_1PropertyGraph.html">katana::PropertyGraph</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a67acb78e8d11ff97f818977c58ed8ea5">CreateSymmetricGraph</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *pg)</td></tr>
<tr class="memdesc:a67acb78e8d11ff97f818977c58ed8ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates in-memory symmetric (or undirected) graph.  <a href="namespacekatana.html#a67acb78e8d11ff97f818977c58ed8ea5">More...</a><br /></td></tr>
<tr class="separator:a67acb78e8d11ff97f818977c58ed8ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa306ef2add21d28b0fe75e90d1b3079"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; std::unique_ptr&lt; <a class="el" href="classkatana_1_1PropertyGraph.html">katana::PropertyGraph</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aaa306ef2add21d28b0fe75e90d1b3079">CreateTransposeGraph</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *pg)</td></tr>
<tr class="memdesc:aaa306ef2add21d28b0fe75e90d1b3079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates in-memory transpose graph.  <a href="namespacekatana.html#aaa306ef2add21d28b0fe75e90d1b3079">More...</a><br /></td></tr>
<tr class="separator:aaa306ef2add21d28b0fe75e90d1b3079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ad5bb9139add3b34278f67fbfcd522"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa0ad5bb9139add3b34278f67fbfcd522"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkatana_1_1LocalRange.html">LocalRange</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aa0ad5bb9139add3b34278f67fbfcd522">MakeLocalRange</a> (T &amp;obj)</td></tr>
<tr class="separator:aa0ad5bb9139add3b34278f67fbfcd522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7835863382e6e72e5b8b0d8c52f107ac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7835863382e6e72e5b8b0d8c52f107ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkatana_1_1LocalTwoLevelRange.html">LocalTwoLevelRange</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a7835863382e6e72e5b8b0d8c52f107ac">MakeLocalTwoLevelRange</a> (T &amp;obj)</td></tr>
<tr class="separator:a7835863382e6e72e5b8b0d8c52f107ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d1f557e45a33c052ee5d4a9f523867"><td class="memTemplParams" colspan="2">template&lt;typename IterTy &gt; </td></tr>
<tr class="memitem:a15d1f557e45a33c052ee5d4a9f523867"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkatana_1_1StandardRange.html">StandardRange</a>&lt; IterTy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a15d1f557e45a33c052ee5d4a9f523867">MakeStandardRange</a> (IterTy begin, IterTy end)</td></tr>
<tr class="separator:a15d1f557e45a33c052ee5d4a9f523867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac248b1f65105a43af96d136b25bbd6c2"><td class="memTemplParams" colspan="2">template&lt;typename IterTy &gt; </td></tr>
<tr class="memitem:ac248b1f65105a43af96d136b25bbd6c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classkatana_1_1SpecificRange.html">SpecificRange</a>&lt; IterTy &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ac248b1f65105a43af96d136b25bbd6c2">MakeSpecificRange</a> (IterTy begin, IterTy end, const std::vector&lt; uint32_t &gt; &amp;thread_ranges)</td></tr>
<tr class="memdesc:ac248b1f65105a43af96d136b25bbd6c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classkatana_1_1SpecificRange.html" title="SpecificRange is a range type where a threads range is specified by an int array that gives where eac...">SpecificRange</a> object.  <a href="namespacekatana.html#ac248b1f65105a43af96d136b25bbd6c2">More...</a><br /></td></tr>
<tr class="separator:ac248b1f65105a43af96d136b25bbd6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664a7f49a65e22807577f6cc809a7827"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if_t&lt; has_local_iterator_v&lt; T &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a664a7f49a65e22807577f6cc809a7827"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a664a7f49a65e22807577f6cc809a7827">iterate</a> (T &amp;container)</td></tr>
<tr class="memdesc:a664a7f49a65e22807577f6cc809a7827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate returns a specialized range object for various container-like objects:  <a href="namespacekatana.html#a664a7f49a65e22807577f6cc809a7827">More...</a><br /></td></tr>
<tr class="separator:a664a7f49a65e22807577f6cc809a7827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace46c029ce2b00c7618c3c1b1166b5c6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ace46c029ce2b00c7618c3c1b1166b5c6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ace46c029ce2b00c7618c3c1b1166b5c6">iterate</a> (std::initializer_list&lt; T &gt; init_list)</td></tr>
<tr class="separator:ace46c029ce2b00c7618c3c1b1166b5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea87f3bc834744bff599bae71f76d43a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if_t&lt; std::is_integral_v&lt; T &gt;&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aea87f3bc834744bff599bae71f76d43a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aea87f3bc834744bff599bae71f76d43a">iterate</a> (const T &amp;begin, const T &amp;end)</td></tr>
<tr class="separator:aea87f3bc834744bff599bae71f76d43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acceb3be91f6608eb0b91434f86f883ce"><td class="memTemplParams" colspan="2">template&lt;typename GraphTy , typename... Args&gt; </td></tr>
<tr class="memitem:acceb3be91f6608eb0b91434f86f883ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#acceb3be91f6608eb0b91434f86f883ce">readGraph</a> (GraphTy &amp;graph, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:acceb3be91f6608eb0b91434f86f883ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and constructs a graph from a file.  <a href="namespacekatana.html#acceb3be91f6608eb0b91434f86f883ce">More...</a><br /></td></tr>
<tr class="separator:acceb3be91f6608eb0b91434f86f883ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1687066d630a809fc309786d51da209a"><td class="memTemplParams" colspan="2">template&lt;typename GraphTy &gt; </td></tr>
<tr class="memitem:a1687066d630a809fc309786d51da209a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a1687066d630a809fc309786d51da209a">readGraphDispatch</a> (GraphTy &amp;graph, <a class="el" href="structkatana_1_1read__default__graph__tag.html">read_default_graph_tag</a> tag, const std::string &amp;filename, const bool readUnweighted=false)</td></tr>
<tr class="separator:a1687066d630a809fc309786d51da209a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e01f894d1177350056683f382c6325"><td class="memTemplParams" colspan="2">template&lt;typename GraphTy &gt; </td></tr>
<tr class="memitem:a09e01f894d1177350056683f382c6325"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a09e01f894d1177350056683f382c6325">readGraphDispatch</a> (GraphTy &amp;graph, <a class="el" href="structkatana_1_1read__default__graph__tag.html">read_default_graph_tag</a>, <a class="el" href="classkatana_1_1FileGraph.html">FileGraph</a> &amp;f, const bool readUnweighted=false)</td></tr>
<tr class="separator:a09e01f894d1177350056683f382c6325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdf345b9e310e31835ae4d97e2424fd"><td class="memTemplParams" colspan="2">template&lt;typename GraphTy &gt; </td></tr>
<tr class="memitem:a4fdf345b9e310e31835ae4d97e2424fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a4fdf345b9e310e31835ae4d97e2424fd">readGraphDispatch</a> (GraphTy &amp;graph, <a class="el" href="structkatana_1_1read__with__aux__graph__tag.html">read_with_aux_graph_tag</a> tag, const std::string &amp;filename)</td></tr>
<tr class="separator:a4fdf345b9e310e31835ae4d97e2424fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24aabb9eff4a44dcee9d25503b985e00"><td class="memTemplParams" colspan="2">template&lt;typename GraphTy &gt; </td></tr>
<tr class="memitem:a24aabb9eff4a44dcee9d25503b985e00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a24aabb9eff4a44dcee9d25503b985e00">readGraphDispatch</a> (GraphTy &amp;graph, <a class="el" href="structkatana_1_1read__with__aux__graph__tag.html">read_with_aux_graph_tag</a>, <a class="el" href="classkatana_1_1FileGraph.html">FileGraph</a> &amp;f)</td></tr>
<tr class="separator:a24aabb9eff4a44dcee9d25503b985e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac26deb08328c9846a712be1c4e0520"><td class="memTemplParams" colspan="2">template&lt;typename GraphTy &gt; </td></tr>
<tr class="memitem:aeac26deb08328c9846a712be1c4e0520"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aeac26deb08328c9846a712be1c4e0520">readGraphDispatch</a> (GraphTy &amp;graph, <a class="el" href="structkatana_1_1read__with__aux__first__graph__tag.html">read_with_aux_first_graph_tag</a>, <a class="el" href="classkatana_1_1FileGraph.html">FileGraph</a> &amp;f)</td></tr>
<tr class="separator:aeac26deb08328c9846a712be1c4e0520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eda998551511444952075dd734130f3"><td class="memTemplParams" colspan="2">template&lt;typename GraphTy &gt; </td></tr>
<tr class="memitem:a5eda998551511444952075dd734130f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a5eda998551511444952075dd734130f3">readGraphDispatch</a> (GraphTy &amp;graph, <a class="el" href="structkatana_1_1read__with__aux__first__graph__tag.html">read_with_aux_first_graph_tag</a> tag, const std::string &amp;filename)</td></tr>
<tr class="separator:a5eda998551511444952075dd734130f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168cf8a71da3da5033009a8f3b67958d"><td class="memTemplParams" colspan="2">template&lt;typename GraphTy &gt; </td></tr>
<tr class="memitem:a168cf8a71da3da5033009a8f3b67958d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a168cf8a71da3da5033009a8f3b67958d">readGraphDispatch</a> (GraphTy &amp;graph, <a class="el" href="structkatana_1_1read__lc__inout__graph__tag.html">read_lc_inout_graph_tag</a>, const std::string &amp;f1, const std::string &amp;f2)</td></tr>
<tr class="separator:a168cf8a71da3da5033009a8f3b67958d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857cca0a77a566618e0293265093d496"><td class="memTemplParams" colspan="2">template&lt;typename GraphTy &gt; </td></tr>
<tr class="memitem:a857cca0a77a566618e0293265093d496"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a857cca0a77a566618e0293265093d496">readGraphDispatch</a> (GraphTy &amp;graph, <a class="el" href="structkatana_1_1read__lc__inout__graph__tag.html">read_lc_inout_graph_tag</a>, <a class="el" href="classkatana_1_1FileGraph.html">FileGraph</a> &amp;f1, <a class="el" href="classkatana_1_1FileGraph.html">FileGraph</a> &amp;f2)</td></tr>
<tr class="separator:a857cca0a77a566618e0293265093d496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f12232a22aae82d7153589cd828c53"><td class="memTemplParams" colspan="2">template&lt;typename GraphTy &gt; </td></tr>
<tr class="memitem:a56f12232a22aae82d7153589cd828c53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a56f12232a22aae82d7153589cd828c53">readGraphDispatch</a> (GraphTy &amp;graph, <a class="el" href="structkatana_1_1read__lc__inout__graph__tag.html">read_lc_inout_graph_tag</a>, <a class="el" href="classkatana_1_1FileGraph.html">FileGraph</a> &amp;f1)</td></tr>
<tr class="separator:a56f12232a22aae82d7153589cd828c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1106c79af0dbac243bc9153b96286209"><td class="memTemplParams" colspan="2">template&lt;typename GraphTy &gt; </td></tr>
<tr class="memitem:a1106c79af0dbac243bc9153b96286209"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a1106c79af0dbac243bc9153b96286209">readGraphDispatch</a> (GraphTy &amp;graph, <a class="el" href="structkatana_1_1read__lc__inout__graph__tag.html">read_lc_inout_graph_tag</a>, const std::string &amp;f1)</td></tr>
<tr class="separator:a1106c79af0dbac243bc9153b96286209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b1dc8e27f3835d081ae1297869dd80"><td class="memTemplParams" colspan="2">template&lt;typename MergeFn , typename IdFn &gt; </td></tr>
<tr class="memitem:a87b1dc8e27f3835d081ae1297869dd80"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a87b1dc8e27f3835d081ae1297869dd80">make_reducible</a> (const MergeFn &amp;mergeFn, const IdFn &amp;idFn)</td></tr>
<tr class="memdesc:a87b1dc8e27f3835d081ae1297869dd80"><td class="mdescLeft">&#160;</td><td class="mdescRight">make_reducible creates a <a class="el" href="classkatana_1_1Reducible.html" title="A Reducible stores per-thread values of a variable of type T and merges multiple values into one.">Reducible</a> from a merge function and identity function.  <a href="namespacekatana.html#a87b1dc8e27f3835d081ae1297869dd80">More...</a><br /></td></tr>
<tr class="separator:a87b1dc8e27f3835d081ae1297869dd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adc9dc24ba3f5192f26399e61d5fd5a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1adc9dc24ba3f5192f26399e61d5fd5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a1adc9dc24ba3f5192f26399e61d5fd5a">ReportParam</a> (const std::string &amp;region, const std::string &amp;category, const T &amp;value)</td></tr>
<tr class="separator:a1adc9dc24ba3f5192f26399e61d5fd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b7969f7d4254fb0933b84c5a7ab3f5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a12b7969f7d4254fb0933b84c5a7ab3f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a12b7969f7d4254fb0933b84c5a7ab3f5">ReportStat</a> (const std::string &amp;region, const std::string &amp;category, const T &amp;value, const <a class="el" href="structkatana_1_1StatTotal.html#a9dd50ac7b05676100fa167ae41ead1a6">StatTotal::Type</a> &amp;type, std::enable_if_t&lt; std::is_integral_v&lt; T &gt;&gt; *=nullptr)</td></tr>
<tr class="separator:a12b7969f7d4254fb0933b84c5a7ab3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373535c1eca82cc2ac6e6089c0ae771b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a373535c1eca82cc2ac6e6089c0ae771b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a373535c1eca82cc2ac6e6089c0ae771b">ReportStat</a> (const std::string &amp;region, const std::string &amp;category, const T &amp;value, const <a class="el" href="structkatana_1_1StatTotal.html#a9dd50ac7b05676100fa167ae41ead1a6">StatTotal::Type</a> &amp;type, std::enable_if_t&lt; std::is_floating_point_v&lt; T &gt;&gt; *=nullptr)</td></tr>
<tr class="separator:a373535c1eca82cc2ac6e6089c0ae771b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84fe29fa198c3f4ea0183dc47bd4dab2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a84fe29fa198c3f4ea0183dc47bd4dab2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a84fe29fa198c3f4ea0183dc47bd4dab2">ReportStatSingle</a> (const std::string &amp;region, const std::string &amp;category, const T &amp;value)</td></tr>
<tr class="separator:a84fe29fa198c3f4ea0183dc47bd4dab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac002eeebe4f90a37639b20f87128949"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aac002eeebe4f90a37639b20f87128949"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aac002eeebe4f90a37639b20f87128949">ReportStatMin</a> (const std::string &amp;region, const std::string &amp;category, const T &amp;value)</td></tr>
<tr class="separator:aac002eeebe4f90a37639b20f87128949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadba2f74a01e10f763b69d35a82f6e32"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aadba2f74a01e10f763b69d35a82f6e32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aadba2f74a01e10f763b69d35a82f6e32">ReportStatMax</a> (const std::string &amp;region, const std::string &amp;category, const T &amp;value)</td></tr>
<tr class="separator:aadba2f74a01e10f763b69d35a82f6e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26b2591ad27d49579dea66ae5983422"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af26b2591ad27d49579dea66ae5983422"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#af26b2591ad27d49579dea66ae5983422">ReportStatSum</a> (const std::string &amp;region, const std::string &amp;category, const T &amp;value)</td></tr>
<tr class="separator:af26b2591ad27d49579dea66ae5983422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee12a7e5a9f79720a3149e1da78a009"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7ee12a7e5a9f79720a3149e1da78a009"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a7ee12a7e5a9f79720a3149e1da78a009">ReportStatAvg</a> (const std::string &amp;region, const std::string &amp;category, const T &amp;value)</td></tr>
<tr class="separator:a7ee12a7e5a9f79720a3149e1da78a009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a501a5de37b3af287be54576f25e39b"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a7a501a5de37b3af287be54576f25e39b">reportRUsage</a> (const std::string &amp;id)</td></tr>
<tr class="memdesc:a7a501a5de37b3af287be54576f25e39b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports maximum resident set size and page faults stats using rusage.  <a href="namespacekatana.html#a7a501a5de37b3af287be54576f25e39b">More...</a><br /></td></tr>
<tr class="separator:a7a501a5de37b3af287be54576f25e39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a80620300e5ea179d6692cf992d9300"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a3a80620300e5ea179d6692cf992d9300">reportPageAlloc</a> (const char *category)</td></tr>
<tr class="memdesc:a3a80620300e5ea179d6692cf992d9300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports Galois system memory stats for all threads.  <a href="namespacekatana.html#a3a80620300e5ea179d6692cf992d9300">More...</a><br /></td></tr>
<tr class="separator:a3a80620300e5ea179d6692cf992d9300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37cf1446ca54fca399dfdfdbab23bf27"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a37cf1446ca54fca399dfdfdbab23bf27">PrintStats</a> ()</td></tr>
<tr class="memdesc:a37cf1446ca54fca399dfdfdbab23bf27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints statistics out to standard out or to the file indicated by SetStatFile.  <a href="namespacekatana.html#a37cf1446ca54fca399dfdfdbab23bf27">More...</a><br /></td></tr>
<tr class="separator:a37cf1446ca54fca399dfdfdbab23bf27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1b9a8f185ce350243d967cbb301196"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a1f1b9a8f185ce350243d967cbb301196">SetStatFile</a> (const std::string &amp;f)</td></tr>
<tr class="separator:a1f1b9a8f185ce350243d967cbb301196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd775f6f963127a8d60f0480545c28b"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="classkatana_1_1TerminationDetection.html">TerminationDetection</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#acdd775f6f963127a8d60f0480545c28b">GetTerminationDetection</a> (unsigned active_threads)</td></tr>
<tr class="separator:acdd775f6f963127a8d60f0480545c28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e917129a0649c5fece62dca21858a41"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="classkatana_1_1ThreadPool.html">ThreadPool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a8e917129a0649c5fece62dca21858a41">GetThreadPool</a> ()</td></tr>
<tr class="memdesc:a8e917129a0649c5fece62dca21858a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a reference to system thread pool  <a href="namespacekatana.html#a8e917129a0649c5fece62dca21858a41">More...</a><br /></td></tr>
<tr class="separator:a8e917129a0649c5fece62dca21858a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b85cccf776bcc1742273fe7a3032ec8"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R , typename W &gt; </td></tr>
<tr class="memitem:a5b85cccf776bcc1742273fe7a3032ec8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a5b85cccf776bcc1742273fe7a3032ec8">readUpdateProtected</a> (L &amp;rwmutex, R &amp;readAndCheck, W &amp;write)</td></tr>
<tr class="memdesc:a5b85cccf776bcc1742273fe7a3032ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">readOrUpdate is a generic function to perform reads or writes using a rwmutex  <a href="namespacekatana.html#a5b85cccf776bcc1742273fe7a3032ec8">More...</a><br /></td></tr>
<tr class="separator:a5b85cccf776bcc1742273fe7a3032ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf17ca09168c4c9966d156adc7fc4b2"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#abcf17ca09168c4c9966d156adc7fc4b2">setActiveThreads</a> (unsigned int num) noexcept</td></tr>
<tr class="memdesc:abcf17ca09168c4c9966d156adc7fc4b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of threads to use when running any Galois iterator.  <a href="namespacekatana.html#abcf17ca09168c4c9966d156adc7fc4b2">More...</a><br /></td></tr>
<tr class="separator:abcf17ca09168c4c9966d156adc7fc4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69b69591077d0e9f33c0b2e8676d520"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ac69b69591077d0e9f33c0b2e8676d520">getActiveThreads</a> () noexcept</td></tr>
<tr class="memdesc:ac69b69591077d0e9f33c0b2e8676d520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of threads in use.  <a href="namespacekatana.html#ac69b69591077d0e9f33c0b2e8676d520">More...</a><br /></td></tr>
<tr class="separator:ac69b69591077d0e9f33c0b2e8676d520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc06e2def7de4be0704465396b7600d"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename... &gt; class TT, typename... Args&gt; </td></tr>
<tr class="memitem:a7fc06e2def7de4be0704465396b7600d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a7fc06e2def7de4be0704465396b7600d">make_trait_with_args</a> (Args... args) -&gt; TT&lt; Args... &gt;</td></tr>
<tr class="memdesc:a7fc06e2def7de4be0704465396b7600d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to simplify creating traits that take unnamed functions (i.e., lambdas).  <a href="namespacekatana.html#a7fc06e2def7de4be0704465396b7600d">More...</a><br /></td></tr>
<tr class="separator:a7fc06e2def7de4be0704465396b7600d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c11c7e97215b2746292a3df68e88c9f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Tuple , size_t Int, size_t... Ints&gt; </td></tr>
<tr class="memitem:a8c11c7e97215b2746292a3df68e88c9f"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a8c11c7e97215b2746292a3df68e88c9f">find_trait</a> (std::index_sequence&lt; Int, Ints... &gt;)</td></tr>
<tr class="memdesc:a8c11c7e97215b2746292a3df68e88c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns index of first matching trait in Tuple.  <a href="namespacekatana.html#a8c11c7e97215b2746292a3df68e88c9f">More...</a><br /></td></tr>
<tr class="separator:a8c11c7e97215b2746292a3df68e88c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c5585e1bde1a577cf49eace85a256a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Tuple &gt; </td></tr>
<tr class="memitem:ad0c5585e1bde1a577cf49eace85a256a"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ad0c5585e1bde1a577cf49eace85a256a">find_trait</a> ()</td></tr>
<tr class="separator:ad0c5585e1bde1a577cf49eace85a256a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d109a8f65e5c6a70bc84a58b3700767"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a3d109a8f65e5c6a70bc84a58b3700767"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a3d109a8f65e5c6a70bc84a58b3700767">has_trait</a> (std::tuple&lt; Ts... &gt; *)</td></tr>
<tr class="memdesc:a3d109a8f65e5c6a70bc84a58b3700767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the tuple type contains the given trait T.  <a href="namespacekatana.html#a3d109a8f65e5c6a70bc84a58b3700767">More...</a><br /></td></tr>
<tr class="separator:a3d109a8f65e5c6a70bc84a58b3700767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62f925c87175e4b46929506ee9825c3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Tuple &gt; </td></tr>
<tr class="memitem:aa62f925c87175e4b46929506ee9825c3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aa62f925c87175e4b46929506ee9825c3">has_trait</a> ()</td></tr>
<tr class="separator:aa62f925c87175e4b46929506ee9825c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d27f1df6ceb0d7194a24a576f173de5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Tuple &gt; </td></tr>
<tr class="memitem:a7d27f1df6ceb0d7194a24a576f173de5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a7d27f1df6ceb0d7194a24a576f173de5">get_trait_value</a> (Tuple tpl)</td></tr>
<tr class="memdesc:a7d27f1df6ceb0d7194a24a576f173de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value associated with the given trait T in a tuple.  <a href="namespacekatana.html#a7d27f1df6ceb0d7194a24a576f173de5">More...</a><br /></td></tr>
<tr class="separator:a7d27f1df6ceb0d7194a24a576f173de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40e673ccdd430fe34a4b21b9e3fcc2c"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T , typename D &gt; </td></tr>
<tr class="memitem:af40e673ccdd430fe34a4b21b9e3fcc2c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#af40e673ccdd430fe34a4b21b9e3fcc2c">get_default_trait_value</a> ([[maybe_unused]] S source, [[maybe_unused]] T tags, [[maybe_unused]] D defaults)</td></tr>
<tr class="separator:af40e673ccdd430fe34a4b21b9e3fcc2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c2e6fc71d4a95b2a467e038d125e5e"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T , typename D &gt; </td></tr>
<tr class="memitem:a55c2e6fc71d4a95b2a467e038d125e5e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a55c2e6fc71d4a95b2a467e038d125e5e">get_default_trait_values</a> ([[maybe_unused]] std::index_sequence&lt;&gt; seq, [[maybe_unused]] S source, [[maybe_unused]] T tags, [[maybe_unused]] D defaults)</td></tr>
<tr class="memdesc:a55c2e6fc71d4a95b2a467e038d125e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a tuple that has an element from defaults[i] for every type from tags[i] missing in source.  <a href="namespacekatana.html#a55c2e6fc71d4a95b2a467e038d125e5e">More...</a><br /></td></tr>
<tr class="separator:a55c2e6fc71d4a95b2a467e038d125e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346a6db8ac880db765625f23f247cb69"><td class="memTemplParams" colspan="2">template&lt;size_t... Ints, typename S , typename T , typename D &gt; </td></tr>
<tr class="memitem:a346a6db8ac880db765625f23f247cb69"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a346a6db8ac880db765625f23f247cb69">get_default_trait_values</a> ([[maybe_unused]] std::index_sequence&lt; Ints... &gt; seq, S source, T tags, D defaults)</td></tr>
<tr class="separator:a346a6db8ac880db765625f23f247cb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6fbee45cf6d1024abbbf5daed05710"><td class="memTemplParams" colspan="2">template&lt;typename S , typename T , typename D &gt; </td></tr>
<tr class="memitem:a6d6fbee45cf6d1024abbbf5daed05710"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a6d6fbee45cf6d1024abbbf5daed05710">get_default_trait_values</a> (S source, T tags, D defaults)</td></tr>
<tr class="separator:a6d6fbee45cf6d1024abbbf5daed05710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9898d9cb937717b094ac83e2b7946709"><td class="memTemplParams" colspan="2">template&lt;class CategoryOrTraversal  = std::forward_iterator_tag, class OuterIter , class InnerIter  = decltype(std::declval&lt;OuterIter&gt;()-&gt;begin()), class InnerBeginFn  = GetBegin, class InnerEndFn  = GetEnd, class Iter  = TwoLevelIterator&lt;        OuterIter, InnerIter, CategoryOrTraversal, InnerBeginFn, InnerEndFn&gt;&gt; </td></tr>
<tr class="memitem:a9898d9cb937717b094ac83e2b7946709"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; Iter, Iter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a9898d9cb937717b094ac83e2b7946709">make_two_level_iterator</a> (OuterIter outer_begin, OuterIter outer_end)</td></tr>
<tr class="separator:a9898d9cb937717b094ac83e2b7946709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6ccf7561be4d365565f6a92f099a67"><td class="memTemplParams" colspan="2">template&lt;typename GraphTy &gt; </td></tr>
<tr class="memitem:a3c6ccf7561be4d365565f6a92f099a67"><td class="memTemplItemLeft" align="right" valign="top">KATANA_EXPORT GraphTy::edge_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a3c6ccf7561be4d365565f6a92f099a67">FindEdgeSortedByDest</a> (const GraphTy &amp;graph, typename <a class="el" href="triangle__count_8cpp.html#abbf75957bb25c1104c933baf133ac20b">GraphTy::Node</a> node, typename <a class="el" href="triangle__count_8cpp.html#abbf75957bb25c1104c933baf133ac20b">GraphTy::Node</a> node_to_find)</td></tr>
<tr class="memdesc:a3c6ccf7561be4d365565f6a92f099a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a node in the sorted edgelist of some other node using binary search.  <a href="namespacekatana.html#a3c6ccf7561be4d365565f6a92f099a67">More...</a><br /></td></tr>
<tr class="separator:a3c6ccf7561be4d365565f6a92f099a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6390ccfacfd1dda67e08badb713b497e"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a6390ccfacfd1dda67e08badb713b497e">getVersion</a> ()</td></tr>
<tr class="separator:a6390ccfacfd1dda67e08badb713b497e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11445d97956a8fdd3bb3bd33d0f96138"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a11445d97956a8fdd3bb3bd33d0f96138">getRevision</a> ()</td></tr>
<tr class="separator:a11445d97956a8fdd3bb3bd33d0f96138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a1722b39f9f8b6616a3ef0f385aec4"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a01a1722b39f9f8b6616a3ef0f385aec4">getVersionMajor</a> ()</td></tr>
<tr class="separator:a01a1722b39f9f8b6616a3ef0f385aec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a191cf944185f45cec69506e336f407"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a9a191cf944185f45cec69506e336f407">getVersionMinor</a> ()</td></tr>
<tr class="separator:a9a191cf944185f45cec69506e336f407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6513606838f0d8d3b4a6aaf14e6965"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a8e6513606838f0d8d3b4a6aaf14e6965">getVersionPatch</a> ()</td></tr>
<tr class="separator:a8e6513606838f0d8d3b4a6aaf14e6965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62665c2b2ae9fd0cce7ad46108d457a"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ab62665c2b2ae9fd0cce7ad46108d457a">getCopyrightYear</a> ()</td></tr>
<tr class="separator:ab62665c2b2ae9fd0cce7ad46108d457a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefaa588ef763a587b0bdf68faf7f8018"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a9d227598262d7bcbd17e8270fdc25d56">ErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aefaa588ef763a587b0bdf68faf7f8018">ArrowToKatana</a> (arrow::StatusCode code)</td></tr>
<tr class="separator:aefaa588ef763a587b0bdf68faf7f8018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6ac16a63bccd5bb77a0b7fd5030a97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacekatana.html#a9d227598262d7bcbd17e8270fdc25d56">ErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ace6ac16a63bccd5bb77a0b7fd5030a97">ArrowToKatana</a> (arrow::Status st)</td></tr>
<tr class="separator:ace6ac16a63bccd5bb77a0b7fd5030a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ffa128de14b8dcfcdff4b7a3076c659"><td class="memTemplParams" colspan="2">template&lt;typename ArrowArrayType &gt; </td></tr>
<tr class="memitem:a1ffa128de14b8dcfcdff4b7a3076c659"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; std::shared_ptr&lt; ArrowArrayType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a1ffa128de14b8dcfcdff4b7a3076c659">ViewCast</a> (const std::shared_ptr&lt; arrow::Array &gt; &amp;gen_array)</td></tr>
<tr class="memdesc:a1ffa128de14b8dcfcdff4b7a3076c659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a safe cast from.  <a href="namespacekatana.html#a1ffa128de14b8dcfcdff4b7a3076c659">More...</a><br /></td></tr>
<tr class="separator:a1ffa128de14b8dcfcdff4b7a3076c659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c805dd77bf706871493fdf2849a516"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a63c805dd77bf706871493fdf2849a516"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a63c805dd77bf706871493fdf2849a516">SingleView</a> (std::vector&lt; std::tuple&lt; T &gt;&gt; *v)</td></tr>
<tr class="separator:a63c805dd77bf706871493fdf2849a516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6a5beb4b08696410d9047c5718867c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1c6a5beb4b08696410d9047c5718867c"><td class="memTemplItemLeft" align="right" valign="top">const std::vector&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a1c6a5beb4b08696410d9047c5718867c">SingleView</a> (const std::vector&lt; std::tuple&lt; T &gt;&gt; *v)</td></tr>
<tr class="separator:a1c6a5beb4b08696410d9047c5718867c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba65c8b04ba5fc50aafbaeeefe24ce3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1ba65c8b04ba5fc50aafbaeeefe24ce3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::tuple&lt; T &gt; &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a1ba65c8b04ba5fc50aafbaeeefe24ce3">TupleView</a> (std::vector&lt; T &gt; *v)</td></tr>
<tr class="separator:a1ba65c8b04ba5fc50aafbaeeefe24ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2a6965620c430869b94916d9bf68f7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5c2a6965620c430869b94916d9bf68f7"><td class="memTemplItemLeft" align="right" valign="top">const std::vector&lt; std::tuple&lt; T &gt; &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a5c2a6965620c430869b94916d9bf68f7">TupleView</a> (const std::vector&lt; T &gt; *v)</td></tr>
<tr class="separator:a5c2a6965620c430869b94916d9bf68f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230f73b3e83498ad75ad294121dabf34"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a230f73b3e83498ad75ad294121dabf34"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a230f73b3e83498ad75ad294121dabf34">UnmarshalVector</a> (const std::shared_ptr&lt; arrow::ChunkedArray &gt; &amp;source)</td></tr>
<tr class="separator:a230f73b3e83498ad75ad294121dabf34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220afb102c04987e7608e953d33ce26e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a220afb102c04987e7608e953d33ce26e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; std::shared_ptr&lt; arrow::ChunkedArray &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a220afb102c04987e7608e953d33ce26e">MarshalVector</a> (const std::vector&lt; T &gt; &amp;source)</td></tr>
<tr class="separator:a220afb102c04987e7608e953d33ce26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94dace563280e6250a46a977f5bb7f9c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a94dace563280e6250a46a977f5bb7f9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; std::shared_ptr&lt; arrow::Table &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a94dace563280e6250a46a977f5bb7f9c">VectorToArrowTable</a> (const std::string &amp;name, const std::vector&lt; T &gt; &amp;source)</td></tr>
<tr class="separator:a94dace563280e6250a46a977f5bb7f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d9799ead1fea82a3a127f5e64da249"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a75d9799ead1fea82a3a127f5e64da249"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a75d9799ead1fea82a3a127f5e64da249">UnmarshalVectorOfVectors</a> (const std::vector&lt; std::shared_ptr&lt; arrow::ChunkedArray &gt;&gt; &amp;source, std::vector&lt; std::vector&lt; T &gt;&gt; *dest)</td></tr>
<tr class="separator:a75d9799ead1fea82a3a127f5e64da249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18f17810376e19b9418695108f83050"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af18f17810376e19b9418695108f83050"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; std::vector&lt; std::shared_ptr&lt; arrow::ChunkedArray &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#af18f17810376e19b9418695108f83050">MarshalVectorOfVectors</a> (const std::vector&lt; std::vector&lt; T &gt;&gt; &amp;source)</td></tr>
<tr class="separator:af18f17810376e19b9418695108f83050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac443dfc789e2c9a96edb8e23f74d2519"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac443dfc789e2c9a96edb8e23f74d2519"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; arrow::Array &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ac443dfc789e2c9a96edb8e23f74d2519">BuildArray</a> (std::vector&lt; T &gt; &amp;data)</td></tr>
<tr class="memdesc:ac443dfc789e2c9a96edb8e23f74d2519"><td class="mdescLeft">&#160;</td><td class="mdescRight">BuildArray copies the input data into an arrow array.  <a href="namespacekatana.html#ac443dfc789e2c9a96edb8e23f74d2519">More...</a><br /></td></tr>
<tr class="separator:ac443dfc789e2c9a96edb8e23f74d2519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29db018e074a8b6937acc03eaec0840a"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; std::shared_ptr&lt; arrow::Array &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a29db018e074a8b6937acc03eaec0840a">Unchunk</a> (const std::shared_ptr&lt; arrow::ChunkedArray &gt; &amp;original)</td></tr>
<tr class="memdesc:a29db018e074a8b6937acc03eaec0840a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine chunks of ChunkedArray into a single Array.  <a href="namespacekatana.html#a29db018e074a8b6937acc03eaec0840a">More...</a><br /></td></tr>
<tr class="separator:a29db018e074a8b6937acc03eaec0840a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a83ff77e4d0cf4bacc8d2ef3c0dfe8d"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; std::shared_ptr&lt; arrow::ChunkedArray &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a0a83ff77e4d0cf4bacc8d2ef3c0dfe8d">Shuffle</a> (const std::shared_ptr&lt; arrow::ChunkedArray &gt; &amp;original)</td></tr>
<tr class="memdesc:a0a83ff77e4d0cf4bacc8d2ef3c0dfe8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a randomly shuffled version of a ChunkedArray.  <a href="namespacekatana.html#a0a83ff77e4d0cf4bacc8d2ef3c0dfe8d">More...</a><br /></td></tr>
<tr class="separator:a0a83ff77e4d0cf4bacc8d2ef3c0dfe8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eec8a2c55e0a1fd6a706cbdb1123a6d"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT std::shared_ptr&lt; arrow::ChunkedArray &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a8eec8a2c55e0a1fd6a706cbdb1123a6d">NullChunkedArray</a> (const std::shared_ptr&lt; arrow::DataType &gt; &amp;type, int64_t length)</td></tr>
<tr class="memdesc:a8eec8a2c55e0a1fd6a706cbdb1123a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a ChunkeArray of Nulls of the given type and length.  <a href="namespacekatana.html#a8eec8a2c55e0a1fd6a706cbdb1123a6d">More...</a><br /></td></tr>
<tr class="separator:a8eec8a2c55e0a1fd6a706cbdb1123a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa9a80bc3a0c7afd2d975e8a43b7738"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#affa9a80bc3a0c7afd2d975e8a43b7738">DiffFormatTo</a> (fmt::memory_buffer *buf, const std::shared_ptr&lt; arrow::ChunkedArray &gt; &amp;a0, const std::shared_ptr&lt; arrow::ChunkedArray &gt; &amp;a1, size_t approx_total_characters=150)</td></tr>
<tr class="memdesc:affa9a80bc3a0c7afd2d975e8a43b7738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the differences between two ChunkedArrays only using about approx_total_characters.  <a href="namespacekatana.html#affa9a80bc3a0c7afd2d975e8a43b7738">More...</a><br /></td></tr>
<tr class="separator:affa9a80bc3a0c7afd2d975e8a43b7738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255e9a26d5902eaf192185f4e83c5e69"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a255e9a26d5902eaf192185f4e83c5e69">ApproxArrayMemUse</a> (const std::shared_ptr&lt; arrow::Array &gt; &amp;array)</td></tr>
<tr class="memdesc:a255e9a26d5902eaf192185f4e83c5e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the amount of memory this array is using n.b.  <a href="namespacekatana.html#a255e9a26d5902eaf192185f4e83c5e69">More...</a><br /></td></tr>
<tr class="separator:a255e9a26d5902eaf192185f4e83c5e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99077f061bb4a4addaaa3d762e3e8f22"><td class="memTemplParams" colspan="2">template&lt;class VisitorType &gt; </td></tr>
<tr class="memitem:a99077f061bb4a4addaaa3d762e3e8f22"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a99077f061bb4a4addaaa3d762e3e8f22">VisitArrow</a> (const arrow::Array &amp;array, VisitorType &amp;&amp;visitor)</td></tr>
<tr class="separator:a99077f061bb4a4addaaa3d762e3e8f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb4dffa843290f76c568dc66ea3a3ef"><td class="memTemplParams" colspan="2">template&lt;class VisitorType &gt; </td></tr>
<tr class="memitem:a1cb4dffa843290f76c568dc66ea3a3ef"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a1cb4dffa843290f76c568dc66ea3a3ef">VisitArrow</a> (const std::shared_ptr&lt; arrow::Array &gt; &amp;array, VisitorType &amp;&amp;visitor)</td></tr>
<tr class="separator:a1cb4dffa843290f76c568dc66ea3a3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8c9eb23aa08a63e8c1506688b8547b"><td class="memTemplParams" colspan="2">template&lt;class VisitorType &gt; </td></tr>
<tr class="memitem:a9d8c9eb23aa08a63e8c1506688b8547b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a9d8c9eb23aa08a63e8c1506688b8547b">VisitArrow</a> (const arrow::Scalar &amp;scalar, VisitorType &amp;&amp;visitor)</td></tr>
<tr class="separator:a9d8c9eb23aa08a63e8c1506688b8547b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d13f7ca4f18d6bb562eb2714f3bc69c"><td class="memTemplParams" colspan="2">template&lt;class VisitorType &gt; </td></tr>
<tr class="memitem:a3d13f7ca4f18d6bb562eb2714f3bc69c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a3d13f7ca4f18d6bb562eb2714f3bc69c">VisitArrow</a> (const std::shared_ptr&lt; arrow::Scalar &gt; &amp;scalar, VisitorType &amp;&amp;visitor)</td></tr>
<tr class="separator:a3d13f7ca4f18d6bb562eb2714f3bc69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b98d31f0a622527d9aac0e2b9b99910"><td class="memTemplParams" colspan="2">template&lt;class VisitorType &gt; </td></tr>
<tr class="memitem:a8b98d31f0a622527d9aac0e2b9b99910"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a8b98d31f0a622527d9aac0e2b9b99910">VisitArrow</a> (arrow::ArrayBuilder *builder, VisitorType &amp;&amp;visitor)</td></tr>
<tr class="separator:a8b98d31f0a622527d9aac0e2b9b99910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6e4e62056de4448f5c1cee63edf6a4"><td class="memTemplParams" colspan="2">template&lt;class VisitorType &gt; </td></tr>
<tr class="memitem:a1c6e4e62056de4448f5c1cee63edf6a4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a1c6e4e62056de4448f5c1cee63edf6a4">VisitArrow</a> (const std::unique_ptr&lt; arrow::ArrayBuilder &gt; &amp;builder, VisitorType &amp;&amp;visitor)</td></tr>
<tr class="separator:a1c6e4e62056de4448f5c1cee63edf6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c6e13e5a4268af8dcbdf958caa973a"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; std::shared_ptr&lt; arrow::Array &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a10c6e13e5a4268af8dcbdf958caa973a">ArrayFromScalars</a> (const std::vector&lt; std::shared_ptr&lt; arrow::Scalar &gt;&gt; &amp;scalars, const std::shared_ptr&lt; arrow::DataType &gt; &amp;type)</td></tr>
<tr class="memdesc:a10c6e13e5a4268af8dcbdf958caa973a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a vector of scalars of type data_type and return an Array.  <a href="namespacekatana.html#a10c6e13e5a4268af8dcbdf958caa973a">More...</a><br /></td></tr>
<tr class="separator:a10c6e13e5a4268af8dcbdf958caa973a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d12469fda4759af6f637e27dfa9ebe"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a76d12469fda4759af6f637e27dfa9ebe">PrintBacktrace</a> ()</td></tr>
<tr class="separator:a76d12469fda4759af6f637e27dfa9ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e3be3fa1ed07518e2d2bd2cb3c2e55"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a52e3be3fa1ed07518e2d2bd2cb3c2e55">InitBacktrace</a> ()</td></tr>
<tr class="separator:a52e3be3fa1ed07518e2d2bd2cb3c2e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd76da271128e81797dfb506203d1414"><td class="memTemplParams" colspan="2">template&lt;typename T , std::enable_if_t&lt; std::is_integral&lt; T &gt;::value, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:acd76da271128e81797dfb506203d1414"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#acd76da271128e81797dfb506203d1414">IsPowerOf2</a> (T val)</td></tr>
<tr class="separator:acd76da271128e81797dfb506203d1414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a51b72d99b8ac0ca754196016330b2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , std::enable_if_t&lt; std::is_integral&lt; U &gt;::value, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a86a51b72d99b8ac0ca754196016330b2"><td class="memTemplItemLeft" align="right" valign="top">constexpr U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a86a51b72d99b8ac0ca754196016330b2">AlignUp</a> (U val)</td></tr>
<tr class="separator:a86a51b72d99b8ac0ca754196016330b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef0ed8904443f99eb725ea286f009f4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , std::enable_if_t&lt; std::is_integral&lt; U &gt;::value, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:afef0ed8904443f99eb725ea286f009f4"><td class="memTemplItemLeft" align="right" valign="top">constexpr U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#afef0ed8904443f99eb725ea286f009f4">AlignDown</a> (U val)</td></tr>
<tr class="separator:afef0ed8904443f99eb725ea286f009f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42da4ba7bd9e2c242250b3b3d5084e0f"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a42da4ba7bd9e2c242250b3b3d5084e0f">GetEnv</a> (const std::string &amp;var_name)</td></tr>
<tr class="memdesc:a42da4ba7bd9e2c242250b3b3d5084e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the environment variable is set.  <a href="namespacekatana.html#a42da4ba7bd9e2c242250b3b3d5084e0f">More...</a><br /></td></tr>
<tr class="separator:a42da4ba7bd9e2c242250b3b3d5084e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d19de081830f433b00a68a22253435"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aa0d19de081830f433b00a68a22253435">GetEnv</a> (const std::string &amp;var_name, bool *ret)</td></tr>
<tr class="memdesc:aa0d19de081830f433b00a68a22253435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if environment variable is set, and extract its value into ret_val parameter.  <a href="namespacekatana.html#aa0d19de081830f433b00a68a22253435">More...</a><br /></td></tr>
<tr class="separator:aa0d19de081830f433b00a68a22253435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7371a5df1bbcd499f9df884154738921"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a7371a5df1bbcd499f9df884154738921">GetEnv</a> (const std::string &amp;var_name, int *ret)</td></tr>
<tr class="separator:a7371a5df1bbcd499f9df884154738921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a9ebbaba1173f09d9c750a06c5bb84"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ae6a9ebbaba1173f09d9c750a06c5bb84">GetEnv</a> (const std::string &amp;var_name, double *ret)</td></tr>
<tr class="separator:ae6a9ebbaba1173f09d9c750a06c5bb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9450422a244d140f5c709df54aaa79bf"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a9450422a244d140f5c709df54aaa79bf">GetEnv</a> (const std::string &amp;var_name, std::string *ret)</td></tr>
<tr class="separator:a9450422a244d140f5c709df54aaa79bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac533e1296ea9b6bc79600af41bb9e541"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ac533e1296ea9b6bc79600af41bb9e541">SetEnv</a> (const std::string &amp;var_name, const std::string &amp;val, bool overwrite)</td></tr>
<tr class="memdesc:ac533e1296ea9b6bc79600af41bb9e541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set environment variable.  <a href="namespacekatana.html#ac533e1296ea9b6bc79600af41bb9e541">More...</a><br /></td></tr>
<tr class="separator:ac533e1296ea9b6bc79600af41bb9e541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9a55ca4432cdcbcf89f511357f4cf2"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#abb9a55ca4432cdcbcf89f511357f4cf2">UnsetEnv</a> (const std::string &amp;var_name)</td></tr>
<tr class="separator:abb9a55ca4432cdcbcf89f511357f4cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35ecb137fc1cccafad5c6f5c3ef6c98"><td class="memItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ab35ecb137fc1cccafad5c6f5c3ef6c98">make_error_code</a> (<a class="el" href="namespacekatana.html#a9d227598262d7bcbd17e8270fdc25d56">ErrorCode</a> e) noexcept</td></tr>
<tr class="memdesc:ab35ecb137fc1cccafad5c6f5c3ef6c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">make_error_code converts ErrorCode into a standard error code.  <a href="namespacekatana.html#ab35ecb137fc1cccafad5c6f5c3ef6c98">More...</a><br /></td></tr>
<tr class="separator:ab35ecb137fc1cccafad5c6f5c3ef6c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ead6bd15f422d6a58595d316571a77e"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a8ead6bd15f422d6a58595d316571a77e">HttpInit</a> ()</td></tr>
<tr class="separator:a8ead6bd15f422d6a58595d316571a77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280a4edefb3f7b59e15e3214a18865bc"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a280a4edefb3f7b59e15e3214a18865bc">HttpGet</a> (const std::string &amp;url, std::vector&lt; char &gt; *response)</td></tr>
<tr class="memdesc:a280a4edefb3f7b59e15e3214a18865bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an HTTP get request on url and fill buffer with the result on success.  <a href="namespacekatana.html#a280a4edefb3f7b59e15e3214a18865bc">More...</a><br /></td></tr>
<tr class="separator:a280a4edefb3f7b59e15e3214a18865bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4601a35af785e478fe246afe04d7e7"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#afc4601a35af785e478fe246afe04d7e7">HttpPost</a> (const std::string &amp;url, const std::string &amp;data, std::vector&lt; char &gt; *response)</td></tr>
<tr class="memdesc:afc4601a35af785e478fe246afe04d7e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an HTTP post request on url and send the contents of buffer.  <a href="namespacekatana.html#afc4601a35af785e478fe246afe04d7e7">More...</a><br /></td></tr>
<tr class="separator:afc4601a35af785e478fe246afe04d7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8c9769dcae140ac4fe4488e4cb50da"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a9b8c9769dcae140ac4fe4488e4cb50da">HttpPut</a> (const std::string &amp;url, const std::string &amp;data, std::vector&lt; char &gt; *response)</td></tr>
<tr class="memdesc:a9b8c9769dcae140ac4fe4488e4cb50da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an HTTP put request on url and send the contents of buffer.  <a href="namespacekatana.html#a9b8c9769dcae140ac4fe4488e4cb50da">More...</a><br /></td></tr>
<tr class="separator:a9b8c9769dcae140ac4fe4488e4cb50da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23967f8e9c0a95985bfa96c4e7ed0d6"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aa23967f8e9c0a95985bfa96c4e7ed0d6">HttpDelete</a> (const std::string &amp;url, std::vector&lt; char &gt; *response)</td></tr>
<tr class="memdesc:aa23967f8e9c0a95985bfa96c4e7ed0d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an HTTP delete request on url and send the contents of buffer.  <a href="namespacekatana.html#aa23967f8e9c0a95985bfa96c4e7ed0d6">More...</a><br /></td></tr>
<tr class="separator:aa23967f8e9c0a95985bfa96c4e7ed0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e73a91a3ad818e7cba63406ec2475b6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Callable , typename... Args&gt; </td></tr>
<tr class="memitem:a9e73a91a3ad818e7cba63406ec2475b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a9e73a91a3ad818e7cba63406ec2475b6">HttpOpJson</a> (Callable func, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a9e73a91a3ad818e7cba63406ec2475b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c4929a4c8a8480fdd84ace6488bfca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a69c4929a4c8a8480fdd84ace6488bfca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a69c4929a4c8a8480fdd84ace6488bfca">HttpGetJson</a> (const std::string &amp;url)</td></tr>
<tr class="separator:a69c4929a4c8a8480fdd84ace6488bfca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b21cb3758ab377eecd5f94b48a5660"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a30b21cb3758ab377eecd5f94b48a5660"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a30b21cb3758ab377eecd5f94b48a5660">HttpDeleteJson</a> (const std::string &amp;url)</td></tr>
<tr class="separator:a30b21cb3758ab377eecd5f94b48a5660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c2cd816a0d547ab06f2f0c85f2faed"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a73c2cd816a0d547ab06f2f0c85f2faed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a73c2cd816a0d547ab06f2f0c85f2faed">HttpPostJson</a> (const std::string &amp;url, const T &amp;obj)</td></tr>
<tr class="separator:a73c2cd816a0d547ab06f2f0c85f2faed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcca45df3883ac25e5a4cf3e199bb784"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:abcca45df3883ac25e5a4cf3e199bb784"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#abcca45df3883ac25e5a4cf3e199bb784">HttpPutJson</a> (const std::string &amp;url, const T &amp;obj)</td></tr>
<tr class="separator:abcca45df3883ac25e5a4cf3e199bb784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add51b801fe882b401808832002207da0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:add51b801fe882b401808832002207da0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#add51b801fe882b401808832002207da0">JsonParse</a> (U &amp;obj)</td></tr>
<tr class="memdesc:add51b801fe882b401808832002207da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">call parse and turn exceptions into the results we know and love  <a href="namespacekatana.html#add51b801fe882b401808832002207da0">More...</a><br /></td></tr>
<tr class="separator:add51b801fe882b401808832002207da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa9acf0f689aaf40bae0f5dae5499a1d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aaa9acf0f689aaf40bae0f5dae5499a1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aaa9acf0f689aaf40bae0f5dae5499a1d">JsonParse</a> (U &amp;obj, T *val)</td></tr>
<tr class="separator:aaa9acf0f689aaf40bae0f5dae5499a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619f85a58ea717e4cf3dfd0d06fa7ace"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a619f85a58ea717e4cf3dfd0d06fa7ace">JsonDump</a> (const <a class="el" href="RDGPartHeader_8cpp.html#ab701e3ac61a85b337ec5c1abaad6742d">nlohmann::json</a> &amp;obj)</td></tr>
<tr class="memdesc:a619f85a58ea717e4cf3dfd0d06fa7ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump to string, but catch errors.  <a href="namespacekatana.html#a619f85a58ea717e4cf3dfd0d06fa7ace">More...</a><br /></td></tr>
<tr class="separator:a619f85a58ea717e4cf3dfd0d06fa7ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3c958703c41e46a1b8aa6639323a50"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1b3c958703c41e46a1b8aa6639323a50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a1b3c958703c41e46a1b8aa6639323a50">JsonDump</a> (const T &amp;obj)</td></tr>
<tr class="separator:a1b3c958703c41e46a1b8aa6639323a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4d646903f04da1efe3780d64ea79c3"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... Args&gt; </td></tr>
<tr class="memitem:abf4d646903f04da1efe3780d64ea79c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#abf4d646903f04da1efe3780d64ea79c3">Log</a> (<a class="el" href="namespacekatana.html#ab1c012a5bda211a6470b9e8424c14e7b">LogLevel</a> level, F fmt_string, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:abf4d646903f04da1efe3780d64ea79c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log at a specific LogLevel.  <a href="namespacekatana.html#abf4d646903f04da1efe3780d64ea79c3">More...</a><br /></td></tr>
<tr class="separator:abf4d646903f04da1efe3780d64ea79c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28b7084dd2ed48c926855bccf483513"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... Args&gt; </td></tr>
<tr class="memitem:ac28b7084dd2ed48c926855bccf483513"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ac28b7084dd2ed48c926855bccf483513">LogLine</a> (<a class="el" href="namespacekatana.html#ab1c012a5bda211a6470b9e8424c14e7b">LogLevel</a> level, const char *file_name, int line_no, F fmt_string, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac28b7084dd2ed48c926855bccf483513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log at a specific LogLevel with source code information.  <a href="namespacekatana.html#ac28b7084dd2ed48c926855bccf483513">More...</a><br /></td></tr>
<tr class="separator:ac28b7084dd2ed48c926855bccf483513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace496da656c162751f4b8c59c8bff827"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ace496da656c162751f4b8c59c8bff827">AbortApplication</a> ()</td></tr>
<tr class="separator:ace496da656c162751f4b8c59c8bff827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5038f4364fb63fb47b2f5b984e716f0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename _Value &gt; </td></tr>
<tr class="memitem:ac5038f4364fb63fb47b2f5b984e716f0"><td class="memTemplItemLeft" align="right" valign="top">_Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ac5038f4364fb63fb47b2f5b984e716f0">must_be_OpaqueID_subclass</a> (const <a class="el" href="structkatana_1_1OpaqueID.html">OpaqueID</a>&lt; T, _Value &gt; &amp;)</td></tr>
<tr class="separator:ac5038f4364fb63fb47b2f5b984e716f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef431c2bb0ee48ad65341dfd26ce0c99"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aef431c2bb0ee48ad65341dfd26ce0c99">RandomAlphanumericString</a> (uint64_t len, <a class="el" href="namespacekatana.html#a90f4c6b4c41224bdb87892b16e067340">RandGenerator</a> *gen=nullptr)</td></tr>
<tr class="memdesc:aef431c2bb0ee48ad65341dfd26ce0c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random alphanumeric string of length.  <a href="namespacekatana.html#aef431c2bb0ee48ad65341dfd26ce0c99">More...</a><br /></td></tr>
<tr class="separator:aef431c2bb0ee48ad65341dfd26ce0c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa186584ec0a41b2c810ce176fb56b30c"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a90f4c6b4c41224bdb87892b16e067340">RandGenerator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aa186584ec0a41b2c810ce176fb56b30c">GetGenerator</a> ()</td></tr>
<tr class="separator:aa186584ec0a41b2c810ce176fb56b30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b7678f7dda967accf56f3f14e4fca3"><td class="memItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a59b7678f7dda967accf56f3f14e4fca3">make_error_code</a> (<a class="el" href="classkatana_1_1ErrorInfo.html">ErrorInfo</a> e) noexcept</td></tr>
<tr class="memdesc:a59b7678f7dda967accf56f3f14e4fca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">make_error_code converts <a class="el" href="classkatana_1_1ErrorInfo.html" title="An ErrorInfo contains additional context about an error in addition to an error code.">ErrorInfo</a> into a standard error code.  <a href="namespacekatana.html#a59b7678f7dda967accf56f3f14e4fca3">More...</a><br /></td></tr>
<tr class="separator:a59b7678f7dda967accf56f3f14e4fca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1bf0289ae52b019889d22916109855"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a2f1bf0289ae52b019889d22916109855">operator==</a> (const <a class="el" href="classkatana_1_1ErrorInfo.html">ErrorInfo</a> &amp;a, const <a class="el" href="classkatana_1_1ErrorInfo.html">ErrorInfo</a> &amp;b)</td></tr>
<tr class="separator:a2f1bf0289ae52b019889d22916109855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6dd9ff31aea17f6231d2153e85816f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a6c6dd9ff31aea17f6231d2153e85816f">operator!=</a> (const <a class="el" href="classkatana_1_1ErrorInfo.html">ErrorInfo</a> &amp;a, const <a class="el" href="classkatana_1_1ErrorInfo.html">ErrorInfo</a> &amp;b)</td></tr>
<tr class="separator:a6c6dd9ff31aea17f6231d2153e85816f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58306194672cbd10c5ffb4ea812101a6"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a58306194672cbd10c5ffb4ea812101a6">ResultSuccess</a> ()</td></tr>
<tr class="separator:a58306194672cbd10c5ffb4ea812101a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5585c3aee0ab7f501e508e6dc4897186"><td class="memItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a5585c3aee0ab7f501e508e6dc4897186">ResultErrno</a> ()</td></tr>
<tr class="separator:a5585c3aee0ab7f501e508e6dc4897186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f43dc294f927fd963e5cc73ea7c6c8c"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a1f43dc294f927fd963e5cc73ea7c6c8c">FromBase64</a> (const std::string &amp;input)</td></tr>
<tr class="memdesc:a1f43dc294f927fd963e5cc73ea7c6c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">FromBase64 converts from base64 string into a binary encoded string.  <a href="namespacekatana.html#a1f43dc294f927fd963e5cc73ea7c6c8c">More...</a><br /></td></tr>
<tr class="separator:a1f43dc294f927fd963e5cc73ea7c6c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57755b7f0fcee27d8b27ac5d545ae0c"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ab57755b7f0fcee27d8b27ac5d545ae0c">ToBase64</a> (const std::string &amp;message, bool url_safe=false)</td></tr>
<tr class="memdesc:ab57755b7f0fcee27d8b27ac5d545ae0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ToBase64 encodes message string into a Base64 string.  <a href="namespacekatana.html#ab57755b7f0fcee27d8b27ac5d545ae0c">More...</a><br /></td></tr>
<tr class="separator:ab57755b7f0fcee27d8b27ac5d545ae0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab373cd02635e0ba3153c168b92a8ce89"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ab373cd02635e0ba3153c168b92a8ce89">TrimPrefix</a> (const std::string &amp;s, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:ab373cd02635e0ba3153c168b92a8ce89"><td class="mdescLeft">&#160;</td><td class="mdescRight">TrimPrefix returns a string without the given prefix.  <a href="namespacekatana.html#ab373cd02635e0ba3153c168b92a8ce89">More...</a><br /></td></tr>
<tr class="separator:ab373cd02635e0ba3153c168b92a8ce89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ef08536637ab910e7c23b078da24a1"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#af4ef08536637ab910e7c23b078da24a1">HasPrefix</a> (const std::string &amp;s, const std::string &amp;prefix)</td></tr>
<tr class="separator:af4ef08536637ab910e7c23b078da24a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7da63c6791373f48b3c01162fd04717"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aa7da63c6791373f48b3c01162fd04717">TrimSuffix</a> (const std::string &amp;s, const std::string &amp;suffix)</td></tr>
<tr class="memdesc:aa7da63c6791373f48b3c01162fd04717"><td class="mdescLeft">&#160;</td><td class="mdescRight">TrimSuffix returns a string without the given suffix.  <a href="namespacekatana.html#aa7da63c6791373f48b3c01162fd04717">More...</a><br /></td></tr>
<tr class="separator:aa7da63c6791373f48b3c01162fd04717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08c0136825589df6d59573f93953365"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ad08c0136825589df6d59573f93953365">HasSuffix</a> (const std::string &amp;s, const std::string &amp;suffix)</td></tr>
<tr class="separator:ad08c0136825589df6d59573f93953365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336314b6e1f2c87c6d536b8f240c0297"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT std::vector&lt; std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a336314b6e1f2c87c6d536b8f240c0297">SplitView</a> (std::string_view s, std::string_view sep, uint64_t max=std::numeric_limits&lt; uint64_t &gt;::max())</td></tr>
<tr class="memdesc:a336314b6e1f2c87c6d536b8f240c0297"><td class="mdescLeft">&#160;</td><td class="mdescRight">SplitView returns a list of words in.  <a href="namespacekatana.html#a336314b6e1f2c87c6d536b8f240c0297">More...</a><br /></td></tr>
<tr class="separator:a336314b6e1f2c87c6d536b8f240c0297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24cfe906924eac4d975019b6dee49bed"><td class="memTemplParams" colspan="2">template&lt;typename I &gt; </td></tr>
<tr class="memitem:a24cfe906924eac4d975019b6dee49bed"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a24cfe906924eac4d975019b6dee49bed">Join</a> (std::string_view sep, I begin, I end)</td></tr>
<tr class="memdesc:a24cfe906924eac4d975019b6dee49bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join returns a string that is the concatenation of every object from.  <a href="namespacekatana.html#a24cfe906924eac4d975019b6dee49bed">More...</a><br /></td></tr>
<tr class="separator:a24cfe906924eac4d975019b6dee49bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ee151d7c512df2f1d51cb7b3f7595c"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:ab1ee151d7c512df2f1d51cb7b3f7595c"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ab1ee151d7c512df2f1d51cb7b3f7595c">Join</a> (std::string_view sep, const C &amp;items)</td></tr>
<tr class="memdesc:ab1ee151d7c512df2f1d51cb7b3f7595c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join returns a string that is the concatenation of every object in.  <a href="namespacekatana.html#ab1ee151d7c512df2f1d51cb7b3f7595c">More...</a><br /></td></tr>
<tr class="separator:ab1ee151d7c512df2f1d51cb7b3f7595c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085cd46fee778f1cc6495ff15312c6bd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a085cd46fee778f1cc6495ff15312c6bd"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a085cd46fee778f1cc6495ff15312c6bd">Join</a> (std::string_view sep, const std::initializer_list&lt; T &gt; items)</td></tr>
<tr class="memdesc:a085cd46fee778f1cc6495ff15312c6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join returns a string that is the concatenation of every object in.  <a href="namespacekatana.html#a085cd46fee778f1cc6495ff15312c6bd">More...</a><br /></td></tr>
<tr class="separator:a085cd46fee778f1cc6495ff15312c6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b63f9504fe9b550bc5bd8812b52e3ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacekatana.html#ad53d5a0919afb768f3ad0304893c5925">TimePoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a1b63f9504fe9b550bc5bd8812b52e3ac">Now</a> ()</td></tr>
<tr class="separator:a1b63f9504fe9b550bc5bd8812b52e3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95710088fa7cee6aa2c8147e639b7d34"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a95710088fa7cee6aa2c8147e639b7d34">UsSince</a> (const <a class="el" href="namespacekatana.html#ad53d5a0919afb768f3ad0304893c5925">TimePoint</a> &amp;point)</td></tr>
<tr class="separator:a95710088fa7cee6aa2c8147e639b7d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05662d486fd897103e6ec8c2ef8a4a8e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a05662d486fd897103e6ec8c2ef8a4a8e">UsBetween</a> (const <a class="el" href="namespacekatana.html#ad53d5a0919afb768f3ad0304893c5925">TimePoint</a> &amp;before, const <a class="el" href="namespacekatana.html#ad53d5a0919afb768f3ad0304893c5925">TimePoint</a> &amp;after)</td></tr>
<tr class="separator:a05662d486fd897103e6ec8c2ef8a4a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeec63455a70851a42571e44275e551b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; float, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#abeec63455a70851a42571e44275e551b">UsToPair</a> (uint64_t us_)</td></tr>
<tr class="separator:abeec63455a70851a42571e44275e551b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73034aea69c3c53b0bfd6c53deea3171"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a73034aea69c3c53b0bfd6c53deea3171">UsToStr</a> (const std::string &amp;<a class="el" href="structfmt.html">fmt</a>, uint64_t us_)</td></tr>
<tr class="separator:a73034aea69c3c53b0bfd6c53deea3171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f7cf95822545808b5643524392cab6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a76f7cf95822545808b5643524392cab6">BytesToStr</a> (const std::string &amp;<a class="el" href="structfmt.html">fmt</a>, uint64_t bytes_)</td></tr>
<tr class="separator:a76f7cf95822545808b5643524392cab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7cf0a8d194315b87b6e313404b131d"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#aeb7cf0a8d194315b87b6e313404b131d">operator==</a> (const <a class="el" href="classkatana_1_1Uri.html">Uri</a> &amp;lhs, const <a class="el" href="classkatana_1_1Uri.html">Uri</a> &amp;rhs)</td></tr>
<tr class="separator:aeb7cf0a8d194315b87b6e313404b131d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861fa1fe781ba86de34d4f72437db9cb"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a861fa1fe781ba86de34d4f72437db9cb">operator!=</a> (const <a class="el" href="classkatana_1_1Uri.html">Uri</a> &amp;lhs, const <a class="el" href="classkatana_1_1Uri.html">Uri</a> &amp;rhs)</td></tr>
<tr class="separator:a861fa1fe781ba86de34d4f72437db9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:afea83498ac35d84218d622ef40b4aa41"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#afea83498ac35d84218d622ef40b4aa41">activeThreads</a> = 1</td></tr>
<tr class="separator:afea83498ac35d84218d622ef40b4aa41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e72eb4ac2f0ddccce24eefedceec1b2"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a0e72eb4ac2f0ddccce24eefedceec1b2">KATANA_CACHE_LINE_SIZE</a> = 128</td></tr>
<tr class="separator:a0e72eb4ac2f0ddccce24eefedceec1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1beaf8c96891b65f684741e6923db0d4"><td class="memItemLeft" align="right" valign="top">thread_local std::jmp_buf&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a1beaf8c96891b65f684741e6923db0d4">execFrame</a></td></tr>
<tr class="separator:a1beaf8c96891b65f684741e6923db0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71c54b5fc15b823ee663babfd0aabc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkatana_1_1DynamicBitset.html">katana::DynamicBitset</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ae71c54b5fc15b823ee663babfd0aabc0">EmptyBitset</a></td></tr>
<tr class="memdesc:ae71c54b5fc15b823ee663babfd0aabc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">An empty bitset object; used mainly by <a class="el" href="structkatana_1_1InvalidBitsetFn.html" title="A structure representing an empty bitset.">InvalidBitsetFn</a>.  <a href="namespacekatana.html#ae71c54b5fc15b823ee663babfd0aabc0">More...</a><br /></td></tr>
<tr class="separator:ae71c54b5fc15b823ee663babfd0aabc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00ab493efad0f6093ce35620f3ff897"><td class="memItemLeft" align="right" valign="top">thread_local char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ab00ab493efad0f6093ce35620f3ff897">ptsBase</a></td></tr>
<tr class="separator:ab00ab493efad0f6093ce35620f3ff897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb50a75c9196240c03d62e23468d80de"><td class="memItemLeft" align="right" valign="top">thread_local char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#afb50a75c9196240c03d62e23468d80de">pssBase</a></td></tr>
<tr class="separator:afb50a75c9196240c03d62e23468d80de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088ca56912daa367a04eaf7c715d1d9c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a088ca56912daa367a04eaf7c715d1d9c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a088ca56912daa367a04eaf7c715d1d9c">has_local_iterator_v</a> = <a class="el" href="structkatana_1_1has__local__iterator.html">has_local_iterator</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a088ca56912daa367a04eaf7c715d1d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bbd71ce290ae17106f1ed289de971c"><td class="memTemplParams" colspan="2">template&lt;typename Base , typename Derived &gt; </td></tr>
<tr class="memitem:ad8bbd71ce290ae17106f1ed289de971c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#ad8bbd71ce290ae17106f1ed289de971c">at_least_base_of</a></td></tr>
<tr class="memdesc:ad8bbd71ce290ae17106f1ed289de971c"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if Derived is derived from Base or is Base itself.  <a href="namespacekatana.html#ad8bbd71ce290ae17106f1ed289de971c">More...</a><br /></td></tr>
<tr class="separator:ad8bbd71ce290ae17106f1ed289de971c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e52e589c5f15727849f9298bb0d178"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacekatana.html#ab846f7bdd2bd0cecf06708c1806a668f">PerSocketChunkFIFO</a>&lt; <a class="el" href="structkatana_1_1chunk__size.html">chunk_size</a>&lt;&gt;::value &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a16e52e589c5f15727849f9298bb0d178">defaultWL</a></td></tr>
<tr class="separator:a16e52e589c5f15727849f9298bb0d178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a996c85bab3fdbf1afad32e8595db32"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a0a996c85bab3fdbf1afad32e8595db32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structkatana_1_1s__wl.html">s_wl</a>&lt; T, Args... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana.html#a0a996c85bab3fdbf1afad32e8595db32">wl</a> (Args... args)</td></tr>
<tr class="separator:a0a996c85bab3fdbf1afad32e8595db32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Construct a <a class="el" href="classkatana_1_1PropertyGraph.html" title="A property graph is a graph that has properties associated with its nodes and edges.">PropertyGraph</a> in memory. </p>
<p>We have two strategies for Arrow conversion.</p>
<p>One uses arrow::stl::TableFromTupleRange, the other uses Builders. TableFromTupleRange is good for statically typed data present in an STL collection. Builders are good when static types are not known or data is being generated.</p>
<p>NB: The schema for a table returned by TableFromTupleRange will contain "not null." We make the type nullable in VectorToArrowTable. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a34052bd67465277c5c0f1566150f7778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34052bd67465277c5c0f1566150f7778">&#9670;&nbsp;</a></span>ArrayBuilders</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#a34052bd67465277c5c0f1566150f7778">katana::ArrayBuilders</a> = typedef std::vector&lt;std::shared_ptr&lt;arrow::ArrayBuilder&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac153ba2085dd5c0be210d19e2b0e2e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac153ba2085dd5c0be210d19e2b0e2e32">&#9670;&nbsp;</a></span>ArrowArrays</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#ac153ba2085dd5c0be210d19e2b0e2e32">katana::ArrowArrays</a> = typedef std::vector&lt;std::shared_ptr&lt;arrow::Array&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a377a12a6c4d2af8f936d7b1ff9e5fc3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a377a12a6c4d2af8f936d7b1ff9e5fc3e">&#9670;&nbsp;</a></span>ArrowFields</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#a377a12a6c4d2af8f936d7b1ff9e5fc3e">katana::ArrowFields</a> = typedef std::vector&lt;std::shared_ptr&lt;arrow::Field&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1bd207c3d84560c4872ffb3daa1ce963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd207c3d84560c4872ffb3daa1ce963">&#9670;&nbsp;</a></span>BooleanBuilders</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#a1bd207c3d84560c4872ffb3daa1ce963">katana::BooleanBuilders</a> = typedef std::vector&lt;std::shared_ptr&lt;arrow::BooleanBuilder&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7c790c9b26b98e164abc2c5e0449d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c790c9b26b98e164abc2c5e0449d45">&#9670;&nbsp;</a></span>ChunkFIFO</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int ChunkSize = 64, typename T  = int, bool Concurrent = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#ab7c790c9b26b98e164abc2c5e0449d45">katana::ChunkFIFO</a> = typedef internal::ChunkMaster&lt; T, <a class="el" href="classkatana_1_1ConExtLinkedQueue.html">ConExtLinkedQueue</a>, false, false, ChunkSize, Concurrent&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chunk FIFO. </p>
<p>A global FIFO of chunks of some fixed size.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ChunkSize</td><td>chunk size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a952ae2d2b3b5f99d90b6e04700c435a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952ae2d2b3b5f99d90b6e04700c435a3">&#9670;&nbsp;</a></span>ChunkLIFO</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int ChunkSize = 64, typename T  = int, bool Concurrent = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#a952ae2d2b3b5f99d90b6e04700c435a3">katana::ChunkLIFO</a> = typedef internal::ChunkMaster&lt; T, <a class="el" href="classkatana_1_1ConExtLinkedStack.html">ConExtLinkedStack</a>, false, true, ChunkSize, Concurrent&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chunk LIFO. </p>
<p>A global LIFO of chunks of some fixed size.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ChunkSize</td><td>chunk size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa95b9b34a27cfd81202928e7698e9653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa95b9b34a27cfd81202928e7698e9653">&#9670;&nbsp;</a></span>Clock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#aa95b9b34a27cfd81202928e7698e9653">katana::Clock</a> = typedef std::chrono::high_resolution_clock</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb0f205d2f588c9e6eee5e93c02bc5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0f205d2f588c9e6eee5e93c02bc5d6">&#9670;&nbsp;</a></span>concurrent_gslist</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned chunksize = 16&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#abb0f205d2f588c9e6eee5e93c02bc5d6">katana::concurrent_gslist</a> = typedef <a class="el" href="classkatana_1_1gslist__base.html">gslist_base</a>&lt;T, chunksize, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concurrent linked list. </p>
<p>To conserve space, allocator is maintained external to the list. Iteration order is unspecified. </p>

</div>
</div>
<a id="a7f289119101acc7d05a6fca24ba8f607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f289119101acc7d05a6fca24ba8f607">&#9670;&nbsp;</a></span>ConcurrentFixedSizeBag</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned ChunkSize = 64&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#a7f289119101acc7d05a6fca24ba8f607">katana::ConcurrentFixedSizeBag</a> = typedef <a class="el" href="classkatana_1_1FixedSizeBagBase.html">FixedSizeBagBase</a>&lt;T, ChunkSize, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unordered collection of bounded size with concurrent insertion or deletion but not both simultaneously. </p>

</div>
</div>
<a id="a16e52e589c5f15727849f9298bb0d178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e52e589c5f15727849f9298bb0d178">&#9670;&nbsp;</a></span>defaultWL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacekatana.html#ab846f7bdd2bd0cecf06708c1806a668f">PerSocketChunkFIFO</a>&lt;<a class="el" href="structkatana_1_1chunk__size.html">chunk_size</a>&lt;&gt;::value&gt; <a class="el" href="namespacekatana.html#a16e52e589c5f15727849f9298bb0d178">katana::defaultWL</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad93efdbdcf28e687428900efeda73ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93efdbdcf28e687428900efeda73ba4">&#9670;&nbsp;</a></span>enable_if_list_type_patched</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#ad93efdbdcf28e687428900efeda73ba4">katana::enable_if_list_type_patched</a> = typedef arrow::enable_if_t&lt;<a class="el" href="namespacekatana.html#a48505b29fc3b758864a6798815f38afc">is_list_type_patched</a>&lt;T&gt;::value, R&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84226ce246b0237245e6bb9069c7d092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84226ce246b0237245e6bb9069c7d092">&#9670;&nbsp;</a></span>FIFO</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#a84226ce246b0237245e6bb9069c7d092">katana::FIFO</a> = typedef <a class="el" href="classkatana_1_1Wrapper.html">Wrapper</a>&lt;T, std::deque&lt;T&gt;, false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa1dfda6e2830fcd2bb12d0164fd1608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa1dfda6e2830fcd2bb12d0164fd1608">&#9670;&nbsp;</a></span>FixedSizeBag</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned ChunkSize = 64&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#aaa1dfda6e2830fcd2bb12d0164fd1608">katana::FixedSizeBag</a> = typedef <a class="el" href="classkatana_1_1FixedSizeBagBase.html">FixedSizeBagBase</a>&lt;T, ChunkSize, false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unordered collection of bounded size. </p>

</div>
</div>
<a id="a714ec5bc951d6ab1ff98a1f15dd9bc4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714ec5bc951d6ab1ff98a1f15dd9bc4a">&#9670;&nbsp;</a></span>GFIFO</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#a714ec5bc951d6ab1ff98a1f15dd9bc4a">katana::GFIFO</a> = typedef <a class="el" href="classkatana_1_1Wrapper.html">Wrapper</a>&lt;T, <a class="el" href="classkatana_1_1gdeque.html">katana::gdeque</a>&lt;T&gt;, false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a38fd2c9cd3d14cdd7c06906939080006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38fd2c9cd3d14cdd7c06906939080006">&#9670;&nbsp;</a></span>GLIFO</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#a38fd2c9cd3d14cdd7c06906939080006">katana::GLIFO</a> = typedef <a class="el" href="classkatana_1_1Wrapper.html">Wrapper</a>&lt;T, <a class="el" href="classkatana_1_1gdeque.html">katana::gdeque</a>&lt;T&gt;, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa45c0b8fb3f5a82a6f96c2d50258a1d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45c0b8fb3f5a82a6f96c2d50258a1d3">&#9670;&nbsp;</a></span>gslist</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned chunksize = 16&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#aa45c0b8fb3f5a82a6f96c2d50258a1d3">katana::gslist</a> = typedef <a class="el" href="classkatana_1_1gslist__base.html">gslist_base</a>&lt;T, chunksize, false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Singly linked list. </p>
<p>To conserve space, allocator is maintained external to the list. </p>

</div>
</div>
<a id="a48505b29fc3b758864a6798815f38afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48505b29fc3b758864a6798815f38afc">&#9670;&nbsp;</a></span>is_list_type_patched</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#a48505b29fc3b758864a6798815f38afc">katana::is_list_type_patched</a> = typedef std::integral_constant&lt; bool, std::is_same&lt;T, arrow::ListType&gt;::value || std::is_same&lt;T, arrow::LargeListType&gt;::value || std::is_same&lt;T, arrow::FixedSizeListType&gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This enables Arrow visitors of the form: class Visitor { using ReturnType = void; // configurable. </p>
<p>template &lt;typename ArrowType, typename ArgumentType&gt; <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb" title="A Result is a T or an ErrorInfo.">katana::Result&lt;ReturnType&gt;</a> Call(ArgumentType arg); };</p>
<p>Visitor visitor; katana::VisitArrow(array, visitor); </p>

</div>
</div>
<a id="a09329c9ae65444d361341095b0c0fb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09329c9ae65444d361341095b0c0fb73">&#9670;&nbsp;</a></span>IterAllocBaseTy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classkatana_1_1BumpWithMallocHeap.html">katana::BumpWithMallocHeap</a>&lt;<a class="el" href="classkatana_1_1FreeListHeap.html">katana::FreeListHeap</a>&lt;<a class="el" href="classkatana_1_1SystemHeap.html">katana::SystemHeap</a>&gt; &gt; <a class="el" href="namespacekatana.html#a09329c9ae65444d361341095b0c0fb73">katana::IterAllocBaseTy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>[PerIterAllocTy example] Base allocator for per-iteration allocator </p>

</div>
</div>
<a id="a35860f323cd4a2faf392c984e77ba618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35860f323cd4a2faf392c984e77ba618">&#9670;&nbsp;</a></span>LAptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::unique_ptr&lt;void, internal::largeFreer&gt; <a class="el" href="namespacekatana.html#a35860f323cd4a2faf392c984e77ba618">katana::LAptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf7993944566434d2c819d10213374ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf7993944566434d2c819d10213374ee">&#9670;&nbsp;</a></span>LIFO</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#acf7993944566434d2c819d10213374ee">katana::LIFO</a> = typedef <a class="el" href="classkatana_1_1Wrapper.html">Wrapper</a>&lt;T, std::deque&lt;T&gt;, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaeccde14111dee36ee879ea833929193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeccde14111dee36ee879ea833929193">&#9670;&nbsp;</a></span>NullMaps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#aaeccde14111dee36ee879ea833929193">katana::NullMaps</a> = typedef std::pair&lt; std::unordered_map&lt;int, std::shared_ptr&lt;arrow::Array&gt; &gt;, std::unordered_map&lt;int, std::shared_ptr&lt;arrow::Array&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a482e28ae619c1a2de9364752b2848ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482e28ae619c1a2de9364752b2848ec3">&#9670;&nbsp;</a></span>opaque_id_value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpaqueIDType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#a482e28ae619c1a2de9364752b2848ec3">katana::opaque_id_value_type</a> = typedef decltype(<a class="el" href="namespacekatana.html#ac5038f4364fb63fb47b2f5b984e716f0">must_be_OpaqueID_subclass</a>(std::declval&lt;OpaqueIDType&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value type of an <a class="el" href="structkatana_1_1OpaqueID.html" title="Base class for opaque ID types.">OpaqueID</a> subclass. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structkatana_1_1OpaqueID.html" title="Base class for opaque ID types.">OpaqueID</a> </dd></dl>

</div>
</div>
<a id="a7456f5718807adfd1dafa96512a3bf5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7456f5718807adfd1dafa96512a3bf5f">&#9670;&nbsp;</a></span>OperatorReferenceType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#a7456f5718807adfd1dafa96512a3bf5f">katana::OperatorReferenceType</a> = typedef typename internal::OperatorReferenceType_impl&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f52a31ff8a25ead3235efa1534724a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f52a31ff8a25ead3235efa1534724a3">&#9670;&nbsp;</a></span>PerIterAllocTy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classkatana_1_1ExternalHeapAllocator.html">katana::ExternalHeapAllocator</a>&lt;char, <a class="el" href="namespacekatana.html#a09329c9ae65444d361341095b0c0fb73">IterAllocBaseTy</a>&gt; <a class="el" href="namespacekatana.html#a2f52a31ff8a25ead3235efa1534724a3">katana::PerIterAllocTy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Per-iteration allocator that conforms to STL allocator interface. </p>

</div>
</div>
<a id="afbe2e583b3a2f54a658c08932110f18e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe2e583b3a2f54a658c08932110f18e">&#9670;&nbsp;</a></span>PerSocketChunkBag</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int ChunkSize = 64, typename T  = int, bool Concurrent = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#afbe2e583b3a2f54a658c08932110f18e">katana::PerSocketChunkBag</a> = typedef internal::ChunkMaster&lt; T, <a class="el" href="classkatana_1_1ConExtLinkedQueue.html">ConExtLinkedQueue</a>, true, true, ChunkSize, Concurrent&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Distributed chunked bag. </p>
<p>A scalable and resource-efficient policy when you are agnostic to the particular scheduling order.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">chunksize</td><td>chunk size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab846f7bdd2bd0cecf06708c1806a668f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab846f7bdd2bd0cecf06708c1806a668f">&#9670;&nbsp;</a></span>PerSocketChunkFIFO</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int ChunkSize = 64, typename T  = int, bool Concurrent = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#ab846f7bdd2bd0cecf06708c1806a668f">katana::PerSocketChunkFIFO</a> = typedef internal::ChunkMaster&lt; T, <a class="el" href="classkatana_1_1ConExtLinkedQueue.html">ConExtLinkedQueue</a>, true, false, ChunkSize, Concurrent&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Distributed chunked FIFO. </p>
<p>A more scalable version of <a class="el" href="namespacekatana.html#ab7c790c9b26b98e164abc2c5e0449d45">ChunkFIFO</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ChunkSize</td><td>chunk size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61ae784a4e1b6a4885f4a32d144938ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ae784a4e1b6a4885f4a32d144938ec">&#9670;&nbsp;</a></span>PerSocketChunkLIFO</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int ChunkSize = 64, typename T  = int, bool Concurrent = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#a61ae784a4e1b6a4885f4a32d144938ec">katana::PerSocketChunkLIFO</a> = typedef internal::ChunkMaster&lt; T, <a class="el" href="classkatana_1_1ConExtLinkedStack.html">ConExtLinkedStack</a>, true, true, ChunkSize, Concurrent&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Distributed chunked LIFO. </p>
<p>A more scalable version of <a class="el" href="namespacekatana.html#a952ae2d2b3b5f99d90b6e04700c435a3">ChunkLIFO</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">chunksize</td><td>chunk size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2871917f6d0efc6dbe0207c6baa2429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2871917f6d0efc6dbe0207c6baa2429">&#9670;&nbsp;</a></span>PerThreadChunkFIFO</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int ChunkSize = 64, typename T  = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#ae2871917f6d0efc6dbe0207c6baa2429">katana::PerThreadChunkFIFO</a> = typedef <a class="el" href="structkatana_1_1PerThreadChunkMaster.html">PerThreadChunkMaster</a>&lt; false, ChunkSize, <a class="el" href="classkatana_1_1StealingQueue.html">StealingQueue</a>&lt;<a class="el" href="classkatana_1_1PerThreadChunkQueue.html">PerThreadChunkQueue</a>&gt;, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a2f492fc05abc037f021bfef430f3f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2f492fc05abc037f021bfef430f3f1">&#9670;&nbsp;</a></span>PerThreadChunkLIFO</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int ChunkSize = 64, typename T  = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#a4a2f492fc05abc037f021bfef430f3f1">katana::PerThreadChunkLIFO</a> = typedef <a class="el" href="structkatana_1_1PerThreadChunkMaster.html">PerThreadChunkMaster</a>&lt; true, ChunkSize, <a class="el" href="classkatana_1_1StealingQueue.html">StealingQueue</a>&lt;<a class="el" href="classkatana_1_1PerThreadChunkStack.html">PerThreadChunkStack</a>&gt;, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2d8be731b9710b958cc5d394ef2f505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d8be731b9710b958cc5d394ef2f505">&#9670;&nbsp;</a></span>Pow2VarSizeAlloc</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#aa2d8be731b9710b958cc5d394ef2f505">katana::Pow2VarSizeAlloc</a> = typedef <a class="el" href="classkatana_1_1Pow2BlockAllocator.html">Pow2BlockAllocator</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>[PerIterAllocTy example] </p>
<p>Scalable variable-sized allocator for T that allocates blocks of sizes in powers of 2 Useful for small and medium sized allocations, e.g. small or medium vectors, strings, deques </p>

</div>
</div>
<a id="a82c45912870ebf83f7455304855c5aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c45912870ebf83f7455304855c5aeb">&#9670;&nbsp;</a></span>PropertyArrowArrayType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Prop &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#a82c45912870ebf83f7455304855c5aeb">katana::PropertyArrowArrayType</a> = typedef typename arrow::TypeTraits&lt;<a class="el" href="namespacekatana.html#ae96891e61fe2d373acae3b4a9a206791">PropertyArrowType</a>&lt;Prop&gt; &gt;::ArrayType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afbfdff467f47dfe8a2ab1cc597d7584f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfdff467f47dfe8a2ab1cc597d7584f">&#9670;&nbsp;</a></span>PropertyArrowTuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#afbfdff467f47dfe8a2ab1cc597d7584f">katana::PropertyArrowTuple</a> = typedef typename internal::PropertyArrowTuple&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PropertyArrowTuple applies arrow::TypeTraits&lt;T::ArrowType&gt;::CType to a tuple of properties. </p>

</div>
</div>
<a id="ae96891e61fe2d373acae3b4a9a206791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae96891e61fe2d373acae3b4a9a206791">&#9670;&nbsp;</a></span>PropertyArrowType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Prop &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#ae96891e61fe2d373acae3b4a9a206791">katana::PropertyArrowType</a> = typedef typename <a class="el" href="structkatana_1_1PropertyTraits.html">PropertyTraits</a>&lt;Prop&gt;::ArrowType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa1bee45602998c333b50fc73a6d5498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa1bee45602998c333b50fc73a6d5498">&#9670;&nbsp;</a></span>PropertyConstReferenceType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Prop &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#aaa1bee45602998c333b50fc73a6d5498">katana::PropertyConstReferenceType</a> = typedef typename <a class="el" href="namespacekatana.html#aaf4b21fee4699f8130e3178ba8f67bf7">PropertyViewType</a>&lt;Prop&gt;::const_reference</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a53ce8aaa410efd9dbfd1eb814700c2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ce8aaa410efd9dbfd1eb814700c2ca">&#9670;&nbsp;</a></span>PropertyReferenceType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Prop &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#a53ce8aaa410efd9dbfd1eb814700c2ca">katana::PropertyReferenceType</a> = typedef typename <a class="el" href="namespacekatana.html#aaf4b21fee4699f8130e3178ba8f67bf7">PropertyViewType</a>&lt;Prop&gt;::reference</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4ca3836521e1363b4681229b26bacb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ca3836521e1363b4681229b26bacb7">&#9670;&nbsp;</a></span>PropertyViewTuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#aa4ca3836521e1363b4681229b26bacb7">katana::PropertyViewTuple</a> = typedef typename internal::PropertyViewTuple&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PropertyViewTuple applies PropertyViewType to a tuple of properties. </p>

</div>
</div>
<a id="aaf4b21fee4699f8130e3178ba8f67bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf4b21fee4699f8130e3178ba8f67bf7">&#9670;&nbsp;</a></span>PropertyViewType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Prop &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#aaf4b21fee4699f8130e3178ba8f67bf7">katana::PropertyViewType</a> = typedef typename <a class="el" href="structkatana_1_1PropertyTraits.html">PropertyTraits</a>&lt;Prop&gt;::ViewType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a90f4c6b4c41224bdb87892b16e067340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f4c6b4c41224bdb87892b16e067340">&#9670;&nbsp;</a></span>RandGenerator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#a90f4c6b4c41224bdb87892b16e067340">katana::RandGenerator</a> = typedef std::mt19937</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ef5f54fe30dfc7b2cf9294ac744d6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef5f54fe30dfc7b2cf9294ac744d6bb">&#9670;&nbsp;</a></span>Result</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a> = typedef BOOST_OUTCOME_V2_NAMESPACE::std_result&lt; T, <a class="el" href="classkatana_1_1ErrorInfo.html">ErrorInfo</a>, internal::abort_policy&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A Result is a T or an <a class="el" href="classkatana_1_1ErrorInfo.html" title="An ErrorInfo contains additional context about an error in addition to an error code.">ErrorInfo</a>. </p>

</div>
</div>
<a id="ad53d5a0919afb768f3ad0304893c5925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad53d5a0919afb768f3ad0304893c5925">&#9670;&nbsp;</a></span>TimePoint</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#ad53d5a0919afb768f3ad0304893c5925">katana::TimePoint</a> = typedef std::chrono::time_point&lt;<a class="el" href="namespacekatana.html#aa95b9b34a27cfd81202928e7698e9653">Clock</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4969f8e91adb1b78e697a9cff98d9bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4969f8e91adb1b78e697a9cff98d9bd3">&#9670;&nbsp;</a></span>trait_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#a4969f8e91adb1b78e697a9cff98d9bd3">katana::trait_type_t</a> = typedef typename std::tuple_element&lt;<a class="el" href="namespacekatana.html#a8c11c7e97215b2746292a3df68e88c9f">find_trait</a>&lt;T, Tuple&gt;(), Tuple&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ada32e492c7349b1893be8f4849e76852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada32e492c7349b1893be8f4849e76852">&#9670;&nbsp;</a></span>TupleElements</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tuple , size_t... indices&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana.html#ada32e492c7349b1893be8f4849e76852">katana::TupleElements</a> = typedef std::tuple&lt;std::tuple_element_t&lt;indices, Tuple&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TupleElements selects the tuple elements at the given indices. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="abe87e3fefa44cdaf3f6d806d46167ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe87e3fefa44cdaf3f6d806d46167ceb">&#9670;&nbsp;</a></span>ConflictFlag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacekatana.html#abe87e3fefa44cdaf3f6d806d46167ceb">katana::ConflictFlag</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abe87e3fefa44cdaf3f6d806d46167cebaca0fecc4da9701e8eaab62ade337374f"></a>CONFLICT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abe87e3fefa44cdaf3f6d806d46167ceba3e2d012f862ac17b595fbfbf1843e09d"></a>NO_CONFLICT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abe87e3fefa44cdaf3f6d806d46167ceba905c201c162afcb055518e360d92ad86"></a>REACHED_FAILSAFE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abe87e3fefa44cdaf3f6d806d46167cebaeb06e23a71a7949f857b8d198ac687dd"></a>BREAK&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a9d227598262d7bcbd17e8270fdc25d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d227598262d7bcbd17e8270fdc25d56">&#9670;&nbsp;</a></span>ErrorCode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacekatana.html#a9d227598262d7bcbd17e8270fdc25d56">katana::ErrorCode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9d227598262d7bcbd17e8270fdc25d56a253ca7dd096ee0956cccee4d376cab8b"></a>InvalidArgument&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9d227598262d7bcbd17e8270fdc25d56a997ca4ce119685f40f03a9a8a6c5346e"></a>NotImplemented&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9d227598262d7bcbd17e8270fdc25d56a38c300f4fc9ce8a77aad4a30de05cad8"></a>NotFound&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9d227598262d7bcbd17e8270fdc25d56a23c92beca28d9939df06c7a804e5fe81"></a>ArrowError&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9d227598262d7bcbd17e8270fdc25d56ac9f577ac2188250a8a440c25109b4129"></a>JsonParseFailed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9d227598262d7bcbd17e8270fdc25d56aefa880dac8d229e8d19b697841563f05"></a>JsonDumpFailed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9d227598262d7bcbd17e8270fdc25d56a2feb6ea3db3fd8eb9ec285f21f1ef868"></a>HttpError&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9d227598262d7bcbd17e8270fdc25d56ab7b1e314614cf326c6e2b6eba1540682"></a>TODO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9d227598262d7bcbd17e8270fdc25d56ab90705e8d1c51a36cdcf8e4daf3be564"></a>PropertyNotFound&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9d227598262d7bcbd17e8270fdc25d56a89b69484680b18e9179e826c6e023805"></a>AlreadyExists&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9d227598262d7bcbd17e8270fdc25d56a137bf8cff2d59f0883c600f9524b3eed"></a>TypeError&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9d227598262d7bcbd17e8270fdc25d56ac7bca54dd788dd9a141de983df16916d"></a>AssertionFailed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9d227598262d7bcbd17e8270fdc25d56ab65c0861ac72bbaa6339c76132fda8d9"></a>GraphUpdateFailed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9d227598262d7bcbd17e8270fdc25d56a1e8a2f742b0e2bf8256ebb89f095dfc5"></a>FeatureNotEnabled&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="aaddb70632c03509301eb162e81515bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaddb70632c03509301eb162e81515bff">&#9670;&nbsp;</a></span>ImportDataType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacekatana.html#aaddb70632c03509301eb162e81515bff">katana::ImportDataType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aaddb70632c03509301eb162e81515bffa26d2ec82db964954b2ebd0106c88dcc8"></a>kString&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aaddb70632c03509301eb162e81515bffabd2b9300b3cd517af047c9a65900ea1d"></a>kInt64&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aaddb70632c03509301eb162e81515bffa9f185c15cba6a31c303b3154ac5f9bc6"></a>kInt32&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aaddb70632c03509301eb162e81515bffa254d3ee3a61879dc26b0b3c546cd6a86"></a>kUInt32&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aaddb70632c03509301eb162e81515bffacf897f4aaf961485c08defb713e9880c"></a>kDouble&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aaddb70632c03509301eb162e81515bffa65a34000c0df856063234b8ace7d58f7"></a>kFloat&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aaddb70632c03509301eb162e81515bffa8688601c5df2549b8c6cc93ac69a880a"></a>kBoolean&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aaddb70632c03509301eb162e81515bffa0e78936e27a277998a6951ad61f400d5"></a>kTimestampMilli&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aaddb70632c03509301eb162e81515bffaf32daeddef66bda7ba962b18098da5be"></a>kStruct&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aaddb70632c03509301eb162e81515bffa79361bb29fe1d25f1d13d8e7ae7be766"></a>kUnsupported&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ab1c012a5bda211a6470b9e8424c14e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c012a5bda211a6470b9e8424c14e7b">&#9670;&nbsp;</a></span>LogLevel</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacekatana.html#ab1c012a5bda211a6470b9e8424c14e7b">katana::LogLevel</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab1c012a5bda211a6470b9e8424c14e7baa603905470e2a5b8c13e96b579ef0dba"></a>Debug&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab1c012a5bda211a6470b9e8424c14e7bad4a9fa383ab700c5bdd6f31cf7df0faf"></a>Verbose&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab1c012a5bda211a6470b9e8424c14e7ba0eaadb4fcb48a0a0ed7bc9868be9fbaa"></a>Warning&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab1c012a5bda211a6470b9e8424c14e7ba902b0d55fddef6f8d651fe1035b7d4bd"></a>Error&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a679ab3b4021187532d65e16ceb3fc246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679ab3b4021187532d65e16ceb3fc246">&#9670;&nbsp;</a></span>MethodFlag</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246">katana::MethodFlag</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>What should the runtime do when executing a method. </p>
<p>Various methods take an optional parameter indicating what actions the runtime should do on the user's behalf: (1) checking for conflicts, and/or (2) saving undo information. By default, both are performed (ALL). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a679ab3b4021187532d65e16ceb3fc246a937e6a98c210e6d3d0af5ed55de70d3b"></a>UNPROTECTED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a679ab3b4021187532d65e16ceb3fc246ad4b9e47f65b6e79b010582f15785867e"></a>WRITE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a679ab3b4021187532d65e16ceb3fc246a3466fab4975481651940ed328aa990e4"></a>READ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a679ab3b4021187532d65e16ceb3fc246a82109e7d807e8a6ffa3ff3648e1ff809"></a>INTERNAL_MASK&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a679ab3b4021187532d65e16ceb3fc246a315ba7a868d45a9cb131c8dca3166b51"></a>PREVIOUS&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a85815a5455e9140c17d581c3c4247c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85815a5455e9140c17d581c3c4247c57">&#9670;&nbsp;</a></span>SourceDatabase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacekatana.html#a85815a5455e9140c17d581c3c4247c57">katana::SourceDatabase</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a85815a5455e9140c17d581c3c4247c57a4306bbd219bb4a3321a31d2ba2082245"></a>kNone&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a85815a5455e9140c17d581c3c4247c57ae509d183b8082e02d13724db4aef2283"></a>kNeo4j&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a85815a5455e9140c17d581c3c4247c57ab18dc51293ec490624d3bda40d1fe7ed"></a>kMongodb&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a85815a5455e9140c17d581c3c4247c57acb840e7e4ee5d9993194c4adba189880"></a>kMysql&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ada19d9d708b680e28f2c232679afcae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada19d9d708b680e28f2c232679afcae2">&#9670;&nbsp;</a></span>SourceType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacekatana.html#ada19d9d708b680e28f2c232679afcae2">katana::SourceType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ada19d9d708b680e28f2c232679afcae2a6a17a3f48e2bdd78e6ecb0613efc4eb8"></a>kGraphml&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ada19d9d708b680e28f2c232679afcae2a84b36fcfbd942093ad27034be0eccfc4"></a>kKatana&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ace496da656c162751f4b8c59c8bff827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace496da656c162751f4b8c59c8bff827">&#9670;&nbsp;</a></span>AbortApplication()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void katana::AbortApplication </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a79d59247a304c083855ea74a9cd24205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d59247a304c083855ea74a9cd24205">&#9670;&nbsp;</a></span>acquire()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void katana::acquire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1Lockable.html">Lockable</a> *&#160;</td>
          <td class="paramname"><em>lockable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246">katana::MethodFlag</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Master function which handles conflict detection used to acquire a lockable thing. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="lonestar_2tutorial_examples_2ConflictAwareTorus_8cpp-example.html#a6">lonestar/tutorial_examples/ConflictAwareTorus.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="afef0ed8904443f99eb725ea286f009f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef0ed8904443f99eb725ea286f009f4">&#9670;&nbsp;</a></span>AlignDown()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , std::enable_if_t&lt; std::is_integral&lt; U &gt;::value, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr U katana::AlignDown </td>
          <td>(</td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a86a51b72d99b8ac0ca754196016330b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a51b72d99b8ac0ca754196016330b2">&#9670;&nbsp;</a></span>AlignUp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , std::enable_if_t&lt; std::is_integral&lt; U &gt;::value, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr U katana::AlignUp </td>
          <td>(</td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab90a91526675c58912fc6775b5263a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90a91526675c58912fc6775b5263a15">&#9670;&nbsp;</a></span>AllocateTable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Props &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt;std::shared_ptr&lt;arrow::Table&gt; &gt; katana::AllocateTable </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7940de2bae2976ddc9328f7fef9cf93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7940de2bae2976ddc9328f7fef9cf93b">&#9670;&nbsp;</a></span>allocPages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * katana::allocPages </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preFault</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7466f513f15c02ef5f9601f7cd40d370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7466f513f15c02ef5f9601f7cd40d370">&#9670;&nbsp;</a></span>allocSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t katana::allocSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a255e9a26d5902eaf192185f4e83c5e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a255e9a26d5902eaf192185f4e83c5e69">&#9670;&nbsp;</a></span>ApproxArrayMemUse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t katana::ApproxArrayMemUse </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; arrow::Array &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimate the amount of memory this array is using n.b. </p>
<p>Estimate is best effort when array is a slice or a variable type like large_string; it will be an upper bound in those cases </p>

</div>
</div>
<a id="a10c6e13e5a4268af8dcbdf958caa973a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c6e13e5a4268af8dcbdf958caa973a">&#9670;&nbsp;</a></span>ArrayFromScalars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; std::shared_ptr&lt; arrow::Array &gt; &gt; katana::ArrayFromScalars </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; arrow::Scalar &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>scalars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; arrow::DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a vector of scalars of type data_type and return an Array. </p>

</div>
</div>
<a id="a1230aa54a2f09d6eef51d0ef55f28f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1230aa54a2f09d6eef51d0ef55f28f1e">&#9670;&nbsp;</a></span>ArrowToImport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structkatana_1_1ImportData.html">katana::ImportData</a> &gt; katana::ArrowToImport </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; arrow::ChunkedArray &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert Arrow chunked array to/from a vector of <a class="el" href="structkatana_1_1ImportData.html">ImportData</a>. </p>

</div>
</div>
<a id="ace6ac16a63bccd5bb77a0b7fd5030a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6ac16a63bccd5bb77a0b7fd5030a97">&#9670;&nbsp;</a></span>ArrowToKatana() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a9d227598262d7bcbd17e8270fdc25d56">ErrorCode</a> katana::ArrowToKatana </td>
          <td>(</td>
          <td class="paramtype">arrow::Status&#160;</td>
          <td class="paramname"><em>st</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aefaa588ef763a587b0bdf68faf7f8018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefaa588ef763a587b0bdf68faf7f8018">&#9670;&nbsp;</a></span>ArrowToKatana() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a9d227598262d7bcbd17e8270fdc25d56">katana::ErrorCode</a> katana::ArrowToKatana </td>
          <td>(</td>
          <td class="paramtype">arrow::StatusCode&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aef794a8be1062171ff176b4b2b37931d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef794a8be1062171ff176b4b2b37931d">&#9670;&nbsp;</a></span>atomicAdd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T katana::atomicAdd </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c1b28c2c66d52c79ee4db904b631c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1b28c2c66d52c79ee4db904b631c9d">&#9670;&nbsp;</a></span>atomicAdd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T katana::atomicAdd </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt;!std::is_integral_v&lt; T &gt; &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a44eef90a442ccc2bddcc5878dadcd712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44eef90a442ccc2bddcc5878dadcd712">&#9670;&nbsp;</a></span>atomicMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T katana::atomicMax </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad07d172fe8abf6b293db153ca1700131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07d172fe8abf6b293db153ca1700131">&#9670;&nbsp;</a></span>atomicMin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T katana::atomicMin </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e5c06554a539e9ba834cd4099e58564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e5c06554a539e9ba834cd4099e58564">&#9670;&nbsp;</a></span>atomicSub() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T katana::atomicSub </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0014b18f0cd2aae01375d6139ecc2660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0014b18f0cd2aae01375d6139ecc2660">&#9670;&nbsp;</a></span>atomicSub() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T katana::atomicSub </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt;!std::is_integral_v&lt; T &gt; &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a70ea5b7e9709ae81e07009f6575fe062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70ea5b7e9709ae81e07009f6575fe062">&#9670;&nbsp;</a></span>bindThreadSelf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool katana::bindThreadSelf </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] unsigned&#160;</td>
          <td class="paramname"><em>osContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>bindThreadSelf binds a thread to an osContext as returned by getHWTopo. </p>
<p>binds current thread to OS HW context "proc" </p>

</div>
</div>
<a id="aa35d4fcb06589c0877a7ee1868e69be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa35d4fcb06589c0877a7ee1868e69be9">&#9670;&nbsp;</a></span>block_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntTy , typename std::enable_if&lt; std::is_integral&lt; IntTy &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;IntTy, IntTy&gt; katana::block_range </td>
          <td>(</td>
          <td class="paramtype">IntTy&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntTy&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a345761715af2a1d97b495d52aa46cc59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345761715af2a1d97b495d52aa46cc59">&#9670;&nbsp;</a></span>block_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IterTy , typename std::enable_if&lt;!std::is_integral&lt; IterTy &gt;::value &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;IterTy, IterTy&gt; katana::block_range </td>
          <td>(</td>
          <td class="paramtype">IterTy&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterTy&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a continuous block from the range based on the number of divisions and the id of the block requested. </p>

</div>
</div>
<a id="ac443dfc789e2c9a96edb8e23f74d2519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac443dfc789e2c9a96edb8e23f74d2519">&#9670;&nbsp;</a></span>BuildArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;arrow::Array&gt; katana::BuildArray </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>BuildArray copies the input data into an arrow array. </p>

</div>
</div>
<a id="a76f7cf95822545808b5643524392cab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f7cf95822545808b5643524392cab6">&#9670;&nbsp;</a></span>BytesToStr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string katana::BytesToStr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>bytes_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a13d3d3094b541b09751e28b4f60ca2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d3d3094b541b09751e28b4f60ca2ca">&#9670;&nbsp;</a></span>ConstructPropertyView()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Prop &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt;<a class="el" href="namespacekatana.html#aaf4b21fee4699f8130e3178ba8f67bf7">PropertyViewType</a>&lt;Prop&gt; &gt; katana::ConstructPropertyView </td>
          <td>(</td>
          <td class="paramtype">arrow::Array *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ConstructPropertyView applies a property view to an arrow::Array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Prop</td><td>A property </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>An array to apply view to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The view corresponding to given array or nullopt if the array cannot be downcast to the array type for the property. </dd></dl>

</div>
</div>
<a id="a6066d13104ba2b718938aefa9760a334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6066d13104ba2b718938aefa9760a334">&#9670;&nbsp;</a></span>ConstructPropertyViews() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PropTuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt;std::tuple&lt;&gt; &gt; katana::ConstructPropertyViews </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; arrow::Array * &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt;&gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ConstructPropertyViews applies ConstructPropertyView to a tuple of properties. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PropTuple</td><td>a tuple of properties</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacekatana.html#a13d3d3094b541b09751e28b4f60ca2ca" title="ConstructPropertyView applies a property view to an arrow::Array.">ConstructPropertyView</a> </dd></dl>

</div>
</div>
<a id="afc5723542ab0fdcf05904dca7ece0804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc5723542ab0fdcf05904dca7ece0804">&#9670;&nbsp;</a></span>ConstructPropertyViews() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PropTuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt;<a class="el" href="namespacekatana.html#aa4ca3836521e1363b4681229b26bacb7">PropertyViewTuple</a>&lt;PropTuple&gt; &gt; katana::ConstructPropertyViews </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; arrow::Array * &gt; &amp;&#160;</td>
          <td class="paramname"><em>arrays</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa52d589eb252be44211be38ce54309ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52d589eb252be44211be38ce54309ec">&#9670;&nbsp;</a></span>ConstructPropertyViews() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PropTuple , size_t head, size_t... tail&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt;<a class="el" href="namespacekatana.html#ada32e492c7349b1893be8f4849e76852">TupleElements</a>&lt;<a class="el" href="namespacekatana.html#aa4ca3836521e1363b4681229b26bacb7">PropertyViewTuple</a>&lt;PropTuple&gt;, head, tail...&gt; &gt; katana::ConstructPropertyViews </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; arrow::Array * &gt; &amp;&#160;</td>
          <td class="paramname"><em>arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; head, tail... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a384c411cf25b6d8cf613fba36d7155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a384c411cf25b6d8cf613fba36d7155">&#9670;&nbsp;</a></span>ConvertGraphML()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; <a class="el" href="structkatana_1_1GraphComponents.html">katana::GraphComponents</a> &gt; katana::ConvertGraphML </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>infilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>25000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ConvertGraphML converts a GraphML file into katana form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">infilename</td><td>Path to source graphml file </td></tr>
    <tr><td class="paramname"><a class="el" href="structkatana_1_1chunk__size.html" title="Specify chunk size for do_all_coupled &amp; do_all_choice at compile time or at runtime.">chunk_size</a></td><td>Chunk size for in memory representations during conversion. Generally this term can be ignored, but it can be decreased to reduce memory usage when converting large inputs </td></tr>
    <tr><td class="paramname">verbose</td><td>If true, print graph data to the standard out while converting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A collection of Arrow tables of node properties/labels, edge properties/types, and CSR topology </dd></dl>

</div>
</div>
<a id="aea1412ef1a9aae93857afd724ed8a1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1412ef1a9aae93857afd724ed8a1b7">&#9670;&nbsp;</a></span>CreateCountingBarrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classkatana_1_1Barrier.html">katana::Barrier</a> &gt; katana::CreateCountingBarrier </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>active_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b230a1d5e98eebb129da3fdff8f3963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b230a1d5e98eebb129da3fdff8f3963">&#9670;&nbsp;</a></span>CreateDisseminationBarrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classkatana_1_1Barrier.html">katana::Barrier</a> &gt; katana::CreateDisseminationBarrier </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>active_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a90464688cec2043a116bcdd6eba61b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90464688cec2043a116bcdd6eba61b78">&#9670;&nbsp;</a></span>CreateMCSBarrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classkatana_1_1Barrier.html">katana::Barrier</a> &gt; katana::CreateMCSBarrier </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>active_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create specific types of barriers. </p>
<p>For benchmarking only. Use <a class="el" href="namespacekatana.html#ab473e662b3aed5db12ebd185fca76f11" title="Return a reference to system barrier.">GetBarrier()</a> for all production code </p>

</div>
</div>
<a id="a427f77208349841b073228fd4a28022d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a427f77208349841b073228fd4a28022d">&#9670;&nbsp;</a></span>CreateSimpleBarrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classkatana_1_1Barrier.html">katana::Barrier</a> &gt; katana::CreateSimpleBarrier </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>active_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new simple barrier. </p>
<p>This barrier is not designed to be fast but does guarantee that all threads have left the barrier before returning control. Useful when the number of active threads is modified to avoid a race in <a class="el" href="namespacekatana.html#ab473e662b3aed5db12ebd185fca76f11" title="Return a reference to system barrier.">GetBarrier()</a>. Client is responsible for deallocating returned barrier. </p>

</div>
</div>
<a id="a67acb78e8d11ff97f818977c58ed8ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67acb78e8d11ff97f818977c58ed8ea5">&#9670;&nbsp;</a></span>CreateSymmetricGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; std::unique_ptr&lt; <a class="el" href="classkatana_1_1PropertyGraph.html">katana::PropertyGraph</a> &gt; &gt; katana::CreateSymmetricGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">katana::PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates in-memory symmetric (or undirected) graph. </p>
<p>This function creates an symmetric or undirected version of the <a class="el" href="classkatana_1_1PropertyGraph.html" title="A property graph is a graph that has properties associated with its nodes and edges.">PropertyGraph</a> topology by adding reverse edges in-memory.</p>
<p>For each edge (a, b) in the graph, this function will add an additional edge (b, a) except when a == b, in which case, no additional edge is added. The generated symmetric graph may have duplicate edges. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pg</td><td>The original property graph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new symmetric property graph by adding reverse edges </dd></dl>

</div>
</div>
<a id="af030ab004a8288eb76f0ef66834c1c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af030ab004a8288eb76f0ef66834c1c02">&#9670;&nbsp;</a></span>CreateTopoBarrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classkatana_1_1Barrier.html">katana::Barrier</a> &gt; katana::CreateTopoBarrier </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>active_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa306ef2add21d28b0fe75e90d1b3079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa306ef2add21d28b0fe75e90d1b3079">&#9670;&nbsp;</a></span>CreateTransposeGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; std::unique_ptr&lt; <a class="el" href="classkatana_1_1PropertyGraph.html">katana::PropertyGraph</a> &gt; &gt; katana::CreateTransposeGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">katana::PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates in-memory transpose graph. </p>
<p>This function creates transpose version of the <a class="el" href="classkatana_1_1PropertyGraph.html" title="A property graph is a graph that has properties associated with its nodes and edges.">PropertyGraph</a> topology by reversing the edges in-memory.</p>
<p>For each edge (a, b) in the graph, this function will add edge (b, a) without retaining the original edge (a, b) unlike CreateSymmetricGraph. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pg</td><td>The original property graph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new transposed property graph by reversing the edges </dd></dl>

</div>
</div>
<a id="a9df01f742edb20057d834294ccab02c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df01f742edb20057d834294ccab02c2">&#9670;&nbsp;</a></span>determineUnitRangesFromGraph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;uint32_t&gt; katana::determineUnitRangesFromGraph </td>
          <td>(</td>
          <td class="paramtype">GraphTy &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>unitsToSplit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>beginNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nodeAlpha</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines node division ranges for a given range of nodes and returns it as an offset vector. </p>
<p>(node ranges = assigned nodes that a particular unit of execution should work on)</p>
<p>Checks for corner cases, then calls the main loop function.</p>
<p>ONLY CALL AFTER GRAPH IS CONSTRUCTED as it uses functions that assume the graph is already constructed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GraphTy</td><td>type of the graph object</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph object to get prefix sum information from </td></tr>
    <tr><td class="paramname">unitsToSplit</td><td>number of units to split nodes among </td></tr>
    <tr><td class="paramname">beginNode</td><td>Beginning of range </td></tr>
    <tr><td class="paramname">endNode</td><td>End of range, non-inclusive </td></tr>
    <tr><td class="paramname">nodeAlpha</td><td>The higher the number, the more weight nodes have in determining division of nodes (edges have weight 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector that indirectly specifies which units get which nodes </dd></dl>

</div>
</div>
<a id="a8637bfb06d4ed0899eb6ec2090f3129d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8637bfb06d4ed0899eb6ec2090f3129d">&#9670;&nbsp;</a></span>determineUnitRangesFromGraph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;uint32_t&gt; katana::determineUnitRangesFromGraph </td>
          <td>(</td>
          <td class="paramtype">GraphTy &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>unitsToSplit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nodeAlpha</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines node division ranges for all nodes in a graph and returns it in an offset vector. </p>
<p>(node ranges = assigned nodes that a particular unit of execution should work on)</p>
<p>Checks for corner cases, then calls the main loop function.</p>
<p>ONLY CALL AFTER GRAPH IS CONSTRUCTED as it uses functions that assume the graph is already constructed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GraphTy</td><td>type of the graph object</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The graph object to get prefix sum information from </td></tr>
    <tr><td class="paramname">unitsToSplit</td><td>number of units to split nodes among </td></tr>
    <tr><td class="paramname">nodeAlpha</td><td>The higher the number, the more weight nodes have in determining division of nodes (edges have weight 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector that indirectly specifies which units get which nodes </dd></dl>

</div>
</div>
<a id="a5333d119c05232d54b6534f1ac505726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5333d119c05232d54b6534f1ac505726">&#9670;&nbsp;</a></span>determineUnitRangesFromPrefixSum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;uint32_t&gt; katana::determineUnitRangesFromPrefixSum </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>unitsToSplit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorTy &amp;&#160;</td>
          <td class="paramname"><em>edgePrefixSum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>beginNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>endNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nodeAlpha</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses the divideByNode function (which is binary search based) to divide nodes among units using a provided prefix sum. </p>
<p>Provide a node range so that the prefix sum is only calculated using that range.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VectorTy</td><td>type of the prefix sum object</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unitsToSplit</td><td>number of units to split nodes among </td></tr>
    <tr><td class="paramname">edgePrefixSum</td><td>A prefix sum of edges </td></tr>
    <tr><td class="paramname">beginNode</td><td>Beginning of range </td></tr>
    <tr><td class="paramname">endNode</td><td>End of range, non-inclusive </td></tr>
    <tr><td class="paramname">nodeAlpha</td><td>amount of weight to give to nodes when dividing work among threads </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector that indirectly specifies how nodes are split amongs units of execution </dd></dl>

</div>
</div>
<a id="ae49ce4076f90629479d086480527eb3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49ce4076f90629479d086480527eb3c">&#9670;&nbsp;</a></span>determineUnitRangesFromPrefixSum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;uint32_t&gt; katana::determineUnitRangesFromPrefixSum </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>unitsToSplit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorTy &amp;&#160;</td>
          <td class="paramname"><em>edgePrefixSum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nodeAlpha</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses the divideByNode function (which is binary search based) to divide nodes among units using a provided prefix sum. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VectorTy</td><td>type of the prefix sum object</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unitsToSplit</td><td>number of units to split nodes among </td></tr>
    <tr><td class="paramname">edgePrefixSum</td><td>A prefix sum of edges </td></tr>
    <tr><td class="paramname">numNodes</td><td>number of nodes in the graph </td></tr>
    <tr><td class="paramname">nodeAlpha</td><td>amount of weight to give to nodes when dividing work among threads </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector that indirectly specifies how nodes are split amongs units of execution </dd></dl>

</div>
</div>
<a id="affa9a80bc3a0c7afd2d975e8a43b7738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa9a80bc3a0c7afd2d975e8a43b7738">&#9670;&nbsp;</a></span>DiffFormatTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void katana::DiffFormatTo </td>
          <td>(</td>
          <td class="paramtype">fmt::memory_buffer *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; arrow::ChunkedArray &gt; &amp;&#160;</td>
          <td class="paramname"><em>a0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; arrow::ChunkedArray &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>approx_total_characters</em> = <code>150</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the differences between two ChunkedArrays only using about approx_total_characters. </p>

</div>
</div>
<a id="aa9556696505c9936a648c93a1c9d80b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9556696505c9936a648c93a1c9d80b6">&#9670;&nbsp;</a></span>divideNodesBinarySearch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PrefixSumType , typename NodeType  = uint64_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto katana::divideNodesBinarySearch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="async_8cpp.html#ab77c64e1d2710678e2f5d9918ff2f8ea">NodeType</a>&#160;</td>
          <td class="paramname"><em>numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>numEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nodeWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edgeWeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>total</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PrefixSumType &amp;&#160;</td>
          <td class="paramname"><em>edgePrefixSum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned &gt;&#160;</td>
          <td class="paramname"><em>scaleFactor</em> = <code>std::vector&lt;unsigned&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>edgeOffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>nodeOffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns 2 ranges (one for nodes, one for edges) for a particular division. </p>
<p>The ranges specify the nodes/edges that a division is responsible for. The function attempts to split them evenly among units given some kind of weighting for both nodes and edges.</p>
<p>Assumes the parameters passed in apply to a local portion of whatever is being divided (i.e. concept of a "global" object is abstracted away in some sense)</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PrefixSumType</td><td>type of the object that holds the edge prefix sum </td></tr>
    <tr><td class="paramname">NodeType</td><td>size of the type representing the node</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numNodes</td><td>Total number of nodes included in prefix sum </td></tr>
    <tr><td class="paramname">numEdges</td><td>Total number of edges included in prefix sum </td></tr>
    <tr><td class="paramname">nodeWeight</td><td>weight to give to a node in division </td></tr>
    <tr><td class="paramname">edgeWeight</td><td>weight to give to an edge in division </td></tr>
    <tr><td class="paramname">id</td><td>Division number you want the range for </td></tr>
    <tr><td class="paramname">total</td><td>Total number of divisions to divide nodes among </td></tr>
    <tr><td class="paramname">edgePrefixSum</td><td>Prefix sum of the edges in the graph </td></tr>
    <tr><td class="paramname">scaleFactor</td><td>Vector specifying if certain divisions should get more than other divisions </td></tr>
    <tr><td class="paramname">edgeOffset</td><td>number of edges to subtract from numbers in edgePrefixSum </td></tr>
    <tr><td class="paramname">nodeOffset</td><td>number of nodes to skip over when looking in the prefix sum: useful if the prefix sum is over the entire graph while you just want to divide the nodes for a particular region (jump to the region with the nodeOffset)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A node pair and an edge pair specifying the assigned nodes/edges to division "id"; returns LOCAL ids, not global ids (i.e. if node offset was used, it is up to the caller to add the offset to the numbers) </dd></dl>

</div>
</div>
<a id="ab9ea3b9de54b0c2f223eb585f4aefaff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9ea3b9de54b0c2f223eb585f4aefaff">&#9670;&nbsp;</a></span>do_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename FunctionTy , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::do_all </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionTy &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard do-all loop. </p>
<p>All iterations should be independent.</p>
<p>Operator should conform to <code>fn(item)</code> where item is a value from the iteration range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>an iterator range typically returned by <a class="el" href="namespacekatana.html#a664a7f49a65e22807577f6cc809a7827">katana::iterate</a> </td></tr>
    <tr><td class="paramname">fn</td><td>operator </td></tr>
    <tr><td class="paramname">args</td><td>optional arguments to loop </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="lonestar_2tutorial_examples_2ConflictAwareTorus_8cpp-example.html#a9">lonestar/tutorial_examples/ConflictAwareTorus.cpp</a>, <a class="el" href="lonestar_2tutorial_examples_2CountLevels_8cpp-example.html#a3">lonestar/tutorial_examples/CountLevels.cpp</a>, <a class="el" href="lonestar_2tutorial_examples_2GraphTraversalPullOperator_8cpp-example.html#a9">lonestar/tutorial_examples/GraphTraversalPullOperator.cpp</a>, <a class="el" href="lonestar_2tutorial_examples_2GraphTraversalPushOperator_8cpp-example.html#a2">lonestar/tutorial_examples/GraphTraversalPushOperator.cpp</a>, and <a class="el" href="lonestar_2tutorial_examples_2SSSPPushSimple_8cpp-example.html#a5">lonestar/tutorial_examples/SSSPPushSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a23ff620616f4ea17557e618f51f7d7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23ff620616f4ea17557e618f51f7d7f7">&#9670;&nbsp;</a></span>do_all_gen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename F , typename ArgsTuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::do_all_gen </td>
          <td>(</td>
          <td class="paramtype">const R &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArgsTuple &amp;&#160;</td>
          <td class="paramname"><em>argsTuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a803887bcce7f07a73115db324810d629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803887bcce7f07a73115db324810d629">&#9670;&nbsp;</a></span>doAcquire()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void katana::doAcquire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1Lockable.html">Lockable</a> *&#160;</td>
          <td class="paramname"><em>lockable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246">katana::MethodFlag</a>&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>actual locking function. Will always lock. </p>

</div>
</div>
<a id="aee1583134ee5266ec9d809fcf71fb8f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee1583134ee5266ec9d809fcf71fb8f7">&#9670;&nbsp;</a></span>EnsurePreallocated() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void katana::EnsurePreallocated </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pages</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensures an amount of memory be free on each thread. </p>
<p>The allocation size is given in total pages which will be divided amongst the threads. </p>

</div>
</div>
<a id="a037533772cd984719ae5476ee6a591d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037533772cd984719ae5476ee6a591d1">&#9670;&nbsp;</a></span>EnsurePreallocated() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void katana::EnsurePreallocated </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pagesPerThread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensures an amount of memory be free on each thread. </p>
<p>The allocation size is given in pages per thread and total bytes which will be divided amongst the threads. </p>

</div>
</div>
<a id="a014df3be01efa8912d944df28bdf9079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014df3be01efa8912d944df28bdf9079">&#9670;&nbsp;</a></span>EnvCheck() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool katana::EnvCheck </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>varName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the Enviroment variable is set. </p>

</div>
</div>
<a id="a4d3dd97ad6b73068f9718c1d9a68adb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d3dd97ad6b73068f9718c1d9a68adb8">&#9670;&nbsp;</a></span>EnvCheck() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool katana::EnvCheck </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>varName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>retVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if Enviroment variable is set, and extract its value into 'retVal' parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varName</td><td>name of the variable </td></tr>
    <tr><td class="paramname">retVal</td><td>lvalue to store the value of environment variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if environment variable set, false otherwise </dd></dl>

</div>
</div>
<a id="a2562dde224ecf03d557e61f0e43b45f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2562dde224ecf03d557e61f0e43b45f7">&#9670;&nbsp;</a></span>EnvCheck() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool katana::EnvCheck </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>varName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abcc7595978b215ac8411ffac375155f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc7595978b215ac8411ffac375155f0">&#9670;&nbsp;</a></span>EnvCheck() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool katana::EnvCheck </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>varName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>retVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0c5585e1bde1a577cf49eace85a256a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c5585e1bde1a577cf49eace85a256a">&#9670;&nbsp;</a></span>find_trait() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Tuple &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t katana::find_trait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c11c7e97215b2746292a3df68e88c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c11c7e97215b2746292a3df68e88c9f">&#9670;&nbsp;</a></span>find_trait() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Tuple , size_t Int, size_t... Ints&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t katana::find_trait </td>
          <td>(</td>
          <td class="paramtype">std::index_sequence&lt; Int, Ints... &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns index of first matching trait in Tuple. </p>
<p>This function is not well-defined if there is no matching trait. </p>

</div>
</div>
<a id="a3c6ccf7561be4d365565f6a92f099a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c6ccf7561be4d365565f6a92f099a67">&#9670;&nbsp;</a></span>FindEdgeSortedByDest() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KATANA_EXPORT GraphTy::edge_iterator katana::FindEdgeSortedByDest </td>
          <td>(</td>
          <td class="paramtype">const GraphTy &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="triangle__count_8cpp.html#abbf75957bb25c1104c933baf133ac20b">GraphTy::Node</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="triangle__count_8cpp.html#abbf75957bb25c1104c933baf133ac20b">GraphTy::Node</a>&#160;</td>
          <td class="paramname"><em>node_to_find</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a node in the sorted edgelist of some other node using binary search. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>graph to search in the topology of </td></tr>
    <tr><td class="paramname">node</td><td>node to find in the edgelist of </td></tr>
    <tr><td class="paramname">node_to_find</td><td>node id of the node to find in the edgelist of "node" </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the edge with id "node_to_find" if present else return "end" iterator </dd></dl>

</div>
</div>
<a id="a35441d15d64a1c339c2e384e7304439d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35441d15d64a1c339c2e384e7304439d">&#9670;&nbsp;</a></span>FindEdgeSortedByDest() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structkatana_1_1GraphTopology.html#ae1eb7d9b4835715f0133d6ef61d67397">katana::GraphTopology::Edge</a> katana::FindEdgeSortedByDest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkatana_1_1GraphTopology.html#acde93f565f18bcd70e5afcb0e0266317">GraphTopology::Node</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkatana_1_1GraphTopology.html#acde93f565f18bcd70e5afcb0e0266317">GraphTopology::Node</a>&#160;</td>
          <td class="paramname"><em>node_to_find</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FindEdgeSortedByDest finds the "node_to_find" id in the sorted edgelist of the "node" using binary search. </p>
<p>This returns the matched edge index if 'node_to_find' is present in the edgelist of 'node' else edge end if 'node_to_find' is not found. </p>

</div>
</div>
<a id="a2eb855d38b5753d67def813f9a7edb81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb855d38b5753d67def813f9a7edb81">&#9670;&nbsp;</a></span>for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename FunctionTy , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::for_each </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionTy &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Galois unordered set iterator. </p>
<p>Operator should conform to <code>fn(item, UserContext&lt;T&gt;&amp;)</code> where item is a value from the iteration range and T is the type of item.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>an iterator range typically returned by <a class="el" href="namespacekatana.html#a664a7f49a65e22807577f6cc809a7827">katana::iterate</a> </td></tr>
    <tr><td class="paramname">fn</td><td>operator </td></tr>
    <tr><td class="paramname">args</td><td>optional arguments to loop, e.g., {</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structkatana_1_1loopname.html">loopname</a>}, {</dd>
<dd>
<a class="el" href="namespacekatana.html#a0a996c85bab3fdbf1afad32e8595db32">wl</a>} </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="lonestar_2tutorial_examples_2ConflictAwareTorus_8cpp-example.html#a12">lonestar/tutorial_examples/ConflictAwareTorus.cpp</a>, <a class="el" href="lonestar_2tutorial_examples_2GraphTraversalPushOperator_8cpp-example.html#a10">lonestar/tutorial_examples/GraphTraversalPushOperator.cpp</a>, and <a class="el" href="lonestar_2tutorial_examples_2SSSPPushSimple_8cpp-example.html#a13">lonestar/tutorial_examples/SSSPPushSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a07cdf1268c8feb6ae8c3a2ecd81e7a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07cdf1268c8feb6ae8c3a2ecd81e7a92">&#9670;&nbsp;</a></span>for_each_gen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeTy , typename FunctionTy , typename TupleTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::for_each_gen </td>
          <td>(</td>
          <td class="paramtype">const RangeTy &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionTy &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TupleTy &amp;&#160;</td>
          <td class="paramname"><em>tpl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize arguments to for_each. </p>

</div>
</div>
<a id="a7f1bb8b9db99383005c03685212ceeac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1bb8b9db99383005c03685212ceeac">&#9670;&nbsp;</a></span>for_each_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeTy , typename FunctionTy , typename ArgsTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::for_each_impl </td>
          <td>(</td>
          <td class="paramtype">const RangeTy &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionTy &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArgsTy &amp;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e366c6edef650208b3372cb9ddabb05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e366c6edef650208b3372cb9ddabb05">&#9670;&nbsp;</a></span>for_each_ordered() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter , typename Cmp , typename NhFunc , typename OpFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::for_each_ordered </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Cmp &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NhFunc &amp;&#160;</td>
          <td class="paramname"><em>nhFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OpFunc &amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>loopname</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Galois ordered set iterator for stable source algorithms. </p>
<p>Operator should conform to <code>fn(item, UserContext&lt;T&gt;&amp;)</code> where item is a value from the iteration range and T is the type of item. Comparison function should conform to <code>bool r = cmp(item1, item2)</code> where r is true if item1 is less than or equal to item2. Neighborhood function should conform to <code>nhFunc(item)</code> and should visit every element in the neighborhood of active element item.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>begining of range of initial items </td></tr>
    <tr><td class="paramname">e</td><td>end of range of initial items </td></tr>
    <tr><td class="paramname">cmp</td><td>comparison function </td></tr>
    <tr><td class="paramname">nhFunc</td><td>neighborhood function </td></tr>
    <tr><td class="paramname">fn</td><td>operator </td></tr>
    <tr><td class="paramname">loopname</td><td>string to identity loop in statistics output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad685991c897c0ec679acb4f752f5e203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad685991c897c0ec679acb4f752f5e203">&#9670;&nbsp;</a></span>for_each_ordered() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter , typename Cmp , typename NhFunc , typename OpFunc , typename StableTest &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::for_each_ordered </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Cmp &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NhFunc &amp;&#160;</td>
          <td class="paramname"><em>nhFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OpFunc &amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StableTest &amp;&#160;</td>
          <td class="paramname"><em>stabilityTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>loopname</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Galois ordered set iterator for unstable source algorithms. </p>
<p>Operator should conform to <code>fn(item, UserContext&lt;T&gt;&amp;)</code> where item is a value from the iteration range and T is the type of item. Comparison function should conform to <code>bool r = cmp(item1, item2)</code> where r is true if item1 is less than or equal to item2. Neighborhood function should conform to <code>nhFunc(item)</code> and should visit every element in the neighborhood of active element item. The stability test should conform to <code>bool r = stabilityTest(item)</code> where r is true if item is a stable source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>begining of range of initial items </td></tr>
    <tr><td class="paramname">e</td><td>end of range of initial items </td></tr>
    <tr><td class="paramname">cmp</td><td>comparison function </td></tr>
    <tr><td class="paramname">nhFunc</td><td>neighborhood function </td></tr>
    <tr><td class="paramname">fn</td><td>operator </td></tr>
    <tr><td class="paramname">stabilityTest</td><td>stability test </td></tr>
    <tr><td class="paramname">loopname</td><td>string to identity loop in statistics output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2407e5b93c52b1c6be5107580fb0fcba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2407e5b93c52b1c6be5107580fb0fcba">&#9670;&nbsp;</a></span>for_each_ordered_impl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter , typename Cmp , typename NhFunc , typename OpFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::for_each_ordered_impl </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] Iter&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] Iter&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const Cmp &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const NhFunc &amp;&#160;</td>
          <td class="paramname"><em>nhFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const OpFunc &amp;&#160;</td>
          <td class="paramname"><em>opFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const char *&#160;</td>
          <td class="paramname"><em>loopname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a088d4fa047c30338d94d9380ffe0cc9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a088d4fa047c30338d94d9380ffe0cc9a">&#9670;&nbsp;</a></span>for_each_ordered_impl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter , typename Cmp , typename NhFunc , typename OpFunc , typename StableTest &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::for_each_ordered_impl </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] Iter&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] Iter&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const Cmp &amp;&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const NhFunc &amp;&#160;</td>
          <td class="paramname"><em>nhFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const OpFunc &amp;&#160;</td>
          <td class="paramname"><em>opFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const StableTest &amp;&#160;</td>
          <td class="paramname"><em>stabilityTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] const char *&#160;</td>
          <td class="paramname"><em>loopname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52dd4ebbf1e2af362f49bd230c2ef11e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52dd4ebbf1e2af362f49bd230c2ef11e">&#9670;&nbsp;</a></span>for_each_ParaMeter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename F , typename ArgsTuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::for_each_ParaMeter </td>
          <td>(</td>
          <td class="paramtype">const R &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArgsTuple &amp;&#160;</td>
          <td class="paramname"><em>argsTuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>invoke <a class="el" href="classkatana_1_1ParaMeter.html">ParaMeter</a> tool to execute a for_each style loop </p>

</div>
</div>
<a id="afcb6c47e78ad4854b7c68c14c2abd1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb6c47e78ad4854b7c68c14c2abd1b4">&#9670;&nbsp;</a></span>freePages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void katana::freePages </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f43dc294f927fd963e5cc73ea7c6c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f43dc294f927fd963e5cc73ea7c6c8c">&#9670;&nbsp;</a></span>FromBase64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string katana::FromBase64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FromBase64 converts from base64 string into a binary encoded string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>base64 encoded input string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6602e81c46161e71a631d2c035c91f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6602e81c46161e71a631d2c035c91f6">&#9670;&nbsp;</a></span>gDebug()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::gDebug </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a debug string from a sequence of things; prints nothing if NDEBUG is defined. </p>

</div>
</div>
<a id="a8d8b891e19c866ef156a1cabcea8be9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8b891e19c866ef156a1cabcea8be9c">&#9670;&nbsp;</a></span>gDebugStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void katana::gDebugStr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a debug string (for easy parsing) </p>

</div>
</div>
<a id="a42b1ae9ac161220e35ed86fddb6e7463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42b1ae9ac161220e35ed86fddb6e7463">&#9670;&nbsp;</a></span>gError()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::gError </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints error message. </p>

</div>
</div>
<a id="a6f49903b7bc8262326131192fd549f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f49903b7bc8262326131192fd549f5c">&#9670;&nbsp;</a></span>gErrorStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void katana::gErrorStr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints an error string (for easy parsing) </p>

</div>
</div>
<a id="af40e673ccdd430fe34a4b21b9e3fcc2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40e673ccdd430fe34a4b21b9e3fcc2c">&#9670;&nbsp;</a></span>get_default_trait_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto katana::get_default_trait_value </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] S&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] T&#160;</td>
          <td class="paramname"><em>tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] D&#160;</td>
          <td class="paramname"><em>defaults</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a346a6db8ac880db765625f23f247cb69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a346a6db8ac880db765625f23f247cb69">&#9670;&nbsp;</a></span>get_default_trait_values() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t... Ints, typename S , typename T , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto katana::get_default_trait_values </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] std::index_sequence&lt; Ints... &gt;&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D&#160;</td>
          <td class="paramname"><em>defaults</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a55c2e6fc71d4a95b2a467e038d125e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55c2e6fc71d4a95b2a467e038d125e5e">&#9670;&nbsp;</a></span>get_default_trait_values() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto katana::get_default_trait_values </td>
          <td>(</td>
          <td class="paramtype">[[maybe_unused] ] std::index_sequence&lt;&gt;&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] S&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] T&#160;</td>
          <td class="paramname"><em>tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[[maybe_unused] ] D&#160;</td>
          <td class="paramname"><em>defaults</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a tuple that has an element from defaults[i] for every type from tags[i] missing in source. </p>

</div>
</div>
<a id="a6d6fbee45cf6d1024abbbf5daed05710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d6fbee45cf6d1024abbbf5daed05710">&#9670;&nbsp;</a></span>get_default_trait_values() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename T , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto katana::get_default_trait_values </td>
          <td>(</td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D&#160;</td>
          <td class="paramname"><em>defaults</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d27f1df6ceb0d7194a24a576f173de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d27f1df6ceb0d7194a24a576f173de5">&#9670;&nbsp;</a></span>get_trait_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Tuple &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto katana::get_trait_value </td>
          <td>(</td>
          <td class="paramtype">Tuple&#160;</td>
          <td class="paramname"><em>tpl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value associated with the given trait T in a tuple. </p>
<p>This function is not well-defined when there is not matching trait. </p>

</div>
</div>
<a id="ac69b69591077d0e9f33c0b2e8676d520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac69b69591077d0e9f33c0b2e8676d520">&#9670;&nbsp;</a></span>getActiveThreads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int katana::getActiveThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of threads in use. </p>

</div>
</div>
<a id="ab473e662b3aed5db12ebd185fca76f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab473e662b3aed5db12ebd185fca76f11">&#9670;&nbsp;</a></span>GetBarrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkatana_1_1Barrier.html">katana::Barrier</a> &amp; katana::GetBarrier </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>active_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to system barrier. </p>
<p>Have a pre-instantiated barrier available for use. This is initialized to the current activeThreads. This barrier is designed to be fast and should be used in the common case.</p>
<p>However, there is a race if the number of active threads is modified after using this barrier: some threads may still be in the barrier while the main thread reinitializes this barrier to the new number of active threads. If that may happen, use <a class="el" href="namespacekatana.html#a427f77208349841b073228fd4a28022d">CreateSimpleBarrier()</a> instead. </p>

</div>
</div>
<a id="ab62665c2b2ae9fd0cce7ad46108d457a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab62665c2b2ae9fd0cce7ad46108d457a">&#9670;&nbsp;</a></span>getCopyrightYear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KATANA_EXPORT int katana::getCopyrightYear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a42da4ba7bd9e2c242250b3b3d5084e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42da4ba7bd9e2c242250b3b3d5084e0f">&#9670;&nbsp;</a></span>GetEnv() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool katana::GetEnv </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the environment variable is set. </p>
<p>This function simply tests for the presence of an environment variable; in contrast, bool GetEnv(std::string, bool&amp;) checks if the value of the environment variable matches common truthy and falsey values. </p>

</div>
</div>
<a id="aa0d19de081830f433b00a68a22253435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d19de081830f433b00a68a22253435">&#9670;&nbsp;</a></span>GetEnv() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool katana::GetEnv </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if environment variable is set, and extract its value into ret_val parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">var_name</td><td>name of the variable </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ret</td><td>where to store the value of environment variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if environment variable set and value was successfully parsed; false otherwise </dd></dl>

</div>
</div>
<a id="ae6a9ebbaba1173f09d9c750a06c5bb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a9ebbaba1173f09d9c750a06c5bb84">&#9670;&nbsp;</a></span>GetEnv() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool katana::GetEnv </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7371a5df1bbcd499f9df884154738921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7371a5df1bbcd499f9df884154738921">&#9670;&nbsp;</a></span>GetEnv() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool katana::GetEnv </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9450422a244d140f5c709df54aaa79bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9450422a244d140f5c709df54aaa79bf">&#9670;&nbsp;</a></span>GetEnv() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool katana::GetEnv </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>ret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa186584ec0a41b2c810ce176fb56b30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa186584ec0a41b2c810ce176fb56b30c">&#9670;&nbsp;</a></span>GetGenerator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a90f4c6b4c41224bdb87892b16e067340">katana::RandGenerator</a> &amp; katana::GetGenerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a random number generator seeded with randomness from the platform. The generator is local to the calling thread so uses of it are thread safe. Useful for things like <code>std::uniform_int_distribution</code> </dd></dl>

</div>
</div>
<a id="a442d543c6af5016fde65ba7dcdfa45e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a442d543c6af5016fde65ba7dcdfa45e6">&#9670;&nbsp;</a></span>getHWTopo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structkatana_1_1HWTopoInfo.html">katana::HWTopoInfo</a> katana::getHWTopo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>getHWTopo determines the machine topology from the process information exposed in /proc and /dev filesystems. </p>

</div>
</div>
<a id="a5ffbd5bd8ef554916a893b0b95ce2cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ffbd5bd8ef554916a893b0b95ce2cf7">&#9670;&nbsp;</a></span>getPPSBackend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkatana_1_1PerBackend.html">katana::PerBackend</a> &amp; katana::getPPSBackend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa85a067a34f40d110114c041c079ab28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa85a067a34f40d110114c041c079ab28">&#9670;&nbsp;</a></span>getPTSBackend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkatana_1_1PerBackend.html">katana::PerBackend</a> &amp; katana::getPTSBackend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a11445d97956a8fdd3bb3bd33d0f96138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11445d97956a8fdd3bb3bd33d0f96138">&#9670;&nbsp;</a></span>getRevision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KATANA_EXPORT std::string katana::getRevision </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acdd775f6f963127a8d60f0480545c28b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd775f6f963127a8d60f0480545c28b">&#9670;&nbsp;</a></span>GetTerminationDetection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkatana_1_1TerminationDetection.html">katana::TerminationDetection</a> &amp; katana::GetTerminationDetection </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>active_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3b2b56d9557fc8ceefef836895765a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b2b56d9557fc8ceefef836895765a7">&#9670;&nbsp;</a></span>getThreadContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkatana_1_1SimpleRuntimeContext.html">katana::SimpleRuntimeContext</a> * katana::getThreadContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the current conflict detection class, may be null if not in parallel region </p>

</div>
</div>
<a id="a8e917129a0649c5fece62dca21858a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e917129a0649c5fece62dca21858a41">&#9670;&nbsp;</a></span>GetThreadPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkatana_1_1ThreadPool.html">katana::ThreadPool</a> &amp; katana::GetThreadPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a reference to system thread pool </p>

</div>
</div>
<a id="a6390ccfacfd1dda67e08badb713b497e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6390ccfacfd1dda67e08badb713b497e">&#9670;&nbsp;</a></span>getVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KATANA_EXPORT std::string katana::getVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a01a1722b39f9f8b6616a3ef0f385aec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a1722b39f9f8b6616a3ef0f385aec4">&#9670;&nbsp;</a></span>getVersionMajor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KATANA_EXPORT int katana::getVersionMajor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a191cf944185f45cec69506e336f407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a191cf944185f45cec69506e336f407">&#9670;&nbsp;</a></span>getVersionMinor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KATANA_EXPORT int katana::getVersionMinor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e6513606838f0d8d3b4a6aaf14e6965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6513606838f0d8d3b4a6aaf14e6965">&#9670;&nbsp;</a></span>getVersionPatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KATANA_EXPORT int katana::getVersionPatch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aff847e10bab466e217c9fe4c0020ec00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff847e10bab466e217c9fe4c0020ec00">&#9670;&nbsp;</a></span>gFlush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void katana::gFlush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f23e8a11feacf0fd0703a147a832d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f23e8a11feacf0fd0703a147a832d42">&#9670;&nbsp;</a></span>gInfo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::gInfo </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints an info string from a sequence of things. </p>

</div>
</div>
<a id="af34b94357c92675be0e31ad0fb116ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34b94357c92675be0e31ad0fb116ae3">&#9670;&nbsp;</a></span>gInfoStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void katana::gInfoStr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints an info string (for easy parsing) </p>

</div>
</div>
<a id="a2a037b52985c7525482de34e3b824cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a037b52985c7525482de34e3b824cb3">&#9670;&nbsp;</a></span>gPrint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::gPrint </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a sequence of things. </p>

</div>
</div>
<a id="a8448775f95d8f5f84f67fc3543c986aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8448775f95d8f5f84f67fc3543c986aa">&#9670;&nbsp;</a></span>gPrintStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void katana::gPrintStr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a string. </p>

</div>
</div>
<a id="a48a8080a1591799040110afb3ea8e126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a8080a1591799040110afb3ea8e126">&#9670;&nbsp;</a></span>gWarn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::gWarn </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a warning string from a sequence of things. </p>

</div>
</div>
<a id="afef56b3b4315cd5dc1fee0f54cf1ab1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef56b3b4315cd5dc1fee0f54cf1ab1c">&#9670;&nbsp;</a></span>gWarnStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void katana::gWarnStr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a warning string (for easy parsing) </p>

</div>
</div>
<a id="aa62f925c87175e4b46929506ee9825c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62f925c87175e4b46929506ee9825c3">&#9670;&nbsp;</a></span>has_trait() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Tuple &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool katana::has_trait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d109a8f65e5c6a70bc84a58b3700767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d109a8f65e5c6a70bc84a58b3700767">&#9670;&nbsp;</a></span>has_trait() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool katana::has_trait </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Ts... &gt; *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the tuple type contains the given trait T. </p>

</div>
</div>
<a id="a6887981974026f0de7127ee8bdd290ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6887981974026f0de7127ee8bdd290ca">&#9670;&nbsp;</a></span>has_with_iterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto katana::has_with_iterator </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a442cf800869fdedc926894feecc5df21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a442cf800869fdedc926894feecc5df21">&#9670;&nbsp;</a></span>has_with_iterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename WLTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto katana::has_with_iterator </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; decltype(
    std::declval&lt;typename WLTy::template with_iterator&lt;int*&gt;::type&gt;(), bool()) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af4ef08536637ab910e7c23b078da24a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ef08536637ab910e7c23b078da24a1">&#9670;&nbsp;</a></span>HasPrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool katana::HasPrefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad08c0136825589df6d59573f93953365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08c0136825589df6d59573f93953365">&#9670;&nbsp;</a></span>HasSuffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool katana::HasSuffix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa23967f8e9c0a95985bfa96c4e7ed0d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa23967f8e9c0a95985bfa96c4e7ed0d6">&#9670;&nbsp;</a></span>HttpDelete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; void &gt; katana::HttpDelete </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; char &gt; *&#160;</td>
          <td class="paramname"><em>response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an HTTP delete request on url and send the contents of buffer. </p>

</div>
</div>
<a id="a30b21cb3758ab377eecd5f94b48a5660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b21cb3758ab377eecd5f94b48a5660">&#9670;&nbsp;</a></span>HttpDeleteJson()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt;T&gt; katana::HttpDeleteJson </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a280a4edefb3f7b59e15e3214a18865bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a280a4edefb3f7b59e15e3214a18865bc">&#9670;&nbsp;</a></span>HttpGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; void &gt; katana::HttpGet </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; char &gt; *&#160;</td>
          <td class="paramname"><em>response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an HTTP get request on url and fill buffer with the result on success. </p>

</div>
</div>
<a id="a69c4929a4c8a8480fdd84ace6488bfca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c4929a4c8a8480fdd84ace6488bfca">&#9670;&nbsp;</a></span>HttpGetJson()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt;T&gt; katana::HttpGetJson </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ead6bd15f422d6a58595d316571a77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ead6bd15f422d6a58595d316571a77e">&#9670;&nbsp;</a></span>HttpInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; void &gt; katana::HttpInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e73a91a3ad818e7cba63406ec2475b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e73a91a3ad818e7cba63406ec2475b6">&#9670;&nbsp;</a></span>HttpOpJson()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Callable , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt;T&gt; katana::HttpOpJson </td>
          <td>(</td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc4601a35af785e478fe246afe04d7e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4601a35af785e478fe246afe04d7e7">&#9670;&nbsp;</a></span>HttpPost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; void &gt; katana::HttpPost </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; char &gt; *&#160;</td>
          <td class="paramname"><em>response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an HTTP post request on url and send the contents of buffer. </p>

</div>
</div>
<a id="a73c2cd816a0d547ab06f2f0c85f2faed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73c2cd816a0d547ab06f2f0c85f2faed">&#9670;&nbsp;</a></span>HttpPostJson()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt;U&gt; katana::HttpPostJson </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b8c9769dcae140ac4fe4488e4cb50da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8c9769dcae140ac4fe4488e4cb50da">&#9670;&nbsp;</a></span>HttpPut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; void &gt; katana::HttpPut </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; char &gt; *&#160;</td>
          <td class="paramname"><em>response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an HTTP put request on url and send the contents of buffer. </p>

</div>
</div>
<a id="abcca45df3883ac25e5a4cf3e199bb784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcca45df3883ac25e5a4cf3e199bb784">&#9670;&nbsp;</a></span>HttpPutJson()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt;U&gt; katana::HttpPutJson </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af3fb96a271f2783315e394cd576d9a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3fb96a271f2783315e394cd576d9a82">&#9670;&nbsp;</a></span>ImportToArrow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; std::shared_ptr&lt; arrow::ChunkedArray &gt; &gt; katana::ImportToArrow </td>
          <td>(</td>
          <td class="paramtype">arrow::Type::type&#160;</td>
          <td class="paramname"><em>arrow_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structkatana_1_1ImportData.html">ImportData</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>import_src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52e3be3fa1ed07518e2d2bd2cb3c2e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e3be3fa1ed07518e2d2bd2cb3c2e55">&#9670;&nbsp;</a></span>InitBacktrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KATANA_EXPORT void katana::InitBacktrace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c87e9d7ccc6d22edbd8b77b5bd5c1bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c87e9d7ccc6d22edbd8b77b5bd5c1bb">&#9670;&nbsp;</a></span>initPTS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void katana::initPTS </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd76da271128e81797dfb506203d1414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd76da271128e81797dfb506203d1414">&#9670;&nbsp;</a></span>IsPowerOf2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::enable_if_t&lt; std::is_integral&lt; T &gt;::value, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool katana::IsPowerOf2 </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aea87f3bc834744bff599bae71f76d43a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea87f3bc834744bff599bae71f76d43a">&#9670;&nbsp;</a></span>iterate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if_t&lt; std::is_integral_v&lt; T &gt;&gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto katana::iterate </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace46c029ce2b00c7618c3c1b1166b5c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace46c029ce2b00c7618c3c1b1166b5c6">&#9670;&nbsp;</a></span>iterate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto katana::iterate </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>init_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a664a7f49a65e22807577f6cc809a7827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a664a7f49a65e22807577f6cc809a7827">&#9670;&nbsp;</a></span>iterate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if_t&lt; has_local_iterator_v&lt; T &gt;&gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto katana::iterate </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate returns a specialized range object for various container-like objects: </p>
<ul>
<li>A standard range: iterate(begin, end)</li>
<li>A standard container: iterator(container)</li>
<li>A container with local iterators: iterator(container)</li>
<li>An initializer list: iterator({1, 2})</li>
<li>A numeric range: iterator(1, 2) </li>
</ul>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="lonestar_2tutorial_examples_2ConflictAwareTorus_8cpp-example.html#a10">lonestar/tutorial_examples/ConflictAwareTorus.cpp</a>, <a class="el" href="lonestar_2tutorial_examples_2CountLevels_8cpp-example.html#a4">lonestar/tutorial_examples/CountLevels.cpp</a>, <a class="el" href="lonestar_2tutorial_examples_2GraphTraversalPullOperator_8cpp-example.html#a10">lonestar/tutorial_examples/GraphTraversalPullOperator.cpp</a>, <a class="el" href="lonestar_2tutorial_examples_2GraphTraversalPushOperator_8cpp-example.html#a3">lonestar/tutorial_examples/GraphTraversalPushOperator.cpp</a>, and <a class="el" href="lonestar_2tutorial_examples_2SSSPPushSimple_8cpp-example.html#a6">lonestar/tutorial_examples/SSSPPushSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab1ee151d7c512df2f1d51cb7b3f7595c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ee151d7c512df2f1d51cb7b3f7595c">&#9670;&nbsp;</a></span>Join() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string katana::Join </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>items</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join returns a string that is the concatenation of every object in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">items</td><td>all separated by an instance of</td></tr>
    <tr><td class="paramname">sep</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a085cd46fee778f1cc6495ff15312c6bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a085cd46fee778f1cc6495ff15312c6bd">&#9670;&nbsp;</a></span>Join() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string katana::Join </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>items</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join returns a string that is the concatenation of every object in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">items</td><td>all separated by an instance of</td></tr>
    <tr><td class="paramname">sep</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24cfe906924eac4d975019b6dee49bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24cfe906924eac4d975019b6dee49bed">&#9670;&nbsp;</a></span>Join() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string katana::Join </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join returns a string that is the concatenation of every object from. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>to</td></tr>
    <tr><td class="paramname">end</td><td>all separated by an instance of</td></tr>
    <tr><td class="paramname">sep</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a619f85a58ea717e4cf3dfd0d06fa7ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619f85a58ea717e4cf3dfd0d06fa7ace">&#9670;&nbsp;</a></span>JsonDump() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; std::string &gt; katana::JsonDump </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="RDGPartHeader_8cpp.html#ab701e3ac61a85b337ec5c1abaad6742d">nlohmann::json</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump to string, but catch errors. </p>

</div>
</div>
<a id="a1b3c958703c41e46a1b8aa6639323a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3c958703c41e46a1b8aa6639323a50">&#9670;&nbsp;</a></span>JsonDump() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt;std::string&gt; katana::JsonDump </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="add51b801fe882b401808832002207da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add51b801fe882b401808832002207da0">&#9670;&nbsp;</a></span>JsonParse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt;T&gt; katana::JsonParse </td>
          <td>(</td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>call parse and turn exceptions into the results we know and love </p>

</div>
</div>
<a id="aaa9acf0f689aaf40bae0f5dae5499a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa9acf0f689aaf40bae0f5dae5499a1d">&#9670;&nbsp;</a></span>JsonParse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt;void&gt; katana::JsonParse </td>
          <td>(</td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9b1cc97c338a2607fab2d4c736dc4f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9b1cc97c338a2607fab2d4c736dc4f0">&#9670;&nbsp;</a></span>largeMallocBlocked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a35860f323cd4a2faf392c984e77ba618">LAptr</a> katana::largeMallocBlocked </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a967c41866a283f207458f1e2e4132d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967c41866a283f207458f1e2e4132d84">&#9670;&nbsp;</a></span>largeMallocFloating()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a35860f323cd4a2faf392c984e77ba618">LAptr</a> katana::largeMallocFloating </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4cd7ceb017df5d99dd3625300788bf36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd7ceb017df5d99dd3625300788bf36">&#9670;&nbsp;</a></span>largeMallocInterleaved()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a35860f323cd4a2faf392c984e77ba618">LAptr</a> katana::largeMallocInterleaved </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numThreads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8c14eb15c7de9cf907f6efe3318370c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c14eb15c7de9cf907f6efe3318370c">&#9670;&nbsp;</a></span>largeMallocLocal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a35860f323cd4a2faf392c984e77ba618">LAptr</a> katana::largeMallocLocal </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae72e3908a3e1dfe17e4c7f3d2b0fd70e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72e3908a3e1dfe17e4c7f3d2b0fd70e">&#9670;&nbsp;</a></span>largeMallocSpecified()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeArrayTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KATANA_EXPORT <a class="el" href="namespacekatana.html#a35860f323cd4a2faf392c984e77ba618">LAptr</a> katana::largeMallocSpecified </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RangeArrayTy &amp;&#160;</td>
          <td class="paramname"><em>threadRanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elementSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates pages for some specified number of bytes, then does NUMA page faulting based on a specified distribution of elements among threads. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RangeArrayTy</td><td>Type of threadRanges array: should either be uint32_t* or uint64_t* </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>Number of bytes to allocate </td></tr>
    <tr><td class="paramname">numThreads</td><td>Number of threads to page in regions for </td></tr>
    <tr><td class="paramname">threadRanges</td><td>Array specifying distribution of elements among threads </td></tr>
    <tr><td class="paramname">elementSize</td><td>Size of a data element that will be stored in the allocated memory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated memory along with a freer object </dd></dl>

</div>
</div>
<a id="abf4d646903f04da1efe3780d64ea79c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4d646903f04da1efe3780d64ea79c3">&#9670;&nbsp;</a></span>Log()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::Log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacekatana.html#ab1c012a5bda211a6470b9e8424c14e7b">LogLevel</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fmt_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Log at a specific LogLevel. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>string-like type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>level to log at </td></tr>
    <tr><td class="paramname">fmt_string</td><td>a C++20-style fmt string (e.g., "hello {}") </td></tr>
    <tr><td class="paramname">args</td><td>arguments to fmt interpolation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac28b7084dd2ed48c926855bccf483513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28b7084dd2ed48c926855bccf483513">&#9670;&nbsp;</a></span>LogLine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::LogLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacekatana.html#ab1c012a5bda211a6470b9e8424c14e7b">LogLevel</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fmt_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Log at a specific LogLevel with source code information. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>string-like type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>level to log at </td></tr>
    <tr><td class="paramname">file_name</td><td>file name </td></tr>
    <tr><td class="paramname">line_no</td><td>line number </td></tr>
    <tr><td class="paramname">fmt_string</td><td>a C++20-style fmt string (e.g., "hello {}") </td></tr>
    <tr><td class="paramname">args</td><td>arguments to fmt interpolation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab35ecb137fc1cccafad5c6f5c3ef6c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35ecb137fc1cccafad5c6f5c3ef6c98">&#9670;&nbsp;</a></span>make_error_code() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::error_code katana::make_error_code </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacekatana.html#a9d227598262d7bcbd17e8270fdc25d56">ErrorCode</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>make_error_code converts ErrorCode into a standard error code. </p>
<p>It is an STL and outcome extension point and will be found with ADL if necessary. </p>

</div>
</div>
<a id="a59b7678f7dda967accf56f3f14e4fca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b7678f7dda967accf56f3f14e4fca3">&#9670;&nbsp;</a></span>make_error_code() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::error_code katana::make_error_code </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1ErrorInfo.html">ErrorInfo</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>make_error_code converts <a class="el" href="classkatana_1_1ErrorInfo.html" title="An ErrorInfo contains additional context about an error in addition to an error code.">ErrorInfo</a> into a standard error code. </p>
<p>It is an STL and boost::outcome extension point and will be found with ADL if necessary. </p>

</div>
</div>
<a id="a30c4f58f277633fd887a386c2f4541dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c4f58f277633fd887a386c2f4541dd">&#9670;&nbsp;</a></span>make_no_deref_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structkatana_1_1NoDerefIterator.html">NoDerefIterator</a>&lt;Iterator&gt; katana::make_no_deref_iterator </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function to create <a class="el" href="structkatana_1_1NoDerefIterator.html">NoDerefIterator</a>. </p>

</div>
</div>
<a id="a87b1dc8e27f3835d081ae1297869dd80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b1dc8e27f3835d081ae1297869dd80">&#9670;&nbsp;</a></span>make_reducible()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MergeFn , typename IdFn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto katana::make_reducible </td>
          <td>(</td>
          <td class="paramtype">const MergeFn &amp;&#160;</td>
          <td class="paramname"><em>mergeFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IdFn &amp;&#160;</td>
          <td class="paramname"><em>idFn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make_reducible creates a <a class="el" href="classkatana_1_1Reducible.html" title="A Reducible stores per-thread values of a variable of type T and merges multiple values into one.">Reducible</a> from a merge function and identity function. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="lonestar_2tutorial_examples_2CountLevels_8cpp-example.html#a2">lonestar/tutorial_examples/CountLevels.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a7fc06e2def7de4be0704465396b7600d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc06e2def7de4be0704465396b7600d">&#9670;&nbsp;</a></span>make_trait_with_args()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename... &gt; class TT, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto katana::make_trait_with_args </td>
          <td>(</td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> -&gt; TT&lt;Args...&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to simplify creating traits that take unnamed functions (i.e., lambdas). </p>

</div>
</div>
<a id="a9898d9cb937717b094ac83e2b7946709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9898d9cb937717b094ac83e2b7946709">&#9670;&nbsp;</a></span>make_two_level_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CategoryOrTraversal  = std::forward_iterator_tag, class OuterIter , class InnerIter  = decltype(std::declval&lt;OuterIter&gt;()-&gt;begin()), class InnerBeginFn  = GetBegin, class InnerEndFn  = GetEnd, class Iter  = TwoLevelIterator&lt;        OuterIter, InnerIter, CategoryOrTraversal, InnerBeginFn, InnerEndFn&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;Iter, Iter&gt; katana::make_two_level_iterator </td>
          <td>(</td>
          <td class="paramtype">OuterIter&#160;</td>
          <td class="paramname"><em>outer_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OuterIter&#160;</td>
          <td class="paramname"><em>outer_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0c17b5ead43129af22d05193c8cb662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c17b5ead43129af22d05193c8cb662">&#9670;&nbsp;</a></span>makeIterRange() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto katana::makeIterRange </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9aae0060c80a59049d4b9d1f357c5e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aae0060c80a59049d4b9d1f357c5e35">&#9670;&nbsp;</a></span>makeIterRange() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto katana::makeIterRange </td>
          <td>(</td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>beg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const I &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0ad5bb9139add3b34278f67fbfcd522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0ad5bb9139add3b34278f67fbfcd522">&#9670;&nbsp;</a></span>MakeLocalRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkatana_1_1LocalRange.html">LocalRange</a>&lt;T&gt; katana::MakeLocalRange </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7835863382e6e72e5b8b0d8c52f107ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7835863382e6e72e5b8b0d8c52f107ac">&#9670;&nbsp;</a></span>MakeLocalTwoLevelRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkatana_1_1LocalTwoLevelRange.html">LocalTwoLevelRange</a>&lt;T&gt; katana::MakeLocalTwoLevelRange </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac248b1f65105a43af96d136b25bbd6c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac248b1f65105a43af96d136b25bbd6c2">&#9670;&nbsp;</a></span>MakeSpecificRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IterTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkatana_1_1SpecificRange.html">SpecificRange</a>&lt;IterTy&gt; katana::MakeSpecificRange </td>
          <td>(</td>
          <td class="paramtype">IterTy&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterTy&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>thread_ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classkatana_1_1SpecificRange.html" title="SpecificRange is a range type where a threads range is specified by an int array that gives where eac...">SpecificRange</a> object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IterTy</td><td>The iterator type used by the range object </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The global beginning of the range </td></tr>
    <tr><td class="paramname">end</td><td>The global end of the range </td></tr>
    <tr><td class="paramname">thread_ranges</td><td>An array of iterators that specifies where each thread's range begins </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classkatana_1_1SpecificRange.html" title="SpecificRange is a range type where a threads range is specified by an int array that gives where eac...">SpecificRange</a> object </dd></dl>

</div>
</div>
<a id="a15d1f557e45a33c052ee5d4a9f523867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d1f557e45a33c052ee5d4a9f523867">&#9670;&nbsp;</a></span>MakeStandardRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IterTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkatana_1_1StandardRange.html">StandardRange</a>&lt;IterTy&gt; katana::MakeStandardRange </td>
          <td>(</td>
          <td class="paramtype">IterTy&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterTy&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3cace38383289e96c798eae2910607ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cace38383289e96c798eae2910607ba">&#9670;&nbsp;</a></span>makeSymmetric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EdgeTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::makeSymmetric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1FileGraph.html">FileGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>in_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkatana_1_1FileGraph.html">FileGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds reverse edges to a graph. </p>
<p>Reverse edges have edge data copied from the original edge. The new graph is placed in the out parameter. The previous out is destroyed. </p>

</div>
</div>
<a id="a220afb102c04987e7608e953d33ce26e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220afb102c04987e7608e953d33ce26e">&#9670;&nbsp;</a></span>MarshalVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt;std::shared_ptr&lt;arrow::ChunkedArray&gt; &gt; katana::MarshalVector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af18f17810376e19b9418695108f83050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af18f17810376e19b9418695108f83050">&#9670;&nbsp;</a></span>MarshalVectorOfVectors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt;std::vector&lt;std::shared_ptr&lt;arrow::ChunkedArray&gt; &gt; &gt; katana::MarshalVectorOfVectors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5038f4364fb63fb47b2f5b984e716f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5038f4364fb63fb47b2f5b984e716f0">&#9670;&nbsp;</a></span>must_be_OpaqueID_subclass()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename _Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Value katana::must_be_OpaqueID_subclass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structkatana_1_1OpaqueID.html">OpaqueID</a>&lt; T, _Value &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b63f9504fe9b550bc5bd8812b52e3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b63f9504fe9b550bc5bd8812b52e3ac">&#9670;&nbsp;</a></span>Now()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#ad53d5a0919afb768f3ad0304893c5925">TimePoint</a> katana::Now </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8eec8a2c55e0a1fd6a706cbdb1123a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eec8a2c55e0a1fd6a706cbdb1123a6d">&#9670;&nbsp;</a></span>NullChunkedArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; arrow::ChunkedArray &gt; katana::NullChunkedArray </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; arrow::DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a ChunkeArray of Nulls of the given type and length. </p>

</div>
</div>
<a id="a618f26ad811ecbf556c183d92da75826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618f26ad811ecbf556c183d92da75826">&#9670;&nbsp;</a></span>numPagePoolAllocForThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int katana::numPagePoolAllocForThread </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>tid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns total large pages allocated for thread by Galois memory management subsystem. </p>

</div>
</div>
<a id="a73caf8a4d244b5fcea67a4a39d6e4694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73caf8a4d244b5fcea67a4a39d6e4694">&#9670;&nbsp;</a></span>numPagePoolAllocTotal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int katana::numPagePoolAllocTotal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns total large pages allocated by Galois memory management subsystem. </p>

</div>
</div>
<a id="ae59063ef456c98bb4731b6ec5d9655d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae59063ef456c98bb4731b6ec5d9655d9">&#9670;&nbsp;</a></span>on_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionTy , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::on_each </td>
          <td>(</td>
          <td class="paramtype">FunctionTy &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low-level parallel loop. </p>
<p>Operator is applied for each running thread. Operator should confirm to <code>fn(tid, numThreads)</code> where tid is the id of the current thread and numThreads is the total number of running threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>operator, which is never copied </td></tr>
    <tr><td class="paramname">args</td><td>optional arguments to loop </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac585b92d00974dfa0ed6125b0de1edd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac585b92d00974dfa0ed6125b0de1edd3">&#9670;&nbsp;</a></span>on_each_gen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionTy , typename TupleTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void katana::on_each_gen </td>
          <td>(</td>
          <td class="paramtype">FunctionTy &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TupleTy &amp;&#160;</td>
          <td class="paramname"><em>tpl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c6dd9ff31aea17f6231d2153e85816f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6dd9ff31aea17f6231d2153e85816f">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool katana::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkatana_1_1ErrorInfo.html">ErrorInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classkatana_1_1ErrorInfo.html">ErrorInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b6c952f5532ec6da9758747964fcb40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6c952f5532ec6da9758747964fcb40">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare , typename _Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool katana::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkatana_1_1flat__map.html">flat_map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classkatana_1_1flat__map.html">flat_map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Based on operator==. </p>

</div>
</div>
<a id="a861fa1fe781ba86de34d4f72437db9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861fa1fe781ba86de34d4f72437db9cb">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool katana::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkatana_1_1Uri.html">Uri</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classkatana_1_1Uri.html">Uri</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a47ec431ab657dd2dae035358cb521f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ec431ab657dd2dae035358cb521f93">&#9670;&nbsp;</a></span>operator&amp;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246">MethodFlag</a> katana::operator&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246">MethodFlag</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246">MethodFlag</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise &amp; for method flags. </p>

</div>
</div>
<a id="a2afa875499adf7ad280de4db979e0d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2afa875499adf7ad280de4db979e0d9c">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare , typename _Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool katana::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkatana_1_1flat__map.html">flat_map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classkatana_1_1flat__map.html">flat_map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a289d560dd3972a6de16cf3012aad4abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a289d560dd3972a6de16cf3012aad4abc">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare , typename _Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool katana::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkatana_1_1flat__map.html">flat_map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classkatana_1_1flat__map.html">flat_map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Based on operator&lt;. </p>

</div>
</div>
<a id="a2f1bf0289ae52b019889d22916109855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1bf0289ae52b019889d22916109855">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool katana::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkatana_1_1ErrorInfo.html">ErrorInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classkatana_1_1ErrorInfo.html">ErrorInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2fcec56089b5a660692cb46edf8dc752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fcec56089b5a660692cb46edf8dc752">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare , typename _Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool katana::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkatana_1_1flat__map.html">flat_map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classkatana_1_1flat__map.html">flat_map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb7cf0a8d194315b87b6e313404b131d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7cf0a8d194315b87b6e313404b131d">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool katana::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkatana_1_1Uri.html">Uri</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classkatana_1_1Uri.html">Uri</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e02e7ae665499588153f5e5d7d2b058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e02e7ae665499588153f5e5d7d2b058">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare , typename _Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool katana::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkatana_1_1flat__map.html">flat_map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classkatana_1_1flat__map.html">flat_map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Based on operator&lt;. </p>

</div>
</div>
<a id="a27cce37579812e3a0630215786153a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27cce37579812e3a0630215786153a35">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key , typename _Tp , typename _Compare , typename _Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool katana::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkatana_1_1flat__map.html">flat_map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classkatana_1_1flat__map.html">flat_map</a>&lt; _Key, _Tp, _Compare, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Based on operator&lt;. </p>

</div>
</div>
<a id="a75f097b8ee9ae3d62df8df4b421e58da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f097b8ee9ae3d62df8df4b421e58da">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246">MethodFlag</a> katana::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246">MethodFlag</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246">MethodFlag</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitwise | for method flags. </p>

</div>
</div>
<a id="a0a15d8fd6f923c1ec191b44afc93c1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a15d8fd6f923c1ec191b44afc93c1c7">&#9670;&nbsp;</a></span>pageIn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KATANA_EXPORT void katana::pageIn </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forces the given block to be paged into physical memory. </p>

</div>
</div>
<a id="a81c8744364d257c6a5b8fac5bb264d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81c8744364d257c6a5b8fac5bb264d1b">&#9670;&nbsp;</a></span>pagePoolAlloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * katana::pagePoolAlloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low level page pool (individual pages, use largeMalloc for large blocks) </p>

</div>
</div>
<a id="abe2d13303dc5a2b096784d47f173baca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe2d13303dc5a2b096784d47f173baca">&#9670;&nbsp;</a></span>pagePoolEnsurePreallocated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void katana::pagePoolEnsurePreallocated </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b1d0d58b17cf84d1242bf128e390c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1d0d58b17cf84d1242bf128e390c43">&#9670;&nbsp;</a></span>pagePoolFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void katana::pagePoolFree </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa938af62a145a49f37131b59ad9fe5e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa938af62a145a49f37131b59ad9fe5e7">&#9670;&nbsp;</a></span>pagePoolPreAlloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void katana::pagePoolPreAlloc </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3836d9769215bd4dbf66eec37e1f646d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3836d9769215bd4dbf66eec37e1f646d">&#9670;&nbsp;</a></span>parseCPUList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; katana::parseCPUList </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parseCPUList parses cpuset information in "List format" as described in cpuset(7) and available under /proc/self/status </p>

</div>
</div>
<a id="ad0c51e3da13cd969a7739672414ff782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c51e3da13cd969a7739672414ff782">&#9670;&nbsp;</a></span>permute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EdgeTy , typename PTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::permute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1FileGraph.html">FileGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>in_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PTy &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkatana_1_1FileGraph.html">FileGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permutes a graph. </p>
<p>Permutation array, P, conforms to: P[i] = j where i is a node index from the original graph and j is a node index in the permuted graph. New, permuted graph is placed in the out parameter. The previous out is destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_graph</td><td>original graph </td></tr>
    <tr><td class="paramname">p</td><td>permutation array </td></tr>
    <tr><td class="paramname">out</td><td>permuted graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7bdbb926af9a6d1a39e18d323a269386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bdbb926af9a6d1a39e18d323a269386">&#9670;&nbsp;</a></span>Prealloc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void katana::Prealloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pages</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Preallocates memory on each thread. </p>
<p>The allocation size is given in total pages which will be divided amongst the threads. </p>

</div>
</div>
<a id="adf0246abc6c31e1172dc6533bcade08a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf0246abc6c31e1172dc6533bcade08a">&#9670;&nbsp;</a></span>Prealloc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void katana::Prealloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pagesPerThread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Preallocates memory on each thread. </p>
<p>The allocation size is given in pages per thread and total bytes which will be divided amongst the threads. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="lonestar_2tutorial_examples_2CountLevels_8cpp-example.html#a10">lonestar/tutorial_examples/CountLevels.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a76d12469fda4759af6f637e27dfa9ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d12469fda4759af6f637e27dfa9ebe">&#9670;&nbsp;</a></span>PrintBacktrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KATANA_EXPORT void katana::PrintBacktrace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a37cf1446ca54fca399dfdfdbab23bf27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37cf1446ca54fca399dfdfdbab23bf27">&#9670;&nbsp;</a></span>PrintStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void katana::PrintStats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints statistics out to standard out or to the file indicated by SetStatFile. </p>

</div>
</div>
<a id="abd798540cfe7c5d97e689d9502c1c639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd798540cfe7c5d97e689d9502c1c639">&#9670;&nbsp;</a></span>profilePapi()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::profilePapi </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1acae7c4c5982885cb541db7faa5f22f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1acae7c4c5982885cb541db7faa5f22f">&#9670;&nbsp;</a></span>profileVtune()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::profileVtune </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aef431c2bb0ee48ad65341dfd26ce0c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef431c2bb0ee48ad65341dfd26ce0c99">&#9670;&nbsp;</a></span>RandomAlphanumericString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string katana::RandomAlphanumericString </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacekatana.html#a90f4c6b4c41224bdb87892b16e067340">RandGenerator</a> *&#160;</td>
          <td class="paramname"><em>gen</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a random alphanumeric string of length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>using </td></tr>
    <tr><td class="paramname">gen</td><td>if provided. If no generator is specified, use the output of GetGenerator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acceb3be91f6608eb0b91434f86f883ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acceb3be91f6608eb0b91434f86f883ce">&#9670;&nbsp;</a></span>readGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphTy , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::readGraph </td>
          <td>(</td>
          <td class="paramtype">GraphTy &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates and constructs a graph from a file. </p>
<p>Tries to balance memory evenly across system. Cannot be called during parallel execution. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="lonestar_2tutorial_examples_2CountLevels_8cpp-example.html#a8">lonestar/tutorial_examples/CountLevels.cpp</a>, <a class="el" href="lonestar_2tutorial_examples_2GraphTraversalPullOperator_8cpp-example.html#a3">lonestar/tutorial_examples/GraphTraversalPullOperator.cpp</a>, <a class="el" href="lonestar_2tutorial_examples_2GraphTraversalPushOperator_8cpp-example.html#a7">lonestar/tutorial_examples/GraphTraversalPushOperator.cpp</a>, <a class="el" href="lonestar_2tutorial_examples_2GraphTraversalSerial_8cpp-example.html#a3">lonestar/tutorial_examples/GraphTraversalSerial.cpp</a>, and <a class="el" href="lonestar_2tutorial_examples_2SSSPPushSimple_8cpp-example.html#a4">lonestar/tutorial_examples/SSSPPushSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1687066d630a809fc309786d51da209a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1687066d630a809fc309786d51da209a">&#9670;&nbsp;</a></span>readGraphDispatch() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::readGraphDispatch </td>
          <td>(</td>
          <td class="paramtype">GraphTy &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkatana_1_1read__default__graph__tag.html">read_default_graph_tag</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>readUnweighted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If user specifies that the input graph is unweighted, the file graph also should be aware of this. Note that the application still could use the edge data array.</p>

</div>
</div>
<a id="a09e01f894d1177350056683f382c6325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e01f894d1177350056683f382c6325">&#9670;&nbsp;</a></span>readGraphDispatch() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::readGraphDispatch </td>
          <td>(</td>
          <td class="paramtype">GraphTy &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkatana_1_1read__default__graph__tag.html">read_default_graph_tag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkatana_1_1FileGraph.html">FileGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>readUnweighted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1106c79af0dbac243bc9153b96286209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1106c79af0dbac243bc9153b96286209">&#9670;&nbsp;</a></span>readGraphDispatch() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::readGraphDispatch </td>
          <td>(</td>
          <td class="paramtype">GraphTy &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkatana_1_1read__lc__inout__graph__tag.html">read_lc_inout_graph_tag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>f1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a168cf8a71da3da5033009a8f3b67958d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168cf8a71da3da5033009a8f3b67958d">&#9670;&nbsp;</a></span>readGraphDispatch() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::readGraphDispatch </td>
          <td>(</td>
          <td class="paramtype">GraphTy &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkatana_1_1read__lc__inout__graph__tag.html">read_lc_inout_graph_tag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a56f12232a22aae82d7153589cd828c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56f12232a22aae82d7153589cd828c53">&#9670;&nbsp;</a></span>readGraphDispatch() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::readGraphDispatch </td>
          <td>(</td>
          <td class="paramtype">GraphTy &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkatana_1_1read__lc__inout__graph__tag.html">read_lc_inout_graph_tag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkatana_1_1FileGraph.html">FileGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a857cca0a77a566618e0293265093d496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857cca0a77a566618e0293265093d496">&#9670;&nbsp;</a></span>readGraphDispatch() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::readGraphDispatch </td>
          <td>(</td>
          <td class="paramtype">GraphTy &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkatana_1_1read__lc__inout__graph__tag.html">read_lc_inout_graph_tag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkatana_1_1FileGraph.html">FileGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkatana_1_1FileGraph.html">FileGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec6aceb321ad842cc715abdbedf90665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6aceb321ad842cc715abdbedf90665">&#9670;&nbsp;</a></span>readGraphDispatch() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphTy , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::readGraphDispatch </td>
          <td>(</td>
          <td class="paramtype">GraphTy &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkatana_1_1read__oc__immutable__edge__graph__tag.html">read_oc_immutable_edge_graph_tag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5eda998551511444952075dd734130f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eda998551511444952075dd734130f3">&#9670;&nbsp;</a></span>readGraphDispatch() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::readGraphDispatch </td>
          <td>(</td>
          <td class="paramtype">GraphTy &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkatana_1_1read__with__aux__first__graph__tag.html">read_with_aux_first_graph_tag</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeac26deb08328c9846a712be1c4e0520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac26deb08328c9846a712be1c4e0520">&#9670;&nbsp;</a></span>readGraphDispatch() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::readGraphDispatch </td>
          <td>(</td>
          <td class="paramtype">GraphTy &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkatana_1_1read__with__aux__first__graph__tag.html">read_with_aux_first_graph_tag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkatana_1_1FileGraph.html">FileGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4fdf345b9e310e31835ae4d97e2424fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fdf345b9e310e31835ae4d97e2424fd">&#9670;&nbsp;</a></span>readGraphDispatch() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::readGraphDispatch </td>
          <td>(</td>
          <td class="paramtype">GraphTy &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkatana_1_1read__with__aux__graph__tag.html">read_with_aux_graph_tag</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24aabb9eff4a44dcee9d25503b985e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24aabb9eff4a44dcee9d25503b985e00">&#9670;&nbsp;</a></span>readGraphDispatch() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::readGraphDispatch </td>
          <td>(</td>
          <td class="paramtype">GraphTy &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structkatana_1_1read__with__aux__graph__tag.html">read_with_aux_graph_tag</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkatana_1_1FileGraph.html">FileGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b85cccf776bcc1742273fe7a3032ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b85cccf776bcc1742273fe7a3032ec8">&#9670;&nbsp;</a></span>readUpdateProtected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L , typename R , typename W &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::readUpdateProtected </td>
          <td>(</td>
          <td class="paramtype">L &amp;&#160;</td>
          <td class="paramname"><em>rwmutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R &amp;&#160;</td>
          <td class="paramname"><em>readAndCheck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">W &amp;&#160;</td>
          <td class="paramname"><em>write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>readOrUpdate is a generic function to perform reads or writes using a rwmutex </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rwmutex</td><td>is a read/write lock that implements readLock/readUnlock, writeLoack/writeUnlock</td></tr>
    <tr><td class="paramname">readAndCheck</td><td>is function object to execute when reading. It returns true only if read was successful. Should update state to store read result. Shouldn't use rwmutex internally </td></tr>
    <tr><td class="paramname">write</td><td>is function object to perform the write. It should update state to store result after writing. Shouldn't use rwmutex internally </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a80620300e5ea179d6692cf992d9300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a80620300e5ea179d6692cf992d9300">&#9670;&nbsp;</a></span>reportPageAlloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void katana::reportPageAlloc </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>category</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports Galois system memory stats for all threads. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="lonestar_2tutorial_examples_2CountLevels_8cpp-example.html#a11">lonestar/tutorial_examples/CountLevels.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a1adc9dc24ba3f5192f26399e61d5fd5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1adc9dc24ba3f5192f26399e61d5fd5a">&#9670;&nbsp;</a></span>ReportParam()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::ReportParam </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>category</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a501a5de37b3af287be54576f25e39b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a501a5de37b3af287be54576f25e39b">&#9670;&nbsp;</a></span>reportRUsage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void katana::reportRUsage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports maximum resident set size and page faults stats using rusage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Identifier to prefix stat with in statistics output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a373535c1eca82cc2ac6e6089c0ae771b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373535c1eca82cc2ac6e6089c0ae771b">&#9670;&nbsp;</a></span>ReportStat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::ReportStat </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>category</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structkatana_1_1StatTotal.html#a9dd50ac7b05676100fa167ae41ead1a6">StatTotal::Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt; std::is_floating_point_v&lt; T &gt;&gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a12b7969f7d4254fb0933b84c5a7ab3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b7969f7d4254fb0933b84c5a7ab3f5">&#9670;&nbsp;</a></span>ReportStat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::ReportStat </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>category</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structkatana_1_1StatTotal.html#a9dd50ac7b05676100fa167ae41ead1a6">StatTotal::Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt; std::is_integral_v&lt; T &gt;&gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ee12a7e5a9f79720a3149e1da78a009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee12a7e5a9f79720a3149e1da78a009">&#9670;&nbsp;</a></span>ReportStatAvg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::ReportStatAvg </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>category</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aadba2f74a01e10f763b69d35a82f6e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadba2f74a01e10f763b69d35a82f6e32">&#9670;&nbsp;</a></span>ReportStatMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::ReportStatMax </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>category</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac002eeebe4f90a37639b20f87128949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac002eeebe4f90a37639b20f87128949">&#9670;&nbsp;</a></span>ReportStatMin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::ReportStatMin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>category</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84fe29fa198c3f4ea0183dc47bd4dab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84fe29fa198c3f4ea0183dc47bd4dab2">&#9670;&nbsp;</a></span>ReportStatSingle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::ReportStatSingle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>category</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af26b2591ad27d49579dea66ae5983422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26b2591ad27d49579dea66ae5983422">&#9670;&nbsp;</a></span>ReportStatSum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void katana::ReportStatSum </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>category</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5585c3aee0ab7f501e508e6dc4897186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5585c3aee0ab7f501e508e6dc4897186">&#9670;&nbsp;</a></span>ResultErrno()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::error_code katana::ResultErrno </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a58306194672cbd10c5ffb4ea812101a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58306194672cbd10c5ffb4ea812101a6">&#9670;&nbsp;</a></span>ResultSuccess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; void &gt; katana::ResultSuccess </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afffe512028c1d9966fe6c33faed802e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afffe512028c1d9966fe6c33faed802e0">&#9670;&nbsp;</a></span>safe_advance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IterTy , class Distance &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IterTy katana::safe_advance </td>
          <td>(</td>
          <td class="paramtype">IterTy&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterTy&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Distance&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like std::advance but returns end if end is closer than the advance amount. </p>

</div>
</div>
<a id="a8e6c6ce37bb694723f64f2ff07d7d9c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6c6ce37bb694723f64f2ff07d7d9c2">&#9670;&nbsp;</a></span>safe_advance_dispatch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IterTy , class Distance &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IterTy katana::safe_advance_dispatch </td>
          <td>(</td>
          <td class="paramtype">IterTy&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterTy&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Distance&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::input_iterator_tag&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad210855f190f658eb311b71f9d7b20c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad210855f190f658eb311b71f9d7b20c1">&#9670;&nbsp;</a></span>safe_advance_dispatch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IterTy , class Distance &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IterTy katana::safe_advance_dispatch </td>
          <td>(</td>
          <td class="paramtype">IterTy&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterTy&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Distance&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::random_access_iterator_tag&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abcf17ca09168c4c9966d156adc7fc4b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf17ca09168c4c9966d156adc7fc4b2">&#9670;&nbsp;</a></span>setActiveThreads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int katana::setActiveThreads </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the number of threads to use when running any Galois iterator. </p>
<p>Returns the actual value of threads used, which could be less than the requested value. System behavior is undefined if this function is called during parallel execution or after the first parallel execution. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="lonestar_2tutorial_examples_2ConflictAwareTorus_8cpp-example.html#a8">lonestar/tutorial_examples/ConflictAwareTorus.cpp</a>, <a class="el" href="lonestar_2tutorial_examples_2GraphTraversalPullOperator_8cpp-example.html#a4">lonestar/tutorial_examples/GraphTraversalPullOperator.cpp</a>, <a class="el" href="lonestar_2tutorial_examples_2GraphTraversalPushOperator_8cpp-example.html#a8">lonestar/tutorial_examples/GraphTraversalPushOperator.cpp</a>, and <a class="el" href="lonestar_2tutorial_examples_2SSSPPushSimple_8cpp-example.html#a3">lonestar/tutorial_examples/SSSPPushSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ac533e1296ea9b6bc79600af41bb9e541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac533e1296ea9b6bc79600af41bb9e541">&#9670;&nbsp;</a></span>SetEnv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool katana::SetEnv </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overwrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set environment variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">var_name</td><td>name of the variable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>new value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">overwrite</td><td>if true, and var_name exists, overwrite previous value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if env not previously set or successfully overwritten </dd></dl>

</div>
</div>
<a id="a1f1b9a8f185ce350243d967cbb301196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1b9a8f185ce350243d967cbb301196">&#9670;&nbsp;</a></span>SetStatFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void katana::SetStatFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad4ffca2ccdc1c54f45f94808aac9306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4ffca2ccdc1c54f45f94808aac9306">&#9670;&nbsp;</a></span>setThreadContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void katana::setThreadContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1SimpleRuntimeContext.html">katana::SimpleRuntimeContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>used by the parallel code to set up conflict detection per thread </p>

</div>
</div>
<a id="aa55a084718d23d24da3e0fa3d2e4a75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55a084718d23d24da3e0fa3d2e4a75e">&#9670;&nbsp;</a></span>shouldLock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool katana::shouldLock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246">katana::MethodFlag</a>&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to decide if the conflict detection lock should be taken. </p>

</div>
</div>
<a id="a0a83ff77e4d0cf4bacc8d2ef3c0dfe8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a83ff77e4d0cf4bacc8d2ef3c0dfe8d">&#9670;&nbsp;</a></span>Shuffle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; std::shared_ptr&lt; arrow::ChunkedArray &gt; &gt; katana::Shuffle </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; arrow::ChunkedArray &gt; &amp;&#160;</td>
          <td class="paramname"><em>original</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a randomly shuffled version of a ChunkedArray. </p>

</div>
</div>
<a id="a2ff9b9f83da21711106f1edba7c00d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff9b9f83da21711106f1edba7c00d0f">&#9670;&nbsp;</a></span>signalConflict()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void katana::signalConflict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1Lockable.html">Lockable</a> *&#160;</td>
          <td class="paramname"> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a558ccee2a8c1ffe3bef91fe5c6b67478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a558ccee2a8c1ffe3bef91fe5c6b67478">&#9670;&nbsp;</a></span>signalFailSafe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void katana::signalFailSafe </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c6a5beb4b08696410d9047c5718867c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c6a5beb4b08696410d9047c5718867c">&#9670;&nbsp;</a></span>SingleView() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;T&gt;* katana::SingleView </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::tuple&lt; T &gt;&gt; *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63c805dd77bf706871493fdf2849a516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c805dd77bf706871493fdf2849a516">&#9670;&nbsp;</a></span>SingleView() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt;* katana::SingleView </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; T &gt;&gt; *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a574511388fed50f51d53c9a39dee18d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574511388fed50f51d53c9a39dee18d8">&#9670;&nbsp;</a></span>SortAllEdgesByDest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; std::shared_ptr&lt; arrow::UInt64Array &gt; &gt; katana::SortAllEdgesByDest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">katana::PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SortAllEdgesByDest sorts edges for each node by destination IDs (ascending order). </p>
<p>Returns the permutation vector (mapping from old indices to the new indices) which results due to the sorting. </p>

</div>
</div>
<a id="abc2abe07e0439f427c32b1ecd8ce498c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc2abe07e0439f427c32b1ecd8ce498c">&#9670;&nbsp;</a></span>SortNodesByDegree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; void &gt; katana::SortNodesByDegree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">katana::PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relabel all nodes in the graph by sorting in the descending order by node degree. </p>

</div>
</div>
<a id="a4a93b4e45b04e6893ddacadc06dd9837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a93b4e45b04e6893ddacadc06dd9837">&#9670;&nbsp;</a></span>split_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IterTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IterTy katana::split_range </td>
          <td>(</td>
          <td class="paramtype">IterTy&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterTy&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the midpoint of a range. </p>
<p>The first half is always be bigger than the second half if the range has an odd length. </p>

</div>
</div>
<a id="a336314b6e1f2c87c6d536b8f240c0297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336314b6e1f2c87c6d536b8f240c0297">&#9670;&nbsp;</a></span>SplitView()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string_view &gt; katana::SplitView </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max</em> = <code>std::numeric_limits&lt;uint64_t&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SplitView returns a list of words in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>using</td></tr>
    <tr><td class="paramname">sep</td><td>as the delimiter string. Splits at most</td></tr>
    <tr><td class="paramname">max</td><td>times (so there will be at most max + 1 entries in the output) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab57755b7f0fcee27d8b27ac5d545ae0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57755b7f0fcee27d8b27ac5d545ae0c">&#9670;&nbsp;</a></span>ToBase64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string katana::ToBase64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>url_safe</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ToBase64 encodes message string into a Base64 string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url_safe</td><td>forces URL-safe encoding of result base64 result (replacing +/ with -_) </td></tr>
    <tr><td class="paramname">message</td><td>binary string input </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab373cd02635e0ba3153c168b92a8ce89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab373cd02635e0ba3153c168b92a8ce89">&#9670;&nbsp;</a></span>TrimPrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string katana::TrimPrefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TrimPrefix returns a string without the given prefix. </p>
<p>If the string does not have the prefix, return the string unchanged. </p>

</div>
</div>
<a id="aa7da63c6791373f48b3c01162fd04717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7da63c6791373f48b3c01162fd04717">&#9670;&nbsp;</a></span>TrimSuffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string katana::TrimSuffix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TrimSuffix returns a string without the given suffix. </p>
<p>If the string does not have the suffix, return the string unchanged. </p>

</div>
</div>
<a id="a5c2a6965620c430869b94916d9bf68f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c2a6965620c430869b94916d9bf68f7">&#9670;&nbsp;</a></span>TupleView() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::tuple&lt;T&gt; &gt;* katana::TupleView </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ba65c8b04ba5fc50aafbaeeefe24ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba65c8b04ba5fc50aafbaeeefe24ce3">&#9670;&nbsp;</a></span>TupleView() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::tuple&lt;T&gt; &gt;* katana::TupleView </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a29db018e074a8b6937acc03eaec0840a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29db018e074a8b6937acc03eaec0840a">&#9670;&nbsp;</a></span>Unchunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; std::shared_ptr&lt; arrow::Array &gt; &gt; katana::Unchunk </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; arrow::ChunkedArray &gt; &amp;&#160;</td>
          <td class="paramname"><em>original</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine chunks of ChunkedArray into a single Array. </p>

</div>
</div>
<a id="acdef1706a232c3c2422532fe231ffaf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdef1706a232c3c2422532fe231ffaf2">&#9670;&nbsp;</a></span>uninitialized_destroy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!std::is_scalar&lt;internal::Val_ty&lt;I&gt; &gt;::value&gt; katana::uninitialized_destroy </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a range. </p>

</div>
</div>
<a id="a8399d55ebc826ebe4e776fda5f3e7cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8399d55ebc826ebe4e776fda5f3e7cb6">&#9670;&nbsp;</a></span>uninitialized_destroy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_scalar&lt;internal::Val_ty&lt;I&gt; &gt;::value&gt; katana::uninitialized_destroy </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a230f73b3e83498ad75ad294121dabf34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230f73b3e83498ad75ad294121dabf34">&#9670;&nbsp;</a></span>UnmarshalVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt;std::vector&lt;T&gt; &gt; katana::UnmarshalVector </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; arrow::ChunkedArray &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a75d9799ead1fea82a3a127f5e64da249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d9799ead1fea82a3a127f5e64da249">&#9670;&nbsp;</a></span>UnmarshalVectorOfVectors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt;void&gt; katana::UnmarshalVectorOfVectors </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; arrow::ChunkedArray &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt;&gt; *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb9a55ca4432cdcbcf89f511357f4cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9a55ca4432cdcbcf89f511357f4cf2">&#9670;&nbsp;</a></span>UnsetEnv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool katana::UnsetEnv </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05662d486fd897103e6ec8c2ef8a4a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05662d486fd897103e6ec8c2ef8a4a8e">&#9670;&nbsp;</a></span>UsBetween()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t katana::UsBetween </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacekatana.html#ad53d5a0919afb768f3ad0304893c5925">TimePoint</a> &amp;&#160;</td>
          <td class="paramname"><em>before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacekatana.html#ad53d5a0919afb768f3ad0304893c5925">TimePoint</a> &amp;&#160;</td>
          <td class="paramname"><em>after</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a95710088fa7cee6aa2c8147e639b7d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95710088fa7cee6aa2c8147e639b7d34">&#9670;&nbsp;</a></span>UsSince()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t katana::UsSince </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacekatana.html#ad53d5a0919afb768f3ad0304893c5925">TimePoint</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abeec63455a70851a42571e44275e551b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeec63455a70851a42571e44275e551b">&#9670;&nbsp;</a></span>UsToPair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;float, std::string&gt; katana::UsToPair </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>us_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a73034aea69c3c53b0bfd6c53deea3171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73034aea69c3c53b0bfd6c53deea3171">&#9670;&nbsp;</a></span>UsToStr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string katana::UsToStr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>us_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a94dace563280e6250a46a977f5bb7f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94dace563280e6250a46a977f5bb7f9c">&#9670;&nbsp;</a></span>VectorToArrowTable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt;std::shared_ptr&lt;arrow::Table&gt; &gt; katana::VectorToArrowTable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ffa128de14b8dcfcdff4b7a3076c659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ffa128de14b8dcfcdff4b7a3076c659">&#9670;&nbsp;</a></span>ViewCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrowArrayType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt;std::shared_ptr&lt;ArrowArrayType&gt; &gt; katana::ViewCast </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; arrow::Array &gt; &amp;&#160;</td>
          <td class="paramname"><em>gen_array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a safe cast from. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen_array</td><td>to </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ArrowArrayType</td><td>calls the array's <code>View()</code> member first to make sure cast is safe. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b98d31f0a622527d9aac0e2b9b99910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b98d31f0a622527d9aac0e2b9b99910">&#9670;&nbsp;</a></span>VisitArrow() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VisitorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto katana::VisitArrow </td>
          <td>(</td>
          <td class="paramtype">arrow::ArrayBuilder *&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VisitorType &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a99077f061bb4a4addaaa3d762e3e8f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99077f061bb4a4addaaa3d762e3e8f22">&#9670;&nbsp;</a></span>VisitArrow() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VisitorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto katana::VisitArrow </td>
          <td>(</td>
          <td class="paramtype">const arrow::Array &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VisitorType &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d8c9eb23aa08a63e8c1506688b8547b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8c9eb23aa08a63e8c1506688b8547b">&#9670;&nbsp;</a></span>VisitArrow() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VisitorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto katana::VisitArrow </td>
          <td>(</td>
          <td class="paramtype">const arrow::Scalar &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VisitorType &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1cb4dffa843290f76c568dc66ea3a3ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb4dffa843290f76c568dc66ea3a3ef">&#9670;&nbsp;</a></span>VisitArrow() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VisitorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto katana::VisitArrow </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; arrow::Array &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VisitorType &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d13f7ca4f18d6bb562eb2714f3bc69c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d13f7ca4f18d6bb562eb2714f3bc69c">&#9670;&nbsp;</a></span>VisitArrow() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VisitorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto katana::VisitArrow </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; arrow::Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VisitorType &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c6e4e62056de4448f5c1cee63edf6a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c6e4e62056de4448f5c1cee63edf6a4">&#9670;&nbsp;</a></span>VisitArrow() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VisitorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto katana::VisitArrow </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; arrow::ArrayBuilder &gt; &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VisitorType &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a996c85bab3fdbf1afad32e8595db32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a996c85bab3fdbf1afad32e8595db32">&#9670;&nbsp;</a></span>wl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structkatana_1_1s__wl.html">s_wl</a>&lt;T, Args...&gt; katana::wl </td>
          <td>(</td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="lonestar_2tutorial_examples_2SSSPPushSimple_8cpp-example.html#a15">lonestar/tutorial_examples/SSSPPushSimple.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a09a29993f22074dde5cfcfaa0d500c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a29993f22074dde5cfcfaa0d500c0c">&#9670;&nbsp;</a></span>WritePropertyGraph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; void &gt; katana::WritePropertyGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structkatana_1_1GraphComponents.html">GraphComponents</a> &amp;&#160;</td>
          <td class="paramname"><em>graph_comps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>WritePropertyGraph writes an RDG from the provided. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph_comps</td><td>to the directory</td></tr>
    <tr><td class="paramname">dir</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad689f7fed45edd01461b6ccc9f7fd8e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad689f7fed45edd01461b6ccc9f7fd8e4">&#9670;&nbsp;</a></span>WritePropertyGraph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; void &gt; katana::WritePropertyGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">katana::PropertyGraph</a>&#160;</td>
          <td class="paramname"><em>prop_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="afea83498ac35d84218d622ef40b4aa41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea83498ac35d84218d622ef40b4aa41">&#9670;&nbsp;</a></span>activeThreads</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KATANA_EXPORT unsigned int katana::activeThreads = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8bbd71ce290ae17106f1ed289de971c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8bbd71ce290ae17106f1ed289de971c">&#9670;&nbsp;</a></span>at_least_base_of</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Base , typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool katana::at_least_base_of</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    std::is_base_of&lt;Base, Derived&gt;::value || std::is_same&lt;Base, Derived&gt;::value</div>
</div><!-- fragment -->
<p>True if Derived is derived from Base or is Base itself. </p>
<p>A matching trait is any type that inherits from a trait. </p>

</div>
</div>
<a id="ae71c54b5fc15b823ee663babfd0aabc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71c54b5fc15b823ee663babfd0aabc0">&#9670;&nbsp;</a></span>EmptyBitset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KATANA_EXPORT <a class="el" href="classkatana_1_1DynamicBitset.html">katana::DynamicBitset</a> katana::EmptyBitset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An empty bitset object; used mainly by <a class="el" href="structkatana_1_1InvalidBitsetFn.html" title="A structure representing an empty bitset.">InvalidBitsetFn</a>. </p>

</div>
</div>
<a id="a1beaf8c96891b65f684741e6923db0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1beaf8c96891b65f684741e6923db0d4">&#9670;&nbsp;</a></span>execFrame</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KATANA_EXPORT thread_local jmp_buf katana::execFrame</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a088ca56912daa367a04eaf7c715d1d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a088ca56912daa367a04eaf7c715d1d9c">&#9670;&nbsp;</a></span>has_local_iterator_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool katana::has_local_iterator_v = <a class="el" href="structkatana_1_1has__local__iterator.html">has_local_iterator</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e72eb4ac2f0ddccce24eefedceec1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e72eb4ac2f0ddccce24eefedceec1b2">&#9670;&nbsp;</a></span>KATANA_CACHE_LINE_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int katana::KATANA_CACHE_LINE_SIZE = 128</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afb50a75c9196240c03d62e23468d80de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb50a75c9196240c03d62e23468d80de">&#9670;&nbsp;</a></span>pssBase</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KATANA_EXPORT thread_local char * katana::pssBase</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab00ab493efad0f6093ce35620f3ff897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab00ab493efad0f6093ce35620f3ff897">&#9670;&nbsp;</a></span>ptsBase</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KATANA_EXPORT thread_local char * katana::ptsBase</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacekatana.html">katana</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
