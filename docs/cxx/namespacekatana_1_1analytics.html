<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Katana: katana::analytics Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Katana
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacekatana_1_1analytics.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">katana::analytics Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1analytics_1_1BetweennessCentralityPlan.html">BetweennessCentralityPlan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A computational plan to for Betweenness Centrality, specifying the algorithm and any parameters associated with it.  <a href="classkatana_1_1analytics_1_1BetweennessCentralityPlan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1analytics_1_1BetweennessCentralityStatistics.html">BetweennessCentralityStatistics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1analytics_1_1BfsPlan.html">BfsPlan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A computational plan to for BFS, specifying the algorithm and any parameters associated with it.  <a href="classkatana_1_1analytics_1_1BfsPlan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1analytics_1_1BfsStatistics.html">BfsStatistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics about a graph that can be extracted from the results of BFS.  <a href="structkatana_1_1analytics_1_1BfsStatistics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1analytics_1_1BfsSsspImplementationBase.html">BfsSsspImplementationBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1analytics_1_1SerialBucketWL.html">SerialBucketWL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1analytics_1_1CommunityType.html">CommunityType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1analytics_1_1ClusteringImplementationBase.html">ClusteringImplementationBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1analytics_1_1ConnectedComponentsPlan.html">ConnectedComponentsPlan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A computational plan to for ConnectedComponents, specifying the algorithm and any parameters associated with it.  <a href="classkatana_1_1analytics_1_1ConnectedComponentsPlan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1analytics_1_1ConnectedComponentsStatistics.html">ConnectedComponentsStatistics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1analytics_1_1IndependentSetPlan.html">IndependentSetPlan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A computational plan to for IndependentSet, specifying the algorithm and any parameters associated with it.  <a href="classkatana_1_1analytics_1_1IndependentSetPlan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1analytics_1_1IndependentSetStatistics.html">IndependentSetStatistics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1analytics_1_1JaccardPlan.html">JaccardPlan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A computational plan to for Jaccard, specifying the algorithm and any parameters associated with it.  <a href="classkatana_1_1analytics_1_1JaccardPlan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1analytics_1_1JaccardStatistics.html">JaccardStatistics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1analytics_1_1KCorePlan.html">KCorePlan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A computational plan to for k-core, specifying the algorithm and any parameters associated with it.  <a href="classkatana_1_1analytics_1_1KCorePlan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1analytics_1_1KCoreStatistics.html">KCoreStatistics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1analytics_1_1KTrussPlan.html">KTrussPlan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A computational plan to for k-truss, specifying the algorithm and any parameters associated with it.  <a href="classkatana_1_1analytics_1_1KTrussPlan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1analytics_1_1KTrussStatistics.html">KTrussStatistics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1analytics_1_1LocalClusteringCoefficientPlan.html">LocalClusteringCoefficientPlan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A computational plan to for computing Local Clustering Coefficient of the nodes in the graph.  <a href="classkatana_1_1analytics_1_1LocalClusteringCoefficientPlan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1analytics_1_1LouvainClusteringPlan.html">LouvainClusteringPlan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A computational plan to for Louvain Clustering, specifying the algorithm and any parameters associated with it.  <a href="classkatana_1_1analytics_1_1LouvainClusteringPlan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1analytics_1_1LouvainClusteringStatistics.html">LouvainClusteringStatistics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1analytics_1_1PagerankPlan.html">PagerankPlan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A computational plan to for Page Rank, specifying the algorithm and any parameters associated with it.  <a href="classkatana_1_1analytics_1_1PagerankPlan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1analytics_1_1PagerankStatistics.html">PagerankStatistics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1analytics_1_1Plan.html">Plan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for abstract algorithm execution plans.  <a href="classkatana_1_1analytics_1_1Plan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1analytics_1_1RandomWalksPlan.html">RandomWalksPlan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A computational plan to for random walks, specifying the algorithm and any parameters associated with it.  <a href="classkatana_1_1analytics_1_1RandomWalksPlan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1analytics_1_1SsspPlan.html">SsspPlan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A computational plan to for SSSP, specifying the algorithm and any parameters associated with it.  <a href="classkatana_1_1analytics_1_1SsspPlan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkatana_1_1analytics_1_1SsspStatistics.html">SsspStatistics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1analytics_1_1SubGraphExtractionPlan.html">SubGraphExtractionPlan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A computational plan to for SubGraph Extraction.  <a href="classkatana_1_1analytics_1_1SubGraphExtractionPlan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1analytics_1_1TriangleCountPlan.html">TriangleCountPlan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A computational plan to for Total Triangle Counting.  <a href="classkatana_1_1analytics_1_1TriangleCountPlan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1analytics_1_1SourcePicker.html">SourcePicker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to pick random non-zero degree starting points for search algorithms This code has been copied from GAP benchmark suite (<a href="https://github.com/sbeamer/gapbs/blob/master/src/benchmark.h">https://github.com/sbeamer/gapbs/blob/master/src/benchmark.h</a>)  <a href="classkatana_1_1analytics_1_1SourcePicker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkatana_1_1analytics_1_1TemporaryPropertyGuard.html">TemporaryPropertyGuard</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae50d59efc521345adc886403dc18c7de"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#ae50d59efc521345adc886403dc18c7de">BetweennessCentralitySources</a> = std::variant&lt; std::vector&lt; uint32_t &gt;, uint32_t &gt;</td></tr>
<tr class="memdesc:ae50d59efc521345adc886403dc18c7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either a vector of node IDs or a number of nodes to use as sources.  <a href="namespacekatana_1_1analytics.html#ae50d59efc521345adc886403dc18c7de">More...</a><br /></td></tr>
<tr class="separator:ae50d59efc521345adc886403dc18c7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03734437694019f4c0cda884fdef6bb1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#a03734437694019f4c0cda884fdef6bb1">PreviousCommunityId</a> = <a class="el" href="structkatana_1_1PODProperty.html">katana::PODProperty</a>&lt; uint64_t &gt;</td></tr>
<tr class="separator:a03734437694019f4c0cda884fdef6bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7080d1f306b7d15f27e1d748920906e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#aa7080d1f306b7d15f27e1d748920906e">CurrentCommunityId</a> = <a class="el" href="structkatana_1_1PODProperty.html">katana::PODProperty</a>&lt; uint64_t &gt;</td></tr>
<tr class="separator:aa7080d1f306b7d15f27e1d748920906e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87877f68912d2b62aaae8a82afcdafd3"><td class="memTemplParams" colspan="2">template&lt;typename EdgeWeightType &gt; </td></tr>
<tr class="memitem:a87877f68912d2b62aaae8a82afcdafd3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#a87877f68912d2b62aaae8a82afcdafd3">DegreeWeight</a> = <a class="el" href="structkatana_1_1PODProperty.html">katana::PODProperty</a>&lt; EdgeWeightType &gt;</td></tr>
<tr class="separator:a87877f68912d2b62aaae8a82afcdafd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab881d32255bbe4a19c4564e7df7c1e0"><td class="memTemplParams" colspan="2">template&lt;typename EdgeWeightType &gt; </td></tr>
<tr class="memitem:aab881d32255bbe4a19c4564e7df7c1e0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#aab881d32255bbe4a19c4564e7df7c1e0">EdgeWeight</a> = <a class="el" href="structkatana_1_1PODProperty.html">katana::PODProperty</a>&lt; EdgeWeightType &gt;</td></tr>
<tr class="separator:aab881d32255bbe4a19c4564e7df7c1e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8026b912be30b3abc12ea48154cdcbc0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#a8026b912be30b3abc12ea48154cdcbc0">JaccardSimilarity</a> = <a class="el" href="structkatana_1_1PODProperty.html">katana::PODProperty</a>&lt; double &gt;</td></tr>
<tr class="memdesc:a8026b912be30b3abc12ea48154cdcbc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tag for the output property of Jaccard in PropertyGraphs.  <a href="namespacekatana_1_1analytics.html#a8026b912be30b3abc12ea48154cdcbc0">More...</a><br /></td></tr>
<tr class="separator:a8026b912be30b3abc12ea48154cdcbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa930ba9d94d02e83368243aee3820363"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#aa930ba9d94d02e83368243aee3820363">Architecture</a> { <a class="el" href="namespacekatana_1_1analytics.html#aa930ba9d94d02e83368243aee3820363a279ae61befa0f7a0d354dfc9878e5a47">kCPU</a>
, <a class="el" href="namespacekatana_1_1analytics.html#aa930ba9d94d02e83368243aee3820363a6582c44036c4ea26a95c767a4a95dd7f">kGPU</a>
, <a class="el" href="namespacekatana_1_1analytics.html#aa930ba9d94d02e83368243aee3820363ab1f37d0c864367a4e924b097371d7e5c">kDistributedCPU</a>
, <a class="el" href="namespacekatana_1_1analytics.html#aa930ba9d94d02e83368243aee3820363a753939223cd69667e69ff1cedd1c958f">kDistributedGPU</a>
 }</td></tr>
<tr class="separator:aa930ba9d94d02e83368243aee3820363"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7639b799bdb08c48b441797944b35993"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#a7639b799bdb08c48b441797944b35993">BetweennessCentrality</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *pg, const std::string &amp;output_property_name, const <a class="el" href="namespacekatana_1_1analytics.html#ae50d59efc521345adc886403dc18c7de">BetweennessCentralitySources</a> &amp;sources=<a class="el" href="namespacekatana_1_1analytics.html#aee075c32ae43c2b5e95358fb77629843">kBetweennessCentralityAllNodes</a>, <a class="el" href="classkatana_1_1analytics_1_1BetweennessCentralityPlan.html">BetweennessCentralityPlan</a> plan={})</td></tr>
<tr class="memdesc:a7639b799bdb08c48b441797944b35993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the betweenness centrality of each node in the graph.  <a href="namespacekatana_1_1analytics.html#a7639b799bdb08c48b441797944b35993">More...</a><br /></td></tr>
<tr class="separator:a7639b799bdb08c48b441797944b35993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0dfee34330fb2bf4f6d699d4cd93dba"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#ad0dfee34330fb2bf4f6d699d4cd93dba">Bfs</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *pg, size_t start_node, const std::string &amp;output_property_name, <a class="el" href="classkatana_1_1analytics_1_1BfsPlan.html">BfsPlan</a> algo={})</td></tr>
<tr class="memdesc:ad0dfee34330fb2bf4f6d699d4cd93dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute BFS level of nodes in the graph pg starting from start_node.  <a href="namespacekatana_1_1analytics.html#ad0dfee34330fb2bf4f6d699d4cd93dba">More...</a><br /></td></tr>
<tr class="separator:ad0dfee34330fb2bf4f6d699d4cd93dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaae12ace70cffe1c6d1244d8bb7ecb8"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#aaaae12ace70cffe1c6d1244d8bb7ecb8">BfsAssertValid</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *pg, const std::string &amp;property_name)</td></tr>
<tr class="memdesc:aaaae12ace70cffe1c6d1244d8bb7ecb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a quick validation of the results of a BFS computation where the results are stored in property_name.  <a href="namespacekatana_1_1analytics.html#aaaae12ace70cffe1c6d1244d8bb7ecb8">More...</a><br /></td></tr>
<tr class="separator:aaaae12ace70cffe1c6d1244d8bb7ecb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acece1aec894ee366dabc793e8823a1cf"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#acece1aec894ee366dabc793e8823a1cf">ConnectedComponents</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *pg, const std::string &amp;output_property_name, <a class="el" href="classkatana_1_1analytics_1_1ConnectedComponentsPlan.html">ConnectedComponentsPlan</a> plan=<a class="el" href="classkatana_1_1analytics_1_1ConnectedComponentsPlan.html">ConnectedComponentsPlan</a>())</td></tr>
<tr class="memdesc:acece1aec894ee366dabc793e8823a1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Connected-components for pg.  <a href="namespacekatana_1_1analytics.html#acece1aec894ee366dabc793e8823a1cf">More...</a><br /></td></tr>
<tr class="separator:acece1aec894ee366dabc793e8823a1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b81f09a193902ef39e3754fb6688476"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#a6b81f09a193902ef39e3754fb6688476">ConnectedComponentsAssertValid</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *pg, const std::string &amp;property_name)</td></tr>
<tr class="separator:a6b81f09a193902ef39e3754fb6688476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d7bac77fedbc9c6c894ea38781820f"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#ae7d7bac77fedbc9c6c894ea38781820f">IndependentSet</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *pg, const std::string &amp;output_property_name, <a class="el" href="classkatana_1_1analytics_1_1IndependentSetPlan.html">IndependentSetPlan</a> plan={})</td></tr>
<tr class="memdesc:ae7d7bac77fedbc9c6c894ea38781820f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a maximal (not the maximum) independent set in the graph and create an indicator property that is true for elements of the independent set.  <a href="namespacekatana_1_1analytics.html#ae7d7bac77fedbc9c6c894ea38781820f">More...</a><br /></td></tr>
<tr class="separator:ae7d7bac77fedbc9c6c894ea38781820f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688aeedd8a418b370fd0e40786e56919"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#a688aeedd8a418b370fd0e40786e56919">IndependentSetAssertValid</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *pg, const std::string &amp;property_name)</td></tr>
<tr class="separator:a688aeedd8a418b370fd0e40786e56919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2004489938a22963b5c4cc01492179b7"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#a2004489938a22963b5c4cc01492179b7">Jaccard</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *pg, uint32_t compare_node, const std::string &amp;output_property_name, <a class="el" href="classkatana_1_1analytics_1_1JaccardPlan.html">JaccardPlan</a> plan={})</td></tr>
<tr class="memdesc:a2004489938a22963b5c4cc01492179b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Jaccard similarity between each node and compare_node.  <a href="namespacekatana_1_1analytics.html#a2004489938a22963b5c4cc01492179b7">More...</a><br /></td></tr>
<tr class="separator:a2004489938a22963b5c4cc01492179b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348b6e08fc56d2cec5425638c7f44238"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#a348b6e08fc56d2cec5425638c7f44238">JaccardAssertValid</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *pg, uint32_t compare_node, const std::string &amp;property_name)</td></tr>
<tr class="separator:a348b6e08fc56d2cec5425638c7f44238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8d23229b722a30e45f94e726ac55d1"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#ade8d23229b722a30e45f94e726ac55d1">KCore</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *pg, uint32_t k_core_number, const std::string &amp;output_property_name, <a class="el" href="classkatana_1_1analytics_1_1KCorePlan.html">KCorePlan</a> plan=<a class="el" href="classkatana_1_1analytics_1_1KCorePlan.html">KCorePlan</a>())</td></tr>
<tr class="memdesc:ade8d23229b722a30e45f94e726ac55d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the k-core for pg.  <a href="namespacekatana_1_1analytics.html#ade8d23229b722a30e45f94e726ac55d1">More...</a><br /></td></tr>
<tr class="separator:ade8d23229b722a30e45f94e726ac55d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bde64d08df2f783d7afa0ce667d56ec"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#a1bde64d08df2f783d7afa0ce667d56ec">KCoreAssertValid</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *pg, uint32_t k_core_number, const std::string &amp;property_name)</td></tr>
<tr class="separator:a1bde64d08df2f783d7afa0ce667d56ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833e4433c5a3f371da2bfd523ee07d27"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#a833e4433c5a3f371da2bfd523ee07d27">KTruss</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *pg, uint32_t k_truss_number, const std::string &amp;output_property_name, <a class="el" href="classkatana_1_1analytics_1_1KTrussPlan.html">KTrussPlan</a> plan=<a class="el" href="classkatana_1_1analytics_1_1KTrussPlan.html">KTrussPlan</a>())</td></tr>
<tr class="memdesc:a833e4433c5a3f371da2bfd523ee07d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the k-truss for pg.  <a href="namespacekatana_1_1analytics.html#a833e4433c5a3f371da2bfd523ee07d27">More...</a><br /></td></tr>
<tr class="separator:a833e4433c5a3f371da2bfd523ee07d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a654f116e8c7458fb5a6f7d0b385a79"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#a9a654f116e8c7458fb5a6f7d0b385a79">KTrussAssertValid</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *pg, uint32_t k_truss_number, const std::string &amp;property_name)</td></tr>
<tr class="separator:a9a654f116e8c7458fb5a6f7d0b385a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229b3504c8bbe09c93ff0f92a9da0975"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#a229b3504c8bbe09c93ff0f92a9da0975">LocalClusteringCoefficient</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *pg, const std::string &amp;output_property_name, <a class="el" href="classkatana_1_1analytics_1_1LocalClusteringCoefficientPlan.html">LocalClusteringCoefficientPlan</a> plan={})</td></tr>
<tr class="memdesc:a229b3504c8bbe09c93ff0f92a9da0975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the local clustering coefficient for each node in the graph.  <a href="namespacekatana_1_1analytics.html#a229b3504c8bbe09c93ff0f92a9da0975">More...</a><br /></td></tr>
<tr class="separator:a229b3504c8bbe09c93ff0f92a9da0975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c829f08df32992b378ee01baa92751"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#a58c829f08df32992b378ee01baa92751">LouvainClustering</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *pg, const std::string &amp;edge_weight_property_name, const std::string &amp;output_property_name, <a class="el" href="classkatana_1_1analytics_1_1LouvainClusteringPlan.html">LouvainClusteringPlan</a> plan={})</td></tr>
<tr class="memdesc:a58c829f08df32992b378ee01baa92751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Louvain Clustering for pg.  <a href="namespacekatana_1_1analytics.html#a58c829f08df32992b378ee01baa92751">More...</a><br /></td></tr>
<tr class="separator:a58c829f08df32992b378ee01baa92751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a66e47c199bf183ff39a5cd2eff72a9"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#a3a66e47c199bf183ff39a5cd2eff72a9">LouvainClusteringAssertValid</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *pg, const std::string &amp;edge_weight_property_name, const std::string &amp;output_property_name)</td></tr>
<tr class="separator:a3a66e47c199bf183ff39a5cd2eff72a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec27a49483311a3facf97a799d9d6a6"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#a7ec27a49483311a3facf97a799d9d6a6">Pagerank</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *pg, const std::string &amp;output_property_name, <a class="el" href="classkatana_1_1analytics_1_1PagerankPlan.html">PagerankPlan</a> plan={})</td></tr>
<tr class="memdesc:a7ec27a49483311a3facf97a799d9d6a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Page Rank of each node in the graph.  <a href="namespacekatana_1_1analytics.html#a7ec27a49483311a3facf97a799d9d6a6">More...</a><br /></td></tr>
<tr class="separator:a7ec27a49483311a3facf97a799d9d6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b148a44c8f7ab6c7674a7a3f79abec"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#ad8b148a44c8f7ab6c7674a7a3f79abec">PagerankAssertValid</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *pg, const std::string &amp;property_name)</td></tr>
<tr class="separator:ad8b148a44c8f7ab6c7674a7a3f79abec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a246a13e7841d59218ec6bf18f1d33"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; std::vector&lt; std::vector&lt; uint32_t &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#af6a246a13e7841d59218ec6bf18f1d33">RandomWalks</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *pg, <a class="el" href="classkatana_1_1analytics_1_1RandomWalksPlan.html">RandomWalksPlan</a> plan=<a class="el" href="classkatana_1_1analytics_1_1RandomWalksPlan.html">RandomWalksPlan</a>())</td></tr>
<tr class="memdesc:af6a246a13e7841d59218ec6bf18f1d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the random-walks for pg.  <a href="namespacekatana_1_1analytics.html#af6a246a13e7841d59218ec6bf18f1d33">More...</a><br /></td></tr>
<tr class="separator:af6a246a13e7841d59218ec6bf18f1d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7646a1f8e62c356a14ccebb66bf828a1"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#a7646a1f8e62c356a14ccebb66bf828a1">RandomWalksAssertValid</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *pg)</td></tr>
<tr class="separator:a7646a1f8e62c356a14ccebb66bf828a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc0a8af9131aec64fabbcda525ed31c"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#a0bc0a8af9131aec64fabbcda525ed31c">Sssp</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *pg, size_t start_node, const std::string &amp;edge_weight_property_name, const std::string &amp;output_property_name, <a class="el" href="classkatana_1_1analytics_1_1SsspPlan.html">SsspPlan</a> plan={})</td></tr>
<tr class="memdesc:a0bc0a8af9131aec64fabbcda525ed31c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Single-Source Shortest Path for pg starting from start_node.  <a href="namespacekatana_1_1analytics.html#a0bc0a8af9131aec64fabbcda525ed31c">More...</a><br /></td></tr>
<tr class="separator:a0bc0a8af9131aec64fabbcda525ed31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8241ffa02d8ec80b0f34b039bd18685"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#ac8241ffa02d8ec80b0f34b039bd18685">SsspAssertValid</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *pg, size_t start_node, const std::string &amp;edge_weight_property_name, const std::string &amp;output_property_name)</td></tr>
<tr class="separator:ac8241ffa02d8ec80b0f34b039bd18685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab856433c113f8b982a51a344a6aa2ab6"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; std::unique_ptr&lt; <a class="el" href="classkatana_1_1PropertyGraph.html">katana::PropertyGraph</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#ab856433c113f8b982a51a344a6aa2ab6">SubGraphExtraction</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">katana::PropertyGraph</a> *pg, const std::vector&lt; <a class="el" href="classkatana_1_1PropertyGraph.html#a024869f2febb6abdeb3d068a3d14b53c">katana::PropertyGraph::Node</a> &gt; &amp;node_vec, <a class="el" href="classkatana_1_1analytics_1_1SubGraphExtractionPlan.html">SubGraphExtractionPlan</a> plan={})</td></tr>
<tr class="memdesc:ab856433c113f8b982a51a344a6aa2ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new sub-graph from the original graph.  <a href="namespacekatana_1_1analytics.html#ab856433c113f8b982a51a344a6aa2ab6">More...</a><br /></td></tr>
<tr class="separator:ab856433c113f8b982a51a344a6aa2ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24b475a6fef88db901164fedec60381"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#af24b475a6fef88db901164fedec60381">TriangleCount</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *pg, <a class="el" href="classkatana_1_1analytics_1_1TriangleCountPlan.html">TriangleCountPlan</a> plan={})</td></tr>
<tr class="memdesc:af24b475a6fef88db901164fedec60381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the total number of triangles in the graph.  <a href="namespacekatana_1_1analytics.html#af24b475a6fef88db901164fedec60381">More...</a><br /></td></tr>
<tr class="separator:af24b475a6fef88db901164fedec60381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95015cac207e65e391d506561ceec6a4"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#a95015cac207e65e391d506561ceec6a4">IsApproximateDegreeDistributionPowerLaw</a> (const <a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> &amp;graph)</td></tr>
<tr class="memdesc:a95015cac207e65e391d506561ceec6a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to determine if a graph has power-law degree distribution or not by sampling some of the vertices in the graph randomly This code has been copied from GAP benchmark suite (<a href="https://github.com/sbeamer/gapbs/blob/master/src/tc.cc">https://github.com/sbeamer/gapbs/blob/master/src/tc.cc</a> WorthRelabelling())  <a href="namespacekatana_1_1analytics.html#a95015cac207e65e391d506561ceec6a4">More...</a><br /></td></tr>
<tr class="separator:a95015cac207e65e391d506561ceec6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba5b98c995d502b2308aa1c775ac9cb"><td class="memTemplParams" colspan="2">template&lt;typename Props &gt; </td></tr>
<tr class="memitem:aeba5b98c995d502b2308aa1c775ac9cb"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#aeba5b98c995d502b2308aa1c775ac9cb">DefaultPropertyNames</a> ()</td></tr>
<tr class="separator:aeba5b98c995d502b2308aa1c775ac9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec2c91b74f1a42575f0e94a0b4ee886"><td class="memTemplParams" colspan="2">template&lt;typename NodeProps &gt; </td></tr>
<tr class="memitem:a3ec2c91b74f1a42575f0e94a0b4ee886"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#a3ec2c91b74f1a42575f0e94a0b4ee886">ConstructNodeProperties</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *pg, const std::vector&lt; std::string &gt; &amp;names=<a class="el" href="namespacekatana_1_1analytics.html#aeba5b98c995d502b2308aa1c775ac9cb">DefaultPropertyNames</a>&lt; NodeProps &gt;())</td></tr>
<tr class="separator:a3ec2c91b74f1a42575f0e94a0b4ee886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa003513d5bb5d8fdec93e3a575c15d40"><td class="memTemplParams" colspan="2">template&lt;typename EdgeProps &gt; </td></tr>
<tr class="memitem:aa003513d5bb5d8fdec93e3a575c15d40"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#aa003513d5bb5d8fdec93e3a575c15d40">ConstructEdgeProperties</a> (<a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *pg, const std::vector&lt; std::string &gt; &amp;names=<a class="el" href="namespacekatana_1_1analytics.html#aeba5b98c995d502b2308aa1c775ac9cb">DefaultPropertyNames</a>&lt; EdgeProps &gt;())</td></tr>
<tr class="separator:aa003513d5bb5d8fdec93e3a575c15d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aee075c32ae43c2b5e95358fb77629843"><td class="memItemLeft" align="right" valign="top">KATANA_EXPORT const <a class="el" href="namespacekatana_1_1analytics.html#ae50d59efc521345adc886403dc18c7de">BetweennessCentralitySources</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekatana_1_1analytics.html#aee075c32ae43c2b5e95358fb77629843">kBetweennessCentralityAllNodes</a></td></tr>
<tr class="memdesc:aee075c32ae43c2b5e95358fb77629843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use all sources instead of a subset.  <a href="namespacekatana_1_1analytics.html#aee075c32ae43c2b5e95358fb77629843">More...</a><br /></td></tr>
<tr class="separator:aee075c32ae43c2b5e95358fb77629843"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ae50d59efc521345adc886403dc18c7de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae50d59efc521345adc886403dc18c7de">&#9670;&nbsp;</a></span>BetweennessCentralitySources</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana_1_1analytics.html#ae50d59efc521345adc886403dc18c7de">katana::analytics::BetweennessCentralitySources</a> = typedef std::variant&lt;std::vector&lt;uint32_t&gt;, uint32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Either a vector of node IDs or a number of nodes to use as sources. </p>

</div>
</div>
<a id="aa7080d1f306b7d15f27e1d748920906e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7080d1f306b7d15f27e1d748920906e">&#9670;&nbsp;</a></span>CurrentCommunityId</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana_1_1analytics.html#aa7080d1f306b7d15f27e1d748920906e">katana::analytics::CurrentCommunityId</a> = typedef <a class="el" href="structkatana_1_1PODProperty.html">katana::PODProperty</a>&lt;uint64_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a87877f68912d2b62aaae8a82afcdafd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87877f68912d2b62aaae8a82afcdafd3">&#9670;&nbsp;</a></span>DegreeWeight</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EdgeWeightType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana_1_1analytics.html#a87877f68912d2b62aaae8a82afcdafd3">katana::analytics::DegreeWeight</a> = typedef <a class="el" href="structkatana_1_1PODProperty.html">katana::PODProperty</a>&lt;EdgeWeightType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab881d32255bbe4a19c4564e7df7c1e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab881d32255bbe4a19c4564e7df7c1e0">&#9670;&nbsp;</a></span>EdgeWeight</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EdgeWeightType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana_1_1analytics.html#aab881d32255bbe4a19c4564e7df7c1e0">katana::analytics::EdgeWeight</a> = typedef <a class="el" href="structkatana_1_1PODProperty.html">katana::PODProperty</a>&lt;EdgeWeightType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8026b912be30b3abc12ea48154cdcbc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8026b912be30b3abc12ea48154cdcbc0">&#9670;&nbsp;</a></span>JaccardSimilarity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana_1_1analytics.html#a8026b912be30b3abc12ea48154cdcbc0">katana::analytics::JaccardSimilarity</a> = typedef <a class="el" href="structkatana_1_1PODProperty.html">katana::PODProperty</a>&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The tag for the output property of Jaccard in PropertyGraphs. </p>

</div>
</div>
<a id="a03734437694019f4c0cda884fdef6bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03734437694019f4c0cda884fdef6bb1">&#9670;&nbsp;</a></span>PreviousCommunityId</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacekatana_1_1analytics.html#a03734437694019f4c0cda884fdef6bb1">katana::analytics::PreviousCommunityId</a> = typedef <a class="el" href="structkatana_1_1PODProperty.html">katana::PODProperty</a>&lt;uint64_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa930ba9d94d02e83368243aee3820363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa930ba9d94d02e83368243aee3820363">&#9670;&nbsp;</a></span>Architecture</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacekatana_1_1analytics.html#aa930ba9d94d02e83368243aee3820363">katana::analytics::Architecture</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa930ba9d94d02e83368243aee3820363a279ae61befa0f7a0d354dfc9878e5a47"></a>kCPU&#160;</td><td class="fielddoc"><p>Local execution using CPUs only. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa930ba9d94d02e83368243aee3820363a6582c44036c4ea26a95c767a4a95dd7f"></a>kGPU&#160;</td><td class="fielddoc"><p>Local execution using mostly GPUs. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa930ba9d94d02e83368243aee3820363ab1f37d0c864367a4e924b097371d7e5c"></a>kDistributedCPU&#160;</td><td class="fielddoc"><p>Distributed execution using CPUs. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa930ba9d94d02e83368243aee3820363a753939223cd69667e69ff1cedd1c958f"></a>kDistributedGPU&#160;</td><td class="fielddoc"><p>Distributed execution using GPUs. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a7639b799bdb08c48b441797944b35993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7639b799bdb08c48b441797944b35993">&#9670;&nbsp;</a></span>BetweennessCentrality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; void &gt; katana::analytics::BetweennessCentrality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">katana::PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output_property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacekatana_1_1analytics.html#ae50d59efc521345adc886403dc18c7de">BetweennessCentralitySources</a> &amp;&#160;</td>
          <td class="paramname"><em>sources</em> = <code><a class="el" href="namespacekatana_1_1analytics.html#aee075c32ae43c2b5e95358fb77629843">kBetweennessCentralityAllNodes</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkatana_1_1analytics_1_1BetweennessCentralityPlan.html">BetweennessCentralityPlan</a>&#160;</td>
          <td class="paramname"><em>plan</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the betweenness centrality of each node in the graph. </p>
<p>The property named output_property_name is created by this function and may not exist before the call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pg</td><td>The graph to process. </td></tr>
    <tr><td class="paramname">output_property_name</td><td>The parameter to create with the computed value. </td></tr>
    <tr><td class="paramname">sources</td><td>Only process some sources, producing an approximate betweenness centrality. If this is a vector process those source nodes; if this is an int process that number of source nodes. </td></tr>
    <tr><td class="paramname">plan</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0dfee34330fb2bf4f6d699d4cd93dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0dfee34330fb2bf4f6d699d4cd93dba">&#9670;&nbsp;</a></span>Bfs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; void &gt; katana::analytics::Bfs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">katana::PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output_property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkatana_1_1analytics_1_1BfsPlan.html">BfsPlan</a>&#160;</td>
          <td class="paramname"><em>algo</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute BFS level of nodes in the graph pg starting from start_node. </p>
<p>The result is stored in a property named by output_property_name. The plan controls the algorithm and parameters used to compute the BFS. The property named output_property_name is created by this function and may not exist before the call. </p>

</div>
</div>
<a id="aaaae12ace70cffe1c6d1244d8bb7ecb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaae12ace70cffe1c6d1244d8bb7ecb8">&#9670;&nbsp;</a></span>BfsAssertValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; void &gt; katana::analytics::BfsAssertValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do a quick validation of the results of a BFS computation where the results are stored in property_name. </p>
<p>This function does not do an exhaustive check. The results are approximate and may have false-negatives. </p><dl class="section return"><dt>Returns</dt><dd>a failure if the BFS results do not pass validation or if there is a failure during checking. </dd></dl>

</div>
</div>
<a id="acece1aec894ee366dabc793e8823a1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acece1aec894ee366dabc793e8823a1cf">&#9670;&nbsp;</a></span>ConnectedComponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; void &gt; katana::analytics::ConnectedComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output_property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkatana_1_1analytics_1_1ConnectedComponentsPlan.html">ConnectedComponentsPlan</a>&#160;</td>
          <td class="paramname"><em>plan</em> = <code><a class="el" href="classkatana_1_1analytics_1_1ConnectedComponentsPlan.html">ConnectedComponentsPlan</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Connected-components for pg. </p>
<p>The pg is expected to be symmetric. The algorithm, neighbor sample size and component sample frequency and tile size parameters can be specified, but have reasonable defaults. Not all parameters are used by the algorithms. The property named output_property_name is created by this function and may not exist before the call. </p>

</div>
</div>
<a id="a6b81f09a193902ef39e3754fb6688476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b81f09a193902ef39e3754fb6688476">&#9670;&nbsp;</a></span>ConnectedComponentsAssertValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; void &gt; katana::analytics::ConnectedComponentsAssertValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa003513d5bb5d8fdec93e3a575c15d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa003513d5bb5d8fdec93e3a575c15d40">&#9670;&nbsp;</a></span>ConstructEdgeProperties()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EdgeProps &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt;void&gt; katana::analytics::ConstructEdgeProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em> = <code><a class="el" href="namespacekatana_1_1analytics.html#aeba5b98c995d502b2308aa1c775ac9cb">DefaultPropertyNames</a>&lt;EdgeProps&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ec2c91b74f1a42575f0e94a0b4ee886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec2c91b74f1a42575f0e94a0b4ee886">&#9670;&nbsp;</a></span>ConstructNodeProperties()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeProps &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt;void&gt; katana::analytics::ConstructNodeProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em> = <code><a class="el" href="namespacekatana_1_1analytics.html#aeba5b98c995d502b2308aa1c775ac9cb">DefaultPropertyNames</a>&lt;NodeProps&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeba5b98c995d502b2308aa1c775ac9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba5b98c995d502b2308aa1c775ac9cb">&#9670;&nbsp;</a></span>DefaultPropertyNames()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Props &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; katana::analytics::DefaultPropertyNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7d7bac77fedbc9c6c894ea38781820f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d7bac77fedbc9c6c894ea38781820f">&#9670;&nbsp;</a></span>IndependentSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; void &gt; katana::analytics::IndependentSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">katana::PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output_property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkatana_1_1analytics_1_1IndependentSetPlan.html">IndependentSetPlan</a>&#160;</td>
          <td class="paramname"><em>plan</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a maximal (not the maximum) independent set in the graph and create an indicator property that is true for elements of the independent set. </p>
<p>The graph must be symmetric. The property named output_property_name is created by this function and may not exist before the call. The created property has type uint8_t. </p>

</div>
</div>
<a id="a688aeedd8a418b370fd0e40786e56919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688aeedd8a418b370fd0e40786e56919">&#9670;&nbsp;</a></span>IndependentSetAssertValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; void &gt; katana::analytics::IndependentSetAssertValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">katana::PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a95015cac207e65e391d506561ceec6a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95015cac207e65e391d506561ceec6a4">&#9670;&nbsp;</a></span>IsApproximateDegreeDistributionPowerLaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool katana::analytics::IsApproximateDegreeDistributionPowerLaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to determine if a graph has power-law degree distribution or not by sampling some of the vertices in the graph randomly This code has been copied from GAP benchmark suite (<a href="https://github.com/sbeamer/gapbs/blob/master/src/tc.cc">https://github.com/sbeamer/gapbs/blob/master/src/tc.cc</a> WorthRelabelling()) </p>

</div>
</div>
<a id="a2004489938a22963b5c4cc01492179b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2004489938a22963b5c4cc01492179b7">&#9670;&nbsp;</a></span>Jaccard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; void &gt; katana::analytics::Jaccard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>compare_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output_property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkatana_1_1analytics_1_1JaccardPlan.html">JaccardPlan</a>&#160;</td>
          <td class="paramname"><em>plan</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Jaccard similarity between each node and compare_node. </p>
<p>The result is stored in a property named by output_property_name. The plan controls the assumptions made about edge list ordering. The property named output_property_name is created by this function and may not exist before the call. </p>

</div>
</div>
<a id="a348b6e08fc56d2cec5425638c7f44238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348b6e08fc56d2cec5425638c7f44238">&#9670;&nbsp;</a></span>JaccardAssertValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; void &gt; katana::analytics::JaccardAssertValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">katana::PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>compare_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade8d23229b722a30e45f94e726ac55d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade8d23229b722a30e45f94e726ac55d1">&#9670;&nbsp;</a></span>KCore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; void &gt; katana::analytics::KCore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">katana::PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>k_core_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output_property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkatana_1_1analytics_1_1KCorePlan.html">KCorePlan</a>&#160;</td>
          <td class="paramname"><em>plan</em> = <code><a class="el" href="classkatana_1_1analytics_1_1KCorePlan.html">KCorePlan</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the k-core for pg. </p>
<p>The pg must be symmetric. The algorithm, and k_core_number parameters can be specified, but have reasonable defaults. The property named output_property_name is created by this function and may not exist before the call. </p>

</div>
</div>
<a id="a1bde64d08df2f783d7afa0ce667d56ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bde64d08df2f783d7afa0ce667d56ec">&#9670;&nbsp;</a></span>KCoreAssertValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt;void&gt; katana::analytics::KCoreAssertValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>k_core_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a833e4433c5a3f371da2bfd523ee07d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833e4433c5a3f371da2bfd523ee07d27">&#9670;&nbsp;</a></span>KTruss()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; void &gt; katana::analytics::KTruss </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">katana::PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>k_truss_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output_property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkatana_1_1analytics_1_1KTrussPlan.html">KTrussPlan</a>&#160;</td>
          <td class="paramname"><em>plan</em> = <code><a class="el" href="classkatana_1_1analytics_1_1KTrussPlan.html">KTrussPlan</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the k-truss for pg. </p>
<p>The pg is expected to be symmetric. The algorithm parameters can be specified, but have reasonable defaults. The property named output_property_name is created by this function and may not exist before the call.</p>
<dl class="section warning"><dt>Warning</dt><dd>This algorithm will reorder nodes and edges in the graph. </dd></dl>

</div>
</div>
<a id="a9a654f116e8c7458fb5a6f7d0b385a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a654f116e8c7458fb5a6f7d0b385a79">&#9670;&nbsp;</a></span>KTrussAssertValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt;void&gt; katana::analytics::KTrussAssertValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>k_truss_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a229b3504c8bbe09c93ff0f92a9da0975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229b3504c8bbe09c93ff0f92a9da0975">&#9670;&nbsp;</a></span>LocalClusteringCoefficient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; void &gt; katana::analytics::LocalClusteringCoefficient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">katana::PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output_property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkatana_1_1analytics_1_1LocalClusteringCoefficientPlan.html">LocalClusteringCoefficientPlan</a>&#160;</td>
          <td class="paramname"><em>plan</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the local clustering coefficient for each node in the graph. </p>
<p>The graph must be symmetric!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pg</td><td>The graph to process. </td></tr>
    <tr><td class="paramname">output_property_name</td><td>name of the output property </td></tr>
    <tr><td class="paramname">plan</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This algorithm will reorder nodes and edges in the graph. </dd></dl>

</div>
</div>
<a id="a58c829f08df32992b378ee01baa92751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c829f08df32992b378ee01baa92751">&#9670;&nbsp;</a></span>LouvainClustering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; void &gt; katana::analytics::LouvainClustering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">katana::PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>edge_weight_property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output_property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkatana_1_1analytics_1_1LouvainClusteringPlan.html">LouvainClusteringPlan</a>&#160;</td>
          <td class="paramname"><em>plan</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Louvain Clustering for pg. </p>
<p>The edge weights are taken from the property named edge_weight_property_name (which may be a 32- or 64-bit sign or unsigned int), and the computed cluster IDs are stored in the property named output_property_name (as uint32_t). The property named output_property_name is created by this function and may not exist before the call. </p>

</div>
</div>
<a id="a3a66e47c199bf183ff39a5cd2eff72a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a66e47c199bf183ff39a5cd2eff72a9">&#9670;&nbsp;</a></span>LouvainClusteringAssertValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt;void&gt; katana::analytics::LouvainClusteringAssertValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>edge_weight_property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output_property_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ec27a49483311a3facf97a799d9d6a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec27a49483311a3facf97a799d9d6a6">&#9670;&nbsp;</a></span>Pagerank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; void &gt; katana::analytics::Pagerank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">katana::PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output_property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkatana_1_1analytics_1_1PagerankPlan.html">PagerankPlan</a>&#160;</td>
          <td class="paramname"><em>plan</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Page Rank of each node in the graph. </p>
<p>The property named output_property_name is created by this function and may not exist before the call. </p>

</div>
</div>
<a id="ad8b148a44c8f7ab6c7674a7a3f79abec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b148a44c8f7ab6c7674a7a3f79abec">&#9670;&nbsp;</a></span>PagerankAssertValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt;void&gt; katana::analytics::PagerankAssertValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af6a246a13e7841d59218ec6bf18f1d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6a246a13e7841d59218ec6bf18f1d33">&#9670;&nbsp;</a></span>RandomWalks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; std::vector&lt; std::vector&lt; uint32_t &gt; &gt; &gt; katana::analytics::RandomWalks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkatana_1_1analytics_1_1RandomWalksPlan.html">RandomWalksPlan</a>&#160;</td>
          <td class="paramname"><em>plan</em> = <code><a class="el" href="classkatana_1_1analytics_1_1RandomWalksPlan.html">RandomWalksPlan</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the random-walks for pg. </p>
<p>The pg is expected to be symmetric. The parameters can be specified, but have reasonable defaults. Not all parameters are used by the algorithms. The generated random-walks generated are returned as a vector of vectors. </p>

</div>
</div>
<a id="a7646a1f8e62c356a14ccebb66bf828a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7646a1f8e62c356a14ccebb66bf828a1">&#9670;&nbsp;</a></span>RandomWalksAssertValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KATANA_EXPORT <a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">Result</a>&lt;void&gt; katana::analytics::RandomWalksAssertValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0bc0a8af9131aec64fabbcda525ed31c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc0a8af9131aec64fabbcda525ed31c">&#9670;&nbsp;</a></span>Sssp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; void &gt; katana::analytics::Sssp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>edge_weight_property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output_property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkatana_1_1analytics_1_1SsspPlan.html">SsspPlan</a>&#160;</td>
          <td class="paramname"><em>plan</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Single-Source Shortest Path for pg starting from start_node. </p>
<p>The edge weights are taken from the property named edge_weight_property_name (which may be a 32- or 64-bit sign or unsigned int), and the computed path lengths are stored in the property named output_property_name (as uint32_t). The algorithm and delta stepping parameter can be specified, but have reasonable defaults. The property named output_property_name is created by this function and may not exist before the call. </p>

</div>
</div>
<a id="ac8241ffa02d8ec80b0f34b039bd18685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8241ffa02d8ec80b0f34b039bd18685">&#9670;&nbsp;</a></span>SsspAssertValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; void &gt; katana::analytics::SsspAssertValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">katana::PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>edge_weight_property_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>output_property_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab856433c113f8b982a51a344a6aa2ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab856433c113f8b982a51a344a6aa2ab6">&#9670;&nbsp;</a></span>SubGraphExtraction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; std::unique_ptr&lt; <a class="el" href="classkatana_1_1PropertyGraph.html">katana::PropertyGraph</a> &gt; &gt; katana::analytics::SubGraphExtraction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">katana::PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classkatana_1_1PropertyGraph.html#a024869f2febb6abdeb3d068a3d14b53c">katana::PropertyGraph::Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkatana_1_1analytics_1_1SubGraphExtractionPlan.html">SubGraphExtractionPlan</a>&#160;</td>
          <td class="paramname"><em>plan</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new sub-graph from the original graph. </p>
<p>By default only topology of the sub-graph is constructed. The new sub-graph is independent of the original graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pg</td><td>The graph to process. </td></tr>
    <tr><td class="paramname">node_vec</td><td>Set of node IDs </td></tr>
    <tr><td class="paramname">plan</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af24b475a6fef88db901164fedec60381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24b475a6fef88db901164fedec60381">&#9670;&nbsp;</a></span>TriangleCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacekatana.html#a7ef5f54fe30dfc7b2cf9294ac744d6bb">katana::Result</a>&lt; uint64_t &gt; katana::analytics::TriangleCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkatana_1_1PropertyGraph.html">katana::PropertyGraph</a> *&#160;</td>
          <td class="paramname"><em>pg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkatana_1_1analytics_1_1TriangleCountPlan.html">TriangleCountPlan</a>&#160;</td>
          <td class="paramname"><em>plan</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the total number of triangles in the graph. </p>
<p>The graph must be symmetric!</p>
<p>This algorithm copies the graph internally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pg</td><td>The graph to process. </td></tr>
    <tr><td class="paramname">plan</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aee075c32ae43c2b5e95358fb77629843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee075c32ae43c2b5e95358fb77629843">&#9670;&nbsp;</a></span>kBetweennessCentralityAllNodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacekatana_1_1analytics.html#ae50d59efc521345adc886403dc18c7de">BetweennessCentralitySources</a> katana::analytics::kBetweennessCentralityAllNodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        std::numeric_limits&lt;uint32_t&gt;::max()</div>
</div><!-- fragment -->
<p>Use all sources instead of a subset. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacekatana.html">katana</a></li><li class="navelem"><a class="el" href="namespacekatana_1_1analytics.html">analytics</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
