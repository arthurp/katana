<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Katana: Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Katana
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('tutorial.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#goal_tutorial">Goal of this Tutorial</a></li>
<li class="level1"><a href="#katana_program">Galois Programs</a><ul><li class="level2"><a href="#execution_model">Execution Model</a></li>
<li class="level2"><a href="#structure_overview">Structure Overview</a></li>
</ul>
</li>
<li class="level1"><a href="#katana_lc_graphs">Parallel Data Structures</a><ul><li class="level2"><a href="#katana_ds_graphs">Graphs</a></li>
<li class="level2"><a href="#katana_ds_others">Other Data Structures</a></li>
</ul>
</li>
<li class="level1"><a href="#katana_parallel_loop">Parallel Loop Iterators</a><ul><li class="level2"><a href="#katana_do_all">katana::do_all</a><ul><li class="level3"><a href="#work_in_do_all">Work Distribution in katana::do_all</a></li>
</ul>
</li>
<li class="level2"><a href="#katana_for_each">katana::for_each</a></li>
</ul>
</li>
<li class="level1"><a href="#katana_worklists">Worklists and Schedules</a><ul><li class="level2"><a href="#katana_deterministic_iterator">Deterministic Loop Iterator</a></li>
<li class="level2"><a href="#katana_parameter_iterator">ParaMeter Loop Iterator</a></li>
</ul>
</li>
<li class="level1"><a href="#example_output">Example Output of Galois Apps</a></li>
<li class="level1"><a href="#katana_morph_graph_api">MorphGraph APIs</a></li>
<li class="level1"><a href="#tuning_guides">Tuning Guides</a></li>
<li class="level1"><a href="#tutorial_conclusion">Concluding Remarks</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="goal_tutorial"></a>
Goal of this Tutorial</h1>
<p>This tutorial is targeted to people who want to start writing Galois programs on shared memory, which are legal C++ parallel programs. It assumes that readers are familiar with C++ and have some knowledge about parallel programming.</p>
<p>The following topics are outside the scope of this tutorial: </p><ol>
<li>
Performance programming in Galois, such as optimizing for non-uniform memory access (NUMA). However, there will be some discussion on this at the end of the tutorial. </li>
<li>
Extending Galois such as implementing new parallel data structures, schedulers or parallelism patterns. </li>
<li>
Distributed programming with D-Galois, which includes Gluon communication substrate, CuSP graph partitioner, etc. </li>
</ol>
<h1><a class="anchor" id="katana_program"></a>
Galois Programs</h1>
<h2><a class="anchor" id="execution_model"></a>
Execution Model</h2>
<p>A Galois program alternates its execution in between serial and parallel phases. The execution begins serially on the master thread, whose thread ID is 0. Other threads wait in a "sleep" state in <a class="el" href="classkatana_1_1ThreadPool.html">katana::ThreadPool</a>, which is created by <a class="el" href="classkatana_1_1SharedMemSys.html" title="SharedMemSys initializes the Galois library for shared memory.">katana::SharedMemSys</a>. Upon encountering a parallel section, the Galois runtime wakes up the threads in cascade, and hands each thread a work function. Threads synchronize at a barrier at the end of the parallel section. In the current implementation, parallel sections are loops and work items are iterations of that loop. This is summarized in the following figure.</p>
<div class="image">
<img src="katana_execution_model.png" alt=""/>
<div class="caption">
Galois Execution Model</div></div>
<p>Galois is different from other models in the following two ways: </p><ol>
<li>
Parallel work may or may not be independent; the implementation guarantees transactional execution of each work item (iteration). </li>
<li>
Parallel sections may create and execute new work items. For example, computing single-source shortest path will create new work items if nodes' distances are lowered. </li>
</ol>
<h2><a class="anchor" id="structure_overview"></a>
Structure Overview</h2>
<p>A Galois user program consists of operators, schedules and data structure API calls. The Galois library implements schedulers and data structures, which are built upon thread primitives and memory allocators. This is summarized by the following figure.</p>
<p> 
<style>div.image img[src="katana_program_structure.png"]{width:70%}</style>
 </p><div class="image">
<img src="katana_program_structure.png" alt=""/>
<div class="caption">
Structure of a Galois Program</div></div>
<blockquote class="doxtable">
<p><b>Note:</b> <a class="el" href="classkatana_1_1SharedMemSys.html" title="SharedMemSys initializes the Galois library for shared memory.">katana::SharedMemSys</a> must be declared and constructed before any other Galois features can be used, since it creates <a class="el" href="classkatana_1_1ThreadPool.html">katana::ThreadPool</a> and other runtime structures on which several Galois features depend. </p>
</blockquote>
<p> 
<table class="doxtable"><tbody>
<tr><th align="left"> Running Example </th></tr>
<tr><td align="left">
</p>
<p>Throughout this tutorial, we will use the following application as our running example: <code>read in an undirected graph with edge weights and then set the label of each node to the sum of the weights on the edges connected to the node.</code> There are two ways to implement this application:</p>
<ul>
<li>If it is implemented as a <em>pull</em>-style algorithm, each node iterates over its edges and computes its own label; there are no conflicts among activities at different nodes.</li>
<li>If it is implemented as a <em>push</em>-style algorithm, each node iterates over its edges and for each edge, the node updates the weight of the destination node; therefore, activities may conflict with each other.</li>
</ul>
<p>Both variants iterate over all nodes, so they are <em>topology-driven</em> algorithms.</p>
<p> 
</td></tr><tbody></table>
</p>
<p>Below we will cover parallel data structures, parallel loop iterators, and worklists and schedules.</p>
<h1><a class="anchor" id="katana_lc_graphs"></a>
Parallel Data Structures</h1>
<p>For graph computation, Galois provides unified, standard APIs to access graph elements and a set of graph implementations optimized for NUMA-awareness, conflict detection, and interoperability with the Galois runtime system. For details, see <a class="el" href="concurrent_data_structures.html">Concurrent Data Structures</a>.</p>
<h2><a class="anchor" id="katana_ds_graphs"></a>
Graphs</h2>
<p>All graphs are in the namespace katana. There are two basic types of graphs: </p><ol>
<li>
<a class="el" href="classkatana_1_1MorphGraph.html" title="A graph that can have new nodes and edges added to it.">katana::MorphGraph</a>: It allows insertion and removal of nodes and edges. It is used in morph algorithms like Delaunay mesh refinement. A variation called <a class="el" href="classkatana_1_1LC__Morph__Graph.html" title="Local computation graph that allows addition of nodes (but not removals) if the maximum degree of a n...">katana::LC_Morph_Graph</a> can be used if (1) no nodes will be deleted, and (2) a node's maximum degree is known when it is created. </li>
<li>
<a class="el" href="classkatana_1_1LC__CSR__Graph.html" title="Local computation graph (i.e., graph structure does not change).">katana::LC_CSR_Graph</a>: It disallows creation and removal of nodes and edges. Internally, it is implemented in Compressed Sparse Row (CSR) format as shown in the following figure. Undirected edges are represented as two directed edges. Galois also provides variants of this graph with different storage representations, e.g., <a class="el" href="classkatana_1_1LC__InlineEdge__Graph.html" title="Local computation graph (i.e., graph structure does not change).">katana::LC_InlineEdge_Graph</a>, <a class="el" href="classkatana_1_1LC__Linear__Graph.html" title="Local computation graph (i.e., graph structure does not change).">katana::LC_Linear_Graph</a>, <a class="el" href="classkatana_1_1LC__InOut__Graph.html" title="Modify a LC_Graph to have in and out edges.">katana::LC_InOut_Graph</a>. </li>
</ol>
<p> 
<style>div.image img[src="csr_format_example.png"]{width:70%}</style>
 </p><div class="image">
<img src="csr_format_example.png" alt=""/>
<div class="caption">
Graph in CSR Format. Left: graphic representation, where numbers in circles (nodes) are node IDs and numbers on arrows (directed edges) are edge weights. Right: CSR representation, which comprises of 4 arrays - Node data, indexed by node IDs, stores data labels of each node; Edge index, indexed by (source) node IDs, stores indices of the first corresponding edges; Edge destination, indexed by edge IDs (chunked in the sequence of node IDs), stores the corresponding (destination) node IDs; Edge data, indexed by edge IDs, stores edge labels (weights in this example) of each edge.</div></div>
<p>We will focus on <a class="el" href="classkatana_1_1LC__CSR__Graph.html" title="Local computation graph (i.e., graph structure does not change).">katana::LC_CSR_Graph</a> in this section; <a class="el" href="tutorial.html#katana_morph_graph_api">MorphGraph APIs</a> are discussed later. When defining a <a class="el" href="classkatana_1_1LC__CSR__Graph.html" title="Local computation graph (i.e., graph structure does not change).">katana::LC_CSR_Graph</a>, you must provide as template parameters <code>NodeTy</code>, the type of data stored on each node, and <code>EdgeTy</code>, the type of data stored on each edge. Use <code>void</code> when no data needs to be stored on nodes or edges. See <a class="el" href="classkatana_1_1LC__CSR__Graph.html" title="Local computation graph (i.e., graph structure does not change).">katana::LC_CSR_Graph</a> for other optional template parameters.</p>
<p>Below is an example of defining an LC_CSR_Graph with <code>int</code> as both its node data type and edge data type:</p>
<div class="fragment"><div class="line">  <span class="comment">// An LC_CSR_Graph whose node data type is int and edge data type is int</span></div>
<div class="line">  <span class="keyword">using</span> <a class="code" href="classkatana_1_1TypedPropertyGraph.html">Graph</a> = <a class="code" href="classkatana_1_1LC__CSR__Graph.html">katana::LC_CSR_Graph&lt;int, int&gt;</a>;</div>
<div class="ttc" id="aclasskatana_1_1LC__CSR__Graph_html"><div class="ttname"><a href="classkatana_1_1LC__CSR__Graph.html">katana::LC_CSR_Graph</a></div><div class="ttdoc">Local computation graph (i.e., graph structure does not change).</div><div class="ttdef"><b>Definition:</b> LC_CSR_Graph.h:61</div></div>
<div class="ttc" id="aclasskatana_1_1TypedPropertyGraph_html"><div class="ttname"><a href="classkatana_1_1TypedPropertyGraph.html">katana::TypedPropertyGraph</a></div><div class="ttdoc">A property graph is a graph that has properties associated with its nodes and edges.</div><div class="ttdef"><b>Definition:</b> TypedPropertyGraph.h:33</div></div>
</div><!-- fragment --><p> The following code snippet shows how to instantiate and read in a graph from a file (in binary .gr format):</p>
<div class="fragment"><div class="line">  <a class="code" href="classkatana_1_1TypedPropertyGraph.html">Graph</a> g;</div>
<div class="line">  <a class="code" href="namespacekatana.html#acceb3be91f6608eb0b91434f86f883ce">katana::readGraph</a>(g, argv[1]);  <span class="comment">// argv[1] is the file name for graph</span></div>
<div class="ttc" id="anamespacekatana_html_acceb3be91f6608eb0b91434f86f883ce"><div class="ttname"><a href="namespacekatana.html#acceb3be91f6608eb0b91434f86f883ce">katana::readGraph</a></div><div class="ttdeci">void readGraph(GraphTy &amp;graph, Args &amp;&amp;... args)</div><div class="ttdoc">Allocates and constructs a graph from a file.</div><div class="ttdef"><b>Definition:</b> ReadGraph.h:38</div></div>
</div><!-- fragment --><p> To access graph elements, use the following constructs: </p><ul>
<li>
<b>To iterate over nodes:</b> use the node iterator <a class="el" href="classkatana_1_1LC__CSR__Graph.html#a9a2fe97428fa80c5b4fbb8ab1812a51f">katana::LC_CSR_Graph::iterator</a> given by <a class="el" href="classkatana_1_1LC__CSR__Graph.html#a92934b1f446615caf918dec82bdffe5a">katana::LC_CSR_Graph::begin</a> and <a class="el" href="classkatana_1_1LC__CSR__Graph.html#a311e04c14a042cb9f4ae344b9a68d546">katana::LC_CSR_Graph::end</a>. </li>
<li>
<b>To iterate over outgoing edges of a node:</b> use the edge iterator <a class="el" href="classkatana_1_1LC__CSR__Graph.html#a40b9a2b53054c133a9f34e4ed892348d">katana::LC_CSR_Graph::edge_iterator</a> given by <a class="el" href="classkatana_1_1LC__CSR__Graph.html#a53081da2ffde97790ddcb85399e207d5">katana::LC_CSR_Graph::edge_begin</a> and <a class="el" href="classkatana_1_1LC__CSR__Graph.html#aa02ca335c90b8cd32b45ee84525a3bac">katana::LC_CSR_Graph::edge_end</a>. </li>
<li>
<b>To access the data of a node:</b> use <a class="el" href="classkatana_1_1LC__CSR__Graph.html#a8fdc3222a3ef4c4110fe7a64067bdb8e">katana::LC_CSR_Graph::getData</a>. </li>
<li>
<b>To access the data of an edge:</b> use <a class="el" href="classkatana_1_1LC__CSR__Graph.html#aa444831162fd4eaf8de80167ef7d29d6">katana::LC_CSR_Graph::getEdgeData</a>. </li>
<li>
<b>To obtain the destination node of an outgoing edge:</b> use <a class="el" href="classkatana_1_1LC__CSR__Graph.html#a43b47e1802691f4ddb30686ccb1f44bc">katana::LC_CSR_Graph::getEdgeDst</a>. </li>
</ul>
<p>For details, see <a class="el" href="concurrent_data_structures.html#katana_graphs">Parallel Graphs</a>.</p>
<p> 
<table class="doxtable"><tbody>
<tr><th align="left"> Running Example </th></tr>
<tr><td align="left">
</p>
<p>The following code is a serial implementation of our running example. It is a <em>pull</em>-style example: iterate through all nodes, and for each node, add all outgoing edges' weights to the node data. (This example is written in C++11 to avoid mentioning node iterators and edge iterators explicitly.)</p>
<div class="fragment"><div class="line">  <span class="comment">// iterate over nodes</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> n : g) {</div>
<div class="line">    <span class="keyword">auto</span>&amp; sum = g.getData(n);  <span class="comment">// get node data of n</span></div>
<div class="line">    sum = 0;</div>
<div class="line">    <span class="comment">// iterate over edges from node n</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : g.edges(n)) {</div>
<div class="line">      sum += g.getEdgeData(e);  <span class="comment">// get edge data of e</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
</div><!-- fragment --><p> The full example is available as <a class="el" href="lonestar_2tutorial_examples_2GraphTraversalSerial_8cpp-example.html">lonestar/tutorial_examples/GraphTraversalSerial.cpp</a>.</p>
<p> 
</td></tr><tbody></table>
</p>
<h2><a class="anchor" id="katana_ds_others"></a>
Other Data Structures</h2>
<p>Other data structures available in Galois include:</p>
<ul>
<li><a class="el" href="classkatana_1_1InsertBag.html" title="Unordered collection of elements.">katana::InsertBag</a>, an unordered bag allowing thread-safe concurrent insertion (see <a class="el" href="concurrent_data_structures.html#insert_bag">Insert Bag</a>);</li>
<li><a class="el" href="classkatana_1_1Reducible.html" title="A Reducible stores per-thread values of a variable of type T and merges multiple values into one.">katana::Reducible</a>, a template for reduction operations (see <a class="el" href="reduction.html">Reduction Operations</a>).</li>
</ul>
<h1><a class="anchor" id="katana_parallel_loop"></a>
Parallel Loop Iterators</h1>
<p>We will focus on <a class="el" href="namespacekatana.html#ab9ea3b9de54b0c2f223eb585f4aefaff" title="Standard do-all loop.">katana::do_all</a> and <a class="el" href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81" title="Galois unordered set iterator.">katana::for_each</a> in this section. For more information, see <a class="el" href="parallel_loops.html">Parallel Loops</a>.</p>
<h2><a class="anchor" id="katana_do_all"></a>
katana::do_all</h2>
<p><a class="el" href="namespacekatana.html#ab9ea3b9de54b0c2f223eb585f4aefaff" title="Standard do-all loop.">katana::do_all</a> partitions the work items evenly among threads, and each thread performs work independently. It turns off conflict detection and assumes no new work items are created. Work stealing can be turned on to achieve load balance among threads. Example usages of <a class="el" href="namespacekatana.html#ab9ea3b9de54b0c2f223eb585f4aefaff" title="Standard do-all loop.">katana::do_all</a> are topology-driven algorithms iterating over nodes in a graph; and bags with independent work items, e.g. subset of nodes in a graph.</p>
<p>Specifically, <a class="el" href="namespacekatana.html#ab9ea3b9de54b0c2f223eb585f4aefaff" title="Standard do-all loop.">katana::do_all</a> expects the following inputs: </p><ol>
<li>
Range as <a class="el" href="namespacekatana.html#a664a7f49a65e22807577f6cc809a7827" title="Iterate returns a specialized range object for various container-like objects:">katana::iterate</a>, which takes one of the following parameters: <ul>
<li>
Pair of iterators for begin() and end() </li>
<li>
Pair of unsigned integers for begin and end </li>
<li>
Initializer list </li>
<li>
Container inside which a well-defined iterator is implemented </li>
</ul>
</li>
<li>
Operator, which can be specified as a lambda expression, function object (functor) or function pointer. Using a lambda expression is recommended. </li>
<li>
Options to turn on/off some features. <ul>
<li>
<a class="el" href="structkatana_1_1steal.html">katana::steal</a> to turn on work stealing </li>
<li>
<a class="el" href="structkatana_1_1chunk__size.html" title="Specify chunk size for do_all_coupled &amp; do_all_choice at compile time or at runtime.">katana::chunk_size</a> for the unit of work stealing. Chunk size is 32 by default. </li>
<li>
<a class="el" href="structkatana_1_1loopname.html">katana::loopname</a> to turn on the collection of statistics associated with the do_all loop, e.g. execution time in milliseconds, number of iterations executed. </li>
</ul>
</li>
</ol>
<p> 
<table class="doxtable"><tbody>
<tr><th align="left"> Running Example </th></tr>
<tr><td align="left">
</p>
<p>Below is the example of parallelizing our running example with a pull-style operator using <a class="el" href="namespacekatana.html#ab9ea3b9de54b0c2f223eb585f4aefaff" title="Standard do-all loop.">katana::do_all</a>. Note that the range for this do_all call is exactly the outer loop range in the serial implementation and that the operator is exactly the body of the outer loop in our serial implementation.</p>
<div class="fragment"><div class="line">  <a class="code" href="namespacekatana.html#ab9ea3b9de54b0c2f223eb585f4aefaff">katana::do_all</a>(</div>
<div class="line">      <a class="code" href="namespacekatana.html#a664a7f49a65e22807577f6cc809a7827">katana::iterate</a>(g.begin(), g.end()),  <span class="comment">// range</span></div>
<div class="line">      [&amp;](<a class="code" href="jaccard_8cpp.html#ac56cf62167e787bf1a4ff1e5b529e0b0">GNode</a> n) {                        <span class="comment">// operator</span></div>
<div class="line">        auto&amp; sum = g.getData(n);</div>
<div class="line">        sum = 0;</div>
<div class="line">        for (auto e : g.edges(n)) {</div>
<div class="line">          sum += g.getEdgeData(e);</div>
<div class="line">        }</div>
<div class="line">      },</div>
<div class="line">      <a class="code" href="structkatana_1_1loopname.html">katana::loopname</a>(<span class="stringliteral">&quot;sum_in_do_all_with_lambda&quot;</span>)  <span class="comment">// options</span></div>
<div class="line">  );</div>
<div class="ttc" id="ajaccard_8cpp_html_ac56cf62167e787bf1a4ff1e5b529e0b0"><div class="ttname"><a href="jaccard_8cpp.html#ac56cf62167e787bf1a4ff1e5b529e0b0">GNode</a></div><div class="ttdeci">Graph::Node GNode</div><div class="ttdef"><b>Definition:</b> jaccard.cpp:31</div></div>
<div class="ttc" id="anamespacekatana_html_a664a7f49a65e22807577f6cc809a7827"><div class="ttname"><a href="namespacekatana.html#a664a7f49a65e22807577f6cc809a7827">katana::iterate</a></div><div class="ttdeci">auto iterate(T &amp;container)</div><div class="ttdoc">Iterate returns a specialized range object for various container-like objects:</div><div class="ttdef"><b>Definition:</b> Range.h:296</div></div>
<div class="ttc" id="anamespacekatana_html_ab9ea3b9de54b0c2f223eb585f4aefaff"><div class="ttname"><a href="namespacekatana.html#ab9ea3b9de54b0c2f223eb585f4aefaff">katana::do_all</a></div><div class="ttdeci">void do_all(const Range &amp;range, FunctionTy &amp;&amp;fn, Args &amp;&amp;... args)</div><div class="ttdoc">Standard do-all loop.</div><div class="ttdef"><b>Definition:</b> Loops.h:69</div></div>
<div class="ttc" id="astructkatana_1_1loopname_html"><div class="ttname"><a href="structkatana_1_1loopname.html">katana::loopname</a></div><div class="ttdef"><b>Definition:</b> Traits.h:211</div></div>
</div><!-- fragment --><p> The full example is available as <a class="el" href="lonestar_2tutorial_examples_2GraphTraversalPullOperator_8cpp-example.html">lonestar/tutorial_examples/GraphTraversalPullOperator.cpp</a>.</p>
<p> 
</td></tr><tbody></table>
</p>
<p> 
<blockquote class="doxtable">
</p>
<h3><a class="anchor" id="work_in_do_all"></a>
Work Distribution in katana::do_all</h3>
<p>How work is divided among threads in <a class="el" href="namespacekatana.html#ab9ea3b9de54b0c2f223eb585f4aefaff" title="Standard do-all loop.">katana::do_all</a> depends on whether work stealing is turned on. If work stealing is turned off, then the range is partitioned evenly among threads, and each thread works on its own partition independently. If work stealing is turned on, the work range is partitioned into chunks of N iterations where N is the chunk size. Each thread is then assigned an initial set of chunks and starts working from the beginning of the set. If a thread finishes its own chunks but other threads are still working on theirs, it will steal chunks from another thread's end of set of chunks.</p>
<p> 
</blockquote>
</p>
<h2><a class="anchor" id="katana_for_each"></a>
katana::for_each</h2>
<p><a class="el" href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81" title="Galois unordered set iterator.">katana::for_each</a> can be used for parallel iterations that may generate new work items and that may have conflicts among iterations. Operators must be cautious: All locks should be acquired successfully before the first write to user state (see <a class="el" href="classkatana_1_1SimpleRuntimeContext.html#a76ce818b3c75b9a84bc6485db5fd4765">katana::SimpleRuntimeContext::acquire</a>). Optional features for <a class="el" href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81" title="Galois unordered set iterator.">katana::for_each</a> include (1) turning off conflict detection, (2) asserting that no new work items will be created, and (3) specifying a desired schedule for processing active elements. <a class="el" href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81" title="Galois unordered set iterator.">katana::for_each</a> is suitable to implement <em>push</em>-style algorithms.</p>
<p><a class="el" href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81" title="Galois unordered set iterator.">katana::for_each</a> uses <a class="el" href="classkatana_1_1UserContext.html" title="This is the object passed to the user&#39;s parallel loop.">katana::UserContext</a>, a per-thread object, to track conflicts and new work. To insert new work items into the worklist, call <a class="el" href="classkatana_1_1UserContext.html#a760db471e9c011dd2962a4833552c76b" title="Push new work.">katana::UserContext::push</a>. To detect conflicts, <a class="el" href="classkatana_1_1UserContext.html" title="This is the object passed to the user&#39;s parallel loop.">katana::UserContext</a> maintains a linked list of acquired items. Each sharable object, e.g. graph nodes, has a lock, which is automatically acquired when getData(), edge_begin(), edge_end(), edges(), etc. are called. A conflict is detected by the Galois runtime when the lock acquisition fails. Locks are released when aborting or finishing an iteration. Since Galois assumes cautious operators, i.e. no writes to user state before acquiring all locks, there is no need to rollback user state when aborting an iteration.</p>
<p><a class="el" href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81" title="Galois unordered set iterator.">katana::for_each</a> expects the following inputs: </p><ol>
<li>
Range as <a class="el" href="namespacekatana.html#a664a7f49a65e22807577f6cc809a7827" title="Iterate returns a specialized range object for various container-like objects:">katana::iterate</a>, which takes one of the following parameters: <ul>
<li>
Pair of iterators for begin() and end() </li>
<li>
Pair of unsigned integers for begin and end </li>
<li>
Initializer list </li>
<li>
Container inside which a well-defined iterator is implemented </li>
</ul>
</li>
<li>
Operator, which can be specified as a lambda expression, function object (functor) or function pointer. Using a lambda expression is recommended. </li>
<li>
Options to turn on/off some features. <ul>
<li>
<a class="el" href="structkatana_1_1loopname.html">katana::loopname</a> to turn on the collection of statistics associated with the for_each loop, e.g. execution time in milliseconds; number of iterations executed, pushed, aborted and committed; etc. </li>
<li>
<a class="el" href="structkatana_1_1no__pushes.html">katana::no_pushes</a> when no new work items will be generated. </li>
<li>
<a class="el" href="structkatana_1_1disable__conflict__detection.html">katana::disable_conflict_detection</a> to turn off conflict detection. </li>
<li>
<a class="el" href="namespacekatana.html#a0a996c85bab3fdbf1afad32e8595db32">katana::wl</a> to specify the schedule to use. </li>
</ul>
</li>
</ol>
<p> 
<table class="doxtable"><tbody>
<tr><th align="left"> Running Example </th></tr>
<tr><td align="left">
</p>
<p>Below is the code snippet of using <a class="el" href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81" title="Galois unordered set iterator.">katana::for_each</a> with conflict detection to implement our running example. It uses a push-style algorithm: Each node adds each of its edge's weight to the corresponding neighbor. Note that the operator code is written as in sequential code; and that the operator expects auto&amp; ctx, a reference to <a class="el" href="classkatana_1_1UserContext.html" title="This is the object passed to the user&#39;s parallel loop.">katana::UserContext</a>.</p>
<div class="fragment"><div class="line">  <span class="comment">//******************************************************</span></div>
<div class="line">  <span class="comment">// parallel traversal over a graph using katana::for_each</span></div>
<div class="line">  <span class="comment">// 1. push operator is specified using lambda expression</span></div>
<div class="line">  <span class="comment">// 2. for_each is named &quot;sum_in_for_each_with_push_operator&quot; to show stat</span></div>
<div class="line">  <span class="comment">// after this program finishes</span></div>
<div class="line">  initialize(g);</div>
<div class="line">  <a class="code" href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81">katana::for_each</a>(</div>
<div class="line">      <a class="code" href="namespacekatana.html#a664a7f49a65e22807577f6cc809a7827">katana::iterate</a>(g.begin(), g.end()),  <span class="comment">// range</span></div>
<div class="line">      [&amp;](<a class="code" href="jaccard_8cpp.html#ac56cf62167e787bf1a4ff1e5b529e0b0">GNode</a> n, <span class="keyword">auto</span>&amp;) {                 <span class="comment">// operator</span></div>
<div class="line">        for (auto e : g.edges(n)) {         <span class="comment">// cautious point</span></div>
<div class="line">          auto dst = g.getEdgeDst(e);</div>
<div class="line">          g.getData(dst) += g.getEdgeData(e);</div>
<div class="line">        }</div>
<div class="line">      },</div>
<div class="line">      <a class="code" href="structkatana_1_1loopname.html">katana::loopname</a>(<span class="stringliteral">&quot;sum_in_for_each_with_push_operator&quot;</span>)  <span class="comment">// options</span></div>
<div class="line">  );</div>
<div class="ttc" id="anamespacekatana_html_a2eb855d38b5753d67def813f9a7edb81"><div class="ttname"><a href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81">katana::for_each</a></div><div class="ttdeci">void for_each(const Range &amp;range, FunctionTy &amp;&amp;fn, Args &amp;&amp;... args)</div><div class="ttdoc">Galois unordered set iterator.</div><div class="ttdef"><b>Definition:</b> Loops.h:52</div></div>
</div><!-- fragment --><p> The code snippet below shows how to let an operator, instead of <a class="el" href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81" title="Galois unordered set iterator.">katana::for_each</a>, take care of synchronization. Conflict detection is turned off in this case. Since there is no new work generated and the operator synchronizes node data, the same code can be implemented with <a class="el" href="namespacekatana.html#ab9ea3b9de54b0c2f223eb585f4aefaff" title="Standard do-all loop.">katana::do_all</a> as well, which is also shown in this example.</p>
<div class="fragment"><div class="line">  <span class="comment">// define lambda expression as a varible for reuse</span></div>
<div class="line">  <span class="keyword">auto</span> sumEdgeWeightsAtomically = [&amp;](<a class="code" href="jaccard_8cpp.html#ac56cf62167e787bf1a4ff1e5b529e0b0">GNode</a> n) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : g.edges(n)) {</div>
<div class="line">      <span class="keyword">auto</span> dst = g.getEdgeDst(e);</div>
<div class="line">      <span class="keyword">auto</span>&amp; dstData = g.getData(dst);</div>
<div class="line">      <span class="keyword">auto</span> edgeWeight = g.getEdgeData(e);</div>
<div class="line">      __sync_fetch_and_add(&amp;dstData, edgeWeight);</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//******************************************************</span></div>
<div class="line">  <span class="comment">// parallel traversal over a graph using katana::do_all w/o work stealing</span></div>
<div class="line">  <span class="comment">// 1. push operator uses atomic intrinsic</span></div>
<div class="line">  <span class="comment">// 2. do_all is named &quot;sum_in_do_all_with_push_atomic&quot; to show stat after this</span></div>
<div class="line">  <span class="comment">// program finishes</span></div>
<div class="line">  initialize(g);</div>
<div class="line">  <a class="code" href="namespacekatana.html#ab9ea3b9de54b0c2f223eb585f4aefaff">katana::do_all</a>(</div>
<div class="line">      <a class="code" href="namespacekatana.html#a664a7f49a65e22807577f6cc809a7827">katana::iterate</a>(g.begin(), g.end()),  <span class="comment">// range</span></div>
<div class="line">      sumEdgeWeightsAtomically              <span class="comment">// operator</span></div>
<div class="line">      ,</div>
<div class="line">      <a class="code" href="structkatana_1_1loopname.html">katana::loopname</a>(<span class="stringliteral">&quot;sum_in_do_all_with_push_atomic&quot;</span>)  <span class="comment">// options</span></div>
<div class="line">  );</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//******************************************************</span></div>
<div class="line">  <span class="comment">// parallel traversal over a graph using katana::for_each</span></div>
<div class="line">  <span class="comment">// 1. push operator uses atomic intrinsic</span></div>
<div class="line">  <span class="comment">// 2. for_each is named &quot;sum_in_do_for_each_with_push_atomic&quot; to show stat</span></div>
<div class="line">  <span class="comment">// after this program finishes</span></div>
<div class="line">  initialize(g);</div>
<div class="line">  <a class="code" href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81">katana::for_each</a>(</div>
<div class="line">      <a class="code" href="namespacekatana.html#a664a7f49a65e22807577f6cc809a7827">katana::iterate</a>(g.begin(), g.end()),                  <span class="comment">// range</span></div>
<div class="line">      [&amp;](<a class="code" href="jaccard_8cpp.html#ac56cf62167e787bf1a4ff1e5b529e0b0">GNode</a> n, <span class="keyword">auto</span>&amp;) { sumEdgeWeightsAtomically(n); }  <span class="comment">// operator</span></div>
<div class="line">      ,</div>
<div class="line">      <a class="code" href="structkatana_1_1loopname.html">katana::loopname</a>(<span class="stringliteral">&quot;sum_in_for_each_with_push_atomic&quot;</span>)  <span class="comment">// options</span></div>
<div class="line">      ,</div>
<div class="line">      <a class="code" href="structkatana_1_1no__pushes.html">katana::no_pushes</a>(), <a class="code" href="structkatana_1_1disable__conflict__detection.html">katana::disable_conflict_detection</a>());</div>
<div class="ttc" id="astructkatana_1_1disable__conflict__detection_html"><div class="ttname"><a href="structkatana_1_1disable__conflict__detection.html">katana::disable_conflict_detection</a></div><div class="ttdef"><b>Definition:</b> Traits.h:276</div></div>
<div class="ttc" id="astructkatana_1_1no__pushes_html"><div class="ttname"><a href="structkatana_1_1no__pushes.html">katana::no_pushes</a></div><div class="ttdef"><b>Definition:</b> Traits.h:250</div></div>
</div><!-- fragment --><p> See <a class="el" href="lonestar_2tutorial_examples_2GraphTraversalPushOperator_8cpp-example.html">lonestar/tutorial_examples/GraphTraversalPushOperator.cpp</a> for the full examples.</p>
<p> 
</td></tr><tbody></table>
</p>
<h1><a class="anchor" id="katana_worklists"></a>
Worklists and Schedules</h1>
<p>So far, we addressed only <em>topology-driven</em> algorithms, e.g. the same computation is done by all graph nodes. To implement <em>data-driven</em> algorithms, two more constructs are needed: (1) a worklist to track active elements, and (2) a scheduler to decide which active elements to work on first. New work items can be inserted to a worklist by calling <a class="el" href="classkatana_1_1UserContext.html#a760db471e9c011dd2962a4833552c76b" title="Push new work.">katana::UserContext::push</a>. This section focuses on the schedulers supported by Galois. For details, see <a class="el" href="scheduler.html">Scheduler</a>.</p>
<p>Galois supports a variety of scheduling policies; all of them are in the namespace katana. Example scheduling policies are <a class="el" href="namespacekatana.html#a84226ce246b0237245e6bb9069c7d092">katana::FIFO</a> (approximate), <a class="el" href="namespacekatana.html#acf7993944566434d2c819d10213374ee">katana::LIFO</a> (approximate), <a class="el" href="namespacekatana.html#ab7c790c9b26b98e164abc2c5e0449d45" title="Chunk FIFO.">katana::ChunkFIFO</a>, <a class="el" href="namespacekatana.html#a952ae2d2b3b5f99d90b6e04700c435a3" title="Chunk LIFO.">katana::ChunkLIFO</a>, <a class="el" href="namespacekatana.html#ab846f7bdd2bd0cecf06708c1806a668f" title="Distributed chunked FIFO.">katana::PerSocketChunkFIFO</a>, <a class="el" href="namespacekatana.html#a61ae784a4e1b6a4885f4a32d144938ec" title="Distributed chunked LIFO.">katana::PerSocketChunkLIFO</a>, <a class="el" href="namespacekatana.html#ae2871917f6d0efc6dbe0207c6baa2429">katana::PerThreadChunkFIFO</a>, <a class="el" href="namespacekatana.html#a4a2f492fc05abc037f021bfef430f3f1">katana::PerThreadChunkLIFO</a>, and <a class="el" href="structkatana_1_1OrderedByIntegerMetric.html" title="Approximate priority scheduling.">katana::OrderedByIntegerMetric</a>. The default scheduler is <a class="el" href="namespacekatana.html#ab846f7bdd2bd0cecf06708c1806a668f" title="Distributed chunked FIFO.">katana::PerSocketChunkFIFO</a> with a chunk size 32.</p>
<p><a class="el" href="structkatana_1_1OrderedByIntegerMetric.html" title="Approximate priority scheduling.">katana::OrderedByIntegerMetric</a> can be used to implement a user-defined soft priority, a hint for the Galois runtime to schedule active elements where priority inversion will not result in incorrect answers or deadlocks. It needs an indexer function to map work items to an integer (priority). Each bin corresponds to a priority level and is itself a worklist, e.g. <a class="el" href="namespacekatana.html#a61ae784a4e1b6a4885f4a32d144938ec" title="Distributed chunked LIFO.">katana::PerSocketChunkLIFO</a> with a chunk size 16. For details, see <a class="el" href="scheduler.html#obim_wl">Ordered By Integer Metric (OBIM)</a>.</p>
<p> 
<table class="doxtable"><tbody>
<tr><th align="left"> Running Example </th></tr>
<tr><td align="left">
</p>
<p>Let us use the single-source shortest path (SSSP) problem to illustrate the implementation of data-driven algorithms using Galois. Given (1) an edge-weighted graph G with no negative-weight cycles, and (2) a source node s; the SSSP problem asks for the shortest distance of every node n in G from s. Initially, s has distance 0 from itself, and all other nodes have a distance of infinity from s.</p>
<p>Here is the operator code common to all push-style SSSP algorithms:</p>
<div class="fragment"><div class="line">  <span class="comment">// SSSP operator</span></div>
<div class="line">  <span class="comment">// auto&amp; ctx expands to katana::UserContext&lt;GNode&gt;&amp; ctx</span></div>
<div class="line">  <span class="keyword">auto</span> SSSP = [&amp;](<a class="code" href="jaccard_8cpp.html#ac56cf62167e787bf1a4ff1e5b529e0b0">GNode</a> active_node, <span class="keyword">auto</span>&amp; ctx) {</div>
<div class="line">    <span class="comment">// Get the value on the node</span></div>
<div class="line">    <span class="keyword">auto</span> srcData = graph.getData(active_node);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// loop over neighbors to compute new value</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> ii : graph.edges(active_node)) {  <span class="comment">// cautious point</span></div>
<div class="line">      <span class="keyword">auto</span> dst = graph.getEdgeDst(ii);</div>
<div class="line">      <span class="keyword">auto</span> weight = graph.getEdgeData(ii);</div>
<div class="line">      <span class="keyword">auto</span>&amp; dstData = graph.getData(dst);</div>
<div class="line">      <span class="keywordflow">if</span> (dstData &gt; weight + srcData) {</div>
<div class="line">        dstData = weight + srcData;</div>
<div class="line">        ctx.push(dst);  <span class="comment">// add new work items</span></div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
</div><!-- fragment --><p> And here is the code to declare worklists. Note how OBIM is declared with an indexer, e.g. reqIndexer, and another worklist, e.g. PerSocketChunkLIFO&lt;16&gt;.</p>
<div class="fragment"><div class="line">  <span class="comment">// Priority Function in SSSPPushSimple</span></div>
<div class="line">  <span class="comment">// Map user-defined priority to a bucket number in OBIM</span></div>
<div class="line">  <span class="keyword">auto</span> reqIndexer = [&amp;](<span class="keyword">const</span> <a class="code" href="jaccard_8cpp.html#ac56cf62167e787bf1a4ff1e5b529e0b0">GNode</a>&amp; N) {</div>
<div class="line">    <span class="keywordflow">return</span> (graph.getData(N, <a class="code" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246a937e6a98c210e6d3d0af5ed55de70d3b">katana::MethodFlag::UNPROTECTED</a>) &gt;&gt; stepShift);</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacekatana.html">katana</a>;</div>
<div class="line">  <span class="keyword">using</span> <a class="code" href="async_8cpp.html#ad91644deb0c87b6fbcc8a46dac0f3584">PSchunk</a> = PerSocketChunkLIFO&lt;16&gt;;  <span class="comment">// chunk size 16</span></div>
<div class="line">  <span class="keyword">using</span> <a class="code" href="structkatana_1_1OrderedByIntegerMetric.html">OBIM</a> = OrderedByIntegerMetric&lt;decltype(reqIndexer), <a class="code" href="async_8cpp.html#ad91644deb0c87b6fbcc8a46dac0f3584">PSchunk</a>&gt;;</div>
<div class="ttc" id="aasync_8cpp_html_ad91644deb0c87b6fbcc8a46dac0f3584"><div class="ttname"><a href="async_8cpp.html#ad91644deb0c87b6fbcc8a46dac0f3584">PSchunk</a></div><div class="ttdeci">katana::PerSocketChunkFIFO&lt; ASYNC_CHUNK_SIZE &gt; PSchunk</div><div class="ttdef"><b>Definition:</b> async.cpp:32</div></div>
<div class="ttc" id="anamespacekatana_html"><div class="ttname"><a href="namespacekatana.html">katana</a></div><div class="ttdoc">Construct a PropertyGraph in memory.</div><div class="ttdef"><b>Definition:</b> Allocators.h:43</div></div>
<div class="ttc" id="anamespacekatana_html_a679ab3b4021187532d65e16ceb3fc246a937e6a98c210e6d3d0af5ed55de70d3b"><div class="ttname"><a href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246a937e6a98c210e6d3d0af5ed55de70d3b">katana::MethodFlag::UNPROTECTED</a></div><div class="ttdeci">@ UNPROTECTED</div></div>
<div class="ttc" id="astructkatana_1_1OrderedByIntegerMetric_html"><div class="ttname"><a href="structkatana_1_1OrderedByIntegerMetric.html">katana::OrderedByIntegerMetric</a></div><div class="ttdoc">Approximate priority scheduling.</div><div class="ttdef"><b>Definition:</b> Obim.h:154</div></div>
</div><!-- fragment --><p> Finally, here is the code for implementing data-driven algorithms. Initial active elements, e.g. the source node in this example, are passed to <a class="el" href="namespacekatana.html#a664a7f49a65e22807577f6cc809a7827" title="Iterate returns a specialized range object for various container-like objects:">katana::iterate</a> as an initializer list. Schedules are passed as options to <a class="el" href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81" title="Galois unordered set iterator.">katana::for_each</a>. Note that OBIM expects an indexer instance for its construction.</p>
<div class="fragment"><div class="line">  std::string schedule = argv[2];  <span class="comment">// argv[2] is the scheduler to be used</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// clear source</span></div>
<div class="line">  graph.getData(*graph.begin()) = 0;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (<span class="stringliteral">&quot;dchunk16&quot;</span> == schedule) {</div>
<div class="line">    <a class="code" href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81">katana::for_each</a>(</div>
<div class="line">        <a class="code" href="namespacekatana.html#a664a7f49a65e22807577f6cc809a7827">katana::iterate</a>(</div>
<div class="line">            {*graph.begin()}),  <span class="comment">// initial range using initializer list</span></div>
<div class="line">        SSSP                    <span class="comment">// operator</span></div>
<div class="line">        ,</div>
<div class="line">        katana::wl&lt;PSchunk&gt;()  <span class="comment">// options. PSchunk expands to</span></div>
<div class="line">                               <span class="comment">// katana::PerSocketChunkLIFO&lt;16&gt;,</span></div>
<div class="line">                               <span class="comment">// where 16 is chunk size</span></div>
<div class="line">        ,</div>
<div class="line">        <a class="code" href="structkatana_1_1loopname.html">katana::loopname</a>(<span class="stringliteral">&quot;sssp_dchunk16&quot;</span>));</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<span class="stringliteral">&quot;obim&quot;</span> == schedule) {</div>
<div class="line">    <a class="code" href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81">katana::for_each</a>(</div>
<div class="line">        <a class="code" href="namespacekatana.html#a664a7f49a65e22807577f6cc809a7827">katana::iterate</a>(</div>
<div class="line">            {*graph.begin()}),  <span class="comment">// initial range using initializer list</span></div>
<div class="line">        SSSP                    <span class="comment">// operator</span></div>
<div class="line">        ,</div>
<div class="line">        katana::wl&lt;OBIM&gt;(reqIndexer)  <span class="comment">// options. Pass an indexer instance for</span></div>
<div class="line">                                      <span class="comment">// OBIM construction.</span></div>
<div class="line">        ,</div>
<div class="line">        <a class="code" href="structkatana_1_1loopname.html">katana::loopname</a>(<span class="stringliteral">&quot;sssp_obim&quot;</span>));</div>
<div class="line">  }</div>
</div><!-- fragment --><p> The full example is available at <a class="el" href="lonestar_2tutorial_examples_2SSSPPushSimple_8cpp-example.html">lonestar/tutorial_examples/SSSPPushSimple.cpp</a>.</p>
<p> 
</td></tr><tbody></table>
</p>
<h2><a class="anchor" id="katana_deterministic_iterator"></a>
Deterministic Loop Iterator</h2>
<p><a class="el" href="namespacekatana.html#ab9ea3b9de54b0c2f223eb585f4aefaff" title="Standard do-all loop.">katana::do_all</a> and <a class="el" href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81" title="Galois unordered set iterator.">katana::for_each</a> assume that the operator allows the loop iterations to be computed in any order, which may give legal yet different results non-deterministically. When it is important to have deterministic results, the deterministic loop iterator comes to the rescue: it executes the operator in rounds, and in each round, it deterministically chooses a conflict-free subset of currently active elements to process. In this way, the Galois deterministic loop iterator can produce the same answer even on different platforms, which we call "portable determinism".</p>
<p>Galois' deterministic loop iterator can be launched on-demand and parameter-less by passing <code><a class="el" href="namespacekatana.html#a0a996c85bab3fdbf1afad32e8595db32">katana::wl</a>&lt;<a class="el" href="structkatana_1_1Deterministic.html" title="Deterministic execution.">katana::Deterministic</a>&lt;&gt;&gt;</code> to <a class="el" href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81" title="Galois unordered set iterator.">katana::for_each</a>. Use <a class="el" href="classkatana_1_1UserContext.html#a07cfefdcf231100edd558c9deb3e6d8a" title="declare that the operator has crossed the cautious point.">katana::UserContext::cautiousPoint</a> to signal the cautious point in the operator if necessary.</p>
<p> 
<table class="doxtable"><tbody>
<tr><th align="left"> Running Example </th></tr>
<tr><td align="left">
</p>
<p>Below is an example of using the deterministic loop executor for SSSP:</p>
<div class="fragment"><div class="line">    <a class="code" href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81">katana::for_each</a>(</div>
<div class="line">        <a class="code" href="namespacekatana.html#a664a7f49a65e22807577f6cc809a7827">katana::iterate</a>(</div>
<div class="line">            {*graph.begin()}),  <span class="comment">// initial range using initializer list</span></div>
<div class="line">        SSSP                    <span class="comment">// operator</span></div>
<div class="line">        ,</div>
<div class="line">        <a class="code" href="namespacekatana.html#a0a996c85bab3fdbf1afad32e8595db32">katana::wl</a>&lt;<a class="code" href="structkatana_1_1Deterministic.html">katana::Deterministic&lt;&gt;</a>&gt;()  <span class="comment">// options</span></div>
<div class="line">        ,</div>
<div class="line">        <a class="code" href="structkatana_1_1loopname.html">katana::loopname</a>(<span class="stringliteral">&quot;sssp_deterministic&quot;</span>));</div>
<div class="ttc" id="anamespacekatana_html_a0a996c85bab3fdbf1afad32e8595db32"><div class="ttname"><a href="namespacekatana.html#a0a996c85bab3fdbf1afad32e8595db32">katana::wl</a></div><div class="ttdeci">s_wl&lt; T, Args... &gt; wl(Args... args)</div><div class="ttdef"><b>Definition:</b> Traits.h:234</div></div>
<div class="ttc" id="astructkatana_1_1Deterministic_html"><div class="ttname"><a href="structkatana_1_1Deterministic.html">katana::Deterministic</a></div><div class="ttdoc">Deterministic execution.</div><div class="ttdef"><b>Definition:</b> Executor_Deterministic.h:1691</div></div>
</div><!-- fragment --><p>  
</td></tr><tbody></table>
</p>
<h2><a class="anchor" id="katana_parameter_iterator"></a>
ParaMeter Loop Iterator</h2>
<p>An algorithm can benefit from parallelization only if it has a lot of parallelism. Galois provides the ParaMeter loop iterator to help algorithm designers find out the amount of parallelism in their algorithms. This parallelism, of course, depends on input-data. The ParaMeter loop iterator executes the operator in rounds and keeps track of statistics of parallelism for each round.</p>
<p>To launch Galois' ParaMeter loop iterator, pass <code><a class="el" href="namespacekatana.html#a0a996c85bab3fdbf1afad32e8595db32">katana::wl</a>&lt;<a class="el" href="classkatana_1_1ParaMeter.html">katana::ParaMeter</a>&lt;&gt;&gt;</code> to <a class="el" href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81" title="Galois unordered set iterator.">katana::for_each</a>.</p>
<p> 
<table class="doxtable"><tbody>
<tr><th align="left"> Running Example </th></tr>
<tr><td align="left">
</p>
<p>Below is an example of using ParaMeter loop executor for SSSP:</p>
<div class="fragment"><div class="line">    <a class="code" href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81">katana::for_each</a>(</div>
<div class="line">        <a class="code" href="namespacekatana.html#a664a7f49a65e22807577f6cc809a7827">katana::iterate</a>(</div>
<div class="line">            {*graph.begin()}),  <span class="comment">// initial range using initializer list</span></div>
<div class="line">        SSSP                    <span class="comment">// operator</span></div>
<div class="line">        ,</div>
<div class="line">        <a class="code" href="namespacekatana.html#a0a996c85bab3fdbf1afad32e8595db32">katana::wl</a>&lt;<a class="code" href="classkatana_1_1ParaMeter.html">katana::ParaMeter&lt;&gt;</a>&gt;()  <span class="comment">// options</span></div>
<div class="line">        ,</div>
<div class="line">        <a class="code" href="structkatana_1_1loopname.html">katana::loopname</a>(<span class="stringliteral">&quot;sssp_ParaMeter&quot;</span>));</div>
<div class="ttc" id="aclasskatana_1_1ParaMeter_html"><div class="ttname"><a href="classkatana_1_1ParaMeter.html">katana::ParaMeter</a></div><div class="ttdef"><b>Definition:</b> Executor_ParaMeter.h:427</div></div>
</div><!-- fragment --><p> Runs using the ParaMeter loop iterator will generate a parallelism profile as a csv file whose prefix is "ParaMeter-Stats-". A sample ParaMeter csv output looks like the following:</p>
<p> 
<code>
LOOPNAME, STEP, PARALLELISM, WORKLIST_SIZE, NEIGHBORHOOD_SIZE<br>
sssp_ParaMeter, 0, 1, 1, 4<br>
sssp_ParaMeter, 1, 1, 3, 4<br>
sssp_ParaMeter, 2, 2, 4, 4<br>
sssp_ParaMeter, 3, 2, 2, 6<br>
sssp_ParaMeter, 4, 1, 2, 4<br>
sssp_ParaMeter, 5, 2, 3, 9<br>
sssp_ParaMeter, 6, 2, 6, 6<br>
sssp_ParaMeter, 7, 3, 6, 12<br>
sssp_ParaMeter, 8, 5, 9, 18<br>
sssp_ParaMeter, 9, 7, 12, 27<br>
sssp_ParaMeter, 10, 8, 18, 28<br>
...
</code>
</p>
<p>The parallelism profile should be interpreted as follows: </p><ol>
<li>
LOOPNAME indicates the for_each loop the statistics are for. In this example, it refers to the <a class="el" href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81" title="Galois unordered set iterator.">katana::for_each</a> passed as an option <a class="el" href="structkatana_1_1loopname.html">katana::loopname</a>("sssp_ParaMeter"). </li>
<li>
STEP indicates which round the statistics are for. It counts from 0 whenever the corresponding for_each is launched. </li>
<li>
PARALLELISM indicates the number of active elements that can be processed in parallel in a given round. </li>
<li>
WORKLIST_SIZE indicates the number of available active elements in a given round. </li>
<li>
NEIGHBORHOOD_SIZE indicates the number of shared objects owned by committed iterations in a given round. NEIGHBORHOOD_SIZE / PARALLELISM gives the average size of the neighborhood of an active element. </li>
</ol>
<p> 
</td></tr><tbody></table>
</p>
<h1><a class="anchor" id="example_output"></a>
Example Output of Galois Apps</h1>
<p>Upon termination, Galois apps will output statistics in csv format, similar to the following:</p>
<p> 
<code>
STAT_TYPE, REGION, CATEGORY, TOTAL_TYPE, TOTAL<br>
STAT, for_each_1, Iterations, TSUM, 9028387<br>
STAT, for_each_1, Time, TMAX, 1663<br>
STAT, for_each_1, Commits, TSUM, 9000000<br>
STAT, for_each_1, Pushes, TSUM, 0<br>
STAT, for_each_1, Conflicts, TSUM, 28387<br>
</code>
</p>
<p>The first row is the header of the csv output. REGION tells you which parallel loop the statistics are related to. For example, "for_each_1" refers to the <a class="el" href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81" title="Galois unordered set iterator.">katana::for_each</a> which has an option of <code><a class="el" href="structkatana_1_1loopname.html">katana::loopname</a>("for_each_1")</code>.</p>
<p>CATEGORY specifies what is being reported for the parallel region. For <a class="el" href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81" title="Galois unordered set iterator.">katana::for_each</a> loops, the following five statistics are reported: </p><ol>
<li>
<code>Iterations</code>: the number of iterations executed </li>
<li>
<code>Time</code>: the runtime, in milliseconds </li>
<li>
<code>Commits</code>: the number of iterations committed </li>
<li>
<code>Pushes</code>: the number of iterations generated </li>
<li>
<code>Conflicts</code>: the number of iterations aborted due to conflicts </li>
</ol>
<p>For <a class="el" href="namespacekatana.html#ab9ea3b9de54b0c2f223eb585f4aefaff" title="Standard do-all loop.">katana::do_all</a> loops, only time and iterations are reported, since there are no conflicts and pushes in <a class="el" href="namespacekatana.html#ab9ea3b9de54b0c2f223eb585f4aefaff" title="Standard do-all loop.">katana::do_all</a> loops.</p>
<p>TOTAL_TYPE tells you how the statistics are derived. TSUM means that the value is the sum of all threads' contributions; TMAX means it is the maximum among all threads for this statistic. TOTAL_TYPE is usually a reduction operation.</p>
<h1><a class="anchor" id="katana_morph_graph_api"></a>
MorphGraph APIs</h1>
<p>If your application requires modifying the graph topology, e.g. as in Delaunay mesh refinement, you need <a class="el" href="classkatana_1_1MorphGraph.html" title="A graph that can have new nodes and edges added to it.">katana::MorphGraph</a>. <a class="el" href="classkatana_1_1MorphGraph.html" title="A graph that can have new nodes and edges added to it.">katana::MorphGraph</a> supports all the functionalities in <a class="el" href="classkatana_1_1LC__CSR__Graph.html" title="Local computation graph (i.e., graph structure does not change).">katana::LC_CSR_Graph</a> except for size(), reporting the number of nodes in a graph; and sizeEdges(), reporting the number of edges in a graph. Additionally, <a class="el" href="classkatana_1_1MorphGraph.html" title="A graph that can have new nodes and edges added to it.">katana::MorphGraph</a> provides the following APIs to modify the graph topology:</p>
<ol>
<li>
<a class="el" href="classkatana_1_1MorphGraph.html#a763a66b2f2042e35916b730ccfbcd784" title="Creates a new node holding the indicated data.">katana::MorphGraph::createNode</a> allocates space for node data, and <a class="el" href="classkatana_1_1MorphGraph.html#a4dda7ab5101878267789257c5d1eda03" title="Adds a node to the graph.">katana::MorphGraph::addNode</a> adds a node to a graph so the node can be found later by graph APIs. </li>
<li>
<a class="el" href="classkatana_1_1MorphGraph.html#a30eb71aa044800d42cc253fc38dc7a3b" title="Adds an edge to graph, replacing existing value if edge already exists.">katana::MorphGraph::addEdge</a> and <a class="el" href="classkatana_1_1MorphGraph.html#a31f169c21840aebfdb8874eb21697825" title="Adds and initializes an edge to graph but does not check for duplicate edges.">katana::MorphGraph::addMultiEdge</a> both add an edge between existing nodes to a graph. The former adds an edge only when the edge does not exist, while the latter always adds the edge. </li>
<li>
<a class="el" href="classkatana_1_1MorphGraph.html#a77f250ac12562b3d67ae47afefd7f7e3" title="Removes a node from the graph along with all its outgoing/incoming edges for undirected graphs or out...">katana::MorphGraph::removeNode</a> removes from a graph a node and all edges connecting to/from the node. </li>
<li>
<a class="el" href="classkatana_1_1MorphGraph.html#ad8c54a164a8c819f3d780edde1409269" title="Removes an edge from the graph.">katana::MorphGraph::removeEdge</a> removes from a graph an edge and its incoming/symmetric counterpart, if there is any. </li>
</ol>
<p>Let us use <a class="el" href="classkatana_1_1MorphGraph.html" title="A graph that can have new nodes and edges added to it.">katana::MorphGraph</a> to construct and represent a two-dimensional torus. To define a <a class="el" href="classkatana_1_1MorphGraph.html" title="A graph that can have new nodes and edges added to it.">katana::MorphGraph</a>, you must provide as template parameters NodeTy, the type of node data; EdgeTy, the type of edge data; and a Boolean value indicating whether or not this is a directed graph. The following code snippet shows an example of defining a <a class="el" href="classkatana_1_1MorphGraph.html" title="A graph that can have new nodes and edges added to it.">katana::MorphGraph</a>. See <a class="el" href="classkatana_1_1MorphGraph.html" title="A graph that can have new nodes and edges added to it.">katana::MorphGraph</a> for details about other optional template parameters.</p>
<div class="fragment"><div class="line"><span class="comment">// Graph has int node data, void edge data and is directed</span></div>
<div class="line"><span class="keyword">using</span> <a class="code" href="classkatana_1_1TypedPropertyGraph.html">Graph</a> = <a class="code" href="classkatana_1_1MorphGraph.html">katana::MorphGraph&lt;int, void, true&gt;</a>;</div>
<div class="line"><span class="comment">// Opaque pointer to graph node</span></div>
<div class="line"><span class="keyword">using</span> <a class="code" href="jaccard_8cpp.html#ac56cf62167e787bf1a4ff1e5b529e0b0">GNode</a> = Graph::GraphNode;</div>
<div class="ttc" id="aclasskatana_1_1MorphGraph_html"><div class="ttname"><a href="classkatana_1_1MorphGraph.html">katana::MorphGraph</a></div><div class="ttdoc">A graph that can have new nodes and edges added to it.</div><div class="ttdef"><b>Definition:</b> MorphGraph.h:242</div></div>
</div><!-- fragment --><p> The following code snippet shows how to add nodes and edges to a <a class="el" href="classkatana_1_1MorphGraph.html" title="A graph that can have new nodes and edges added to it.">katana::MorphGraph</a>. Note that you need to create nodes first, then add the nodes to a <a class="el" href="classkatana_1_1MorphGraph.html" title="A graph that can have new nodes and edges added to it.">katana::MorphGraph</a>, and finally add edges in between the nodes.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div>
<div class="line">constructTorus(<a class="code" href="classkatana_1_1TypedPropertyGraph.html">Graph</a>&amp; g, <span class="keywordtype">int</span> height, <span class="keywordtype">int</span> width) {</div>
<div class="line">  <span class="comment">// Construct set of nodes</span></div>
<div class="line">  <span class="keywordtype">int</span> numNodes = height * width;</div>
<div class="line">  std::vector&lt;GNode&gt; nodes(numNodes);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numNodes; ++i) {</div>
<div class="line">    <a class="code" href="jaccard_8cpp.html#ac56cf62167e787bf1a4ff1e5b529e0b0">GNode</a> n = g.createNode(</div>
<div class="line">        0);        <span class="comment">// allocate node data and initialize the node data with 0</span></div>
<div class="line">    g.addNode(n);  <span class="comment">// add n to g. from now on n can be located from g</span></div>
<div class="line">    nodes[i] = n;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Add edges</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; width; ++x) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; height; ++y) {</div>
<div class="line">      <a class="code" href="jaccard_8cpp.html#ac56cf62167e787bf1a4ff1e5b529e0b0">GNode</a> c = nodes[x * height + y];</div>
<div class="line">      <a class="code" href="jaccard_8cpp.html#ac56cf62167e787bf1a4ff1e5b529e0b0">GNode</a> n = nodes[x * height + ((y + 1) % height)];</div>
<div class="line">      <a class="code" href="jaccard_8cpp.html#ac56cf62167e787bf1a4ff1e5b529e0b0">GNode</a> s = nodes[x * height + ((y - 1 + height) % height)];</div>
<div class="line">      <a class="code" href="jaccard_8cpp.html#ac56cf62167e787bf1a4ff1e5b529e0b0">GNode</a> e = nodes[((x + 1) % width) * height + y];</div>
<div class="line">      <a class="code" href="jaccard_8cpp.html#ac56cf62167e787bf1a4ff1e5b529e0b0">GNode</a> w = nodes[((x - 1 + width) % width) * height + y];</div>
<div class="line">      g.addEdge(c, n);  <span class="comment">// addEdge checks if the edge exists or not. nop if so.</span></div>
<div class="line">      g.addEdge(c, s);</div>
<div class="line">      g.addEdge(c, e);</div>
<div class="line">      g.addEdge(c, w);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p> See the full example at <a class="el" href="lonestar_2tutorial_examples_2TorusConstruction_8cpp-example.html">lonestar/tutorial_examples/TorusConstruction.cpp</a>.</p>
<p> 
<!--
@section mem_alloc Memory Allocators

Memory allocation plays an important role in making parallel programs scalable. Use the following Galois memory allocators with the recommended scenarios, especially in parallel loops.

<ol>
<li> Allocate objects with fixed size, e.g. set elements, from katana::FixedSizeAllocator.
<li> Allocate objects with variable size, e.g. vectors, from katana::Pow2VarSizeAlloc.
<li> Allocate objects used only in a loop iteration from katana::PerIterAllocTy. To use the per-iteration allocator, you need to pass katana::per_iter_alloc to katana::for_each. Here is an example of how to use it:
@code
using Graph = /* graph type definition */;
using GNode = Graph::GraphNode;
Graph g;
katana::for_each(
    katana::iterate(graph),
    [&] (GNode n, auto& ctx) {
      // syntax for conforming to STL allocator interface
      using Alloc = katana::PerIterAllocTy::rebind<GNode>::other;

      // fast, scalable allocation for v, a per-iteration vector
      // get per-iteration allocator from ctx to initialize v
      std::vector<GNode, Alloc> v(ctx.getPerIterAlloc());

      auto& d = graph.getData(n).data;
      std::copy(d.begin(), d.end(), std::back_inserter(v));
      // use of v below
    }
    , katana::per_iter_alloc()
    , katana::loopname("per_iter_alloc_example")
);
@endcode
</ol>
-->
</p>
<h1><a class="anchor" id="tuning_guides"></a>
Tuning Guides</h1>
<p>Performance tuning is required to make a parallel program fast and scalable. Readers should keep the following points in mind when tuning performance: </p><ol>
<li>
Chunk size can be tuned to trade-off work balance and overhead to access the worklist and may hurt priority enforcement when it is large. </li>
<li>
Schedules play an important role in performance. They trade-off the amount of wasted work and parallelism. However, there is overhead in managing additional information. </li>
<li>
NUMA-awareness in data structure and loop execution is critical for performance. For this reason, <a class="el" href="namespacekatana.html#a664a7f49a65e22807577f6cc809a7827" title="Iterate returns a specialized range object for various container-like objects:">katana::iterate</a> prefers local_iterator over iterator if provided a container. For more information, see <a class="el" href="numa.html">NUMA-Awareness</a>. </li>
<li>
Memory allocation in parallel loops can kill the scalability of a parallel program. Use <code><a class="el" href="namespacekatana.html#adf0246abc6c31e1172dc6533bcade08a" title="Preallocates memory on each thread.">katana::Prealloc</a></code> to pre-allocate memory pages instead of on-demand page allocation in parallel loops. </li>
</ol>
<h1><a class="anchor" id="tutorial_conclusion"></a>
Concluding Remarks</h1>
<p>We have walked through the key user-level Galois constructs for writing a C++ parallel program. For details about the aforementioned constructs, library-level Galois constructs, and performance tuning, please refer to <a class="el" href="Manual.html">Manual</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
