<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Katana: Build Your Own Galois Data Structure</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Katana
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('your_own_ds.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Build Your Own Galois Data Structure </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#goal_your_own_ds">Goal of this Section</a></li>
<li class="level1"><a href="#numa_aware_ds">Principles for NUMA-aware Data Structures</a><ul><li class="level2"><a href="#array_like_ds">Array-based Data Structures</a></li>
<li class="level2"><a href="#per_thread_like_ds">Per-thread Data Structure</a></li>
<li class="level2"><a href="#ds_and_mem_alloc">Managing Memory with Custom Allocators</a></li>
</ul>
</li>
<li class="level1"><a href="#conflict_aware_ds">Conflict-aware Galois Data Structures</a><ul><li class="level2"><a href="#torus_conflict_awareness">Conflict Awareness</a></li>
<li class="level2"><a href="#torus_stl">Container Interface</a></li>
<li class="level2"><a href="#torus_easy_cautiousness">Easy Operator Cautiousness</a></li>
<li class="level2"><a href="#torus_use">Use the 2D Torus</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="goal_your_own_ds"></a>
Goal of this Section</h1>
<p>We assume the readers have read <a class="el" href="tutorial.html">Tutorial</a> and understand Galois programming model and related constructs reasonably.</p>
<p>This guide has two parts. The first part talks about the principles to build a NUMA-aware data structure; the second part talks about how to make your data structure work with Galois' conflict detection.</p>
<h1><a class="anchor" id="numa_aware_ds"></a>
Principles for NUMA-aware Data Structures</h1>
<h2><a class="anchor" id="array_like_ds"></a>
Array-based Data Structures</h2>
<p>You can hold a fixed amount of work items, e.g. a 2D torus of fixed width and height, using an array. To allocate an array in a NUMA-aware fashion, you can use <a class="el" href="classkatana_1_1LargeArray.html" title="Large array of objects with proper specialization for void type and supporting various allocation and...">katana::LargeArray</a> and its allocation methods.</p>
<p><a class="el" href="classkatana_1_1LargeArray.html" title="Large array of objects with proper specialization for void type and supporting various allocation and...">katana::LargeArray</a> supports five ways of memory allocation (see details at <a class="el" href="numa.html">NUMA-Awareness</a>). </p><ol>
<li>
<a class="el" href="classkatana_1_1LargeArray.html#afa83765f98006010c24c7542ce00a129" title="Allocates using Thread Local memory policy.">katana::LargeArray::allocateLocal</a>: allocate the array at the calling thread's socket. </li>
<li>
<a class="el" href="classkatana_1_1LargeArray.html#a7f60e1c3df280a29f32ca32ecac3f54c" title="Allocates using no memory policy (no pre alloc)">katana::LargeArray::allocateFloating</a>: each page of the array will be allocated to the socket of the first-touching thread. </li>
<li>
<a class="el" href="classkatana_1_1LargeArray.html#a3a894e8a5ebdd702c6c42e9b4f344a94" title="Allocates using blocked memory policy.">katana::LargeArray::allocateBlocked</a>: partition the array evenly into contiguous chunks, and each thread allocates its own chunk. </li>
<li>
<a class="el" href="classkatana_1_1LargeArray.html#a78090b89802d0e2f35dc9feef04dfd12" title="[allocatefunctions] Allocates interleaved across NUMA (memory) nodes.">katana::LargeArray::allocateInterleaved</a>: interleave the pages of the array among threads in a round-robin fashion. </li>
<li>
<a class="el" href="classkatana_1_1LargeArray.html#ad1488df93065179e87fd09cfa32eb3a5" title="Allocate memory to threads based on a provided array specifying which threads receive which elements ...">katana::LargeArray::allocateSpecified</a>: allocate the array by a specified thread ranges. </li>
</ol>
<p><br  />
</p>
<p>Below are rule of thumb for deciding the allocation policy. </p><ol>
<li>
Use <a class="el" href="classkatana_1_1LargeArray.html#a3a894e8a5ebdd702c6c42e9b4f344a94" title="Allocates using blocked memory policy.">katana::LargeArray::allocateBlocked</a> if the accesses are concentrated within evenly partitioned chunks. </li>
<li>
Use <a class="el" href="classkatana_1_1LargeArray.html#ad1488df93065179e87fd09cfa32eb3a5" title="Allocate memory to threads based on a provided array specifying which threads receive which elements ...">katana::LargeArray::allocateSpecified</a> if you know the access patterns which are different from blocked. </li>
<li>
Use <a class="el" href="classkatana_1_1LargeArray.html#a78090b89802d0e2f35dc9feef04dfd12" title="[allocatefunctions] Allocates interleaved across NUMA (memory) nodes.">katana::LargeArray::allocateInterleaved</a> when the access pattern is unknown or random. </li>
</ol>
<p>Define local_iterator for your data structure so that the Galois runtime can better leverage the locality of accesses by using local ranges formed by local_iterators. Otherwise, Galois falls back to use global ranges given by begin() and end(), which are of type iterator.</p>
<p>See <a class="el" href="classkatana_1_1LC__CSR__Graph.html" title="Local computation graph (i.e., graph structure does not change).">katana::LC_CSR_Graph</a> as an example data structure built with <a class="el" href="classkatana_1_1LargeArray.html" title="Large array of objects with proper specialization for void type and supporting various allocation and...">katana::LargeArray</a>.</p>
<h2><a class="anchor" id="per_thread_like_ds"></a>
Per-thread Data Structure</h2>
<p>If work items are generated dynamically by threads, then it is better to have a per-thread data structure backed by a per-thread heap. Threads populate the data structure in their thread-local copy, and then work items are merged or iterated in another serial/parallel phase. <a class="el" href="classkatana_1_1InsertBag.html" title="Unordered collection of elements.">katana::InsertBag</a> can be used for this purpose. This design helps scalability by avoiding having a big lock around a global data structure.</p>
<p>You can further exploit the semantics of work items when designing your own per-thread data structure. </p><ol>
<li>
If the work items can be merged by well-defined reduction operations, <ul>
<li>
Extend from katana::GSimpleReducible if the work items are cheap to copy. </li>
<li>
Extend from katana::GBigReducible if the work items are expensive to copy, e.g. containers. </li>
</ul>
See <a class="el" href="reduction.html">Reduction Operations</a> for more details. </li>
<li>
If the work items need to be organized with a certain structure, extend from katana::PerThreadContainer. </li>
<li>
If the work items form a multi-set and never get removed before processed, use <a class="el" href="classkatana_1_1InsertBag.html" title="Unordered collection of elements.">katana::InsertBag</a>. </li>
</ol>
<p>Start from <a class="el" href="classkatana_1_1PerThreadStorage.html">katana::PerThreadStorage</a> or <a class="el" href="classkatana_1_1PerSocketStorage.html">katana::PerSocketStorage</a> if none of the above fits your needs. See <a class="el" href="thread_local_storage.html">Per-Thread and Per-Socket Storage</a> for more details.</p>
<p>local_iterator for a per-thread data structure can be naturally defined as the iterators to thread-local containers. The global iterator should be carefully constructed from local_iterators in order to conform to the STL interface. Galois will pick up local iterators to leverage the spacial/temporal locality in work generation.</p>
<p>See <a class="el" href="classkatana_1_1InsertBag.html" title="Unordered collection of elements.">katana::InsertBag</a> as an example data structure built with this design in mind.</p>
<h2><a class="anchor" id="ds_and_mem_alloc"></a>
Managing Memory with Custom Allocators</h2>
<p>To address the memory usage in a NUMA-aware fashion, you may need to work with custom memory allocators. As an example, the code snippet below shows parts of the implementation for <a class="el" href="classkatana_1_1gdeque.html" title="Like std::deque but use Galois memory management functionality.">katana::gdeque</a> related to memory allocations: </p><div class="fragment"><div class="line">  <a class="code" href="classkatana_1_1FixedSizeAllocator.html">katana::FixedSizeAllocator&lt;Block&gt;</a> heap;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</div>
<div class="line">  Block* alloc_block(Args&amp;&amp;... args) {</div>
<div class="line">    <span class="comment">// Fixed size allocator can only allocate 1 object at a time of size</span></div>
<div class="line">    <span class="comment">// sizeof(Block). Argument to allocate is always 1.</span></div>
<div class="line">    Block* b = heap.<a class="code" href="classkatana_1_1FixedSizeAllocator.html#a8d75cbc36c83fa81df2650164ecd9a3f">allocate</a>(1);</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> (b) Block(std::forward&lt;Args&gt;(args)...);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> free_block(Block* b) {</div>
<div class="line">    b-&gt;~Block();</div>
<div class="line">    heap.<a class="code" href="classkatana_1_1FixedSizeAllocator.html#a4c8d5ca6c9c64f0fee1e0a79ad5284b8">deallocate</a>(b, 1);</div>
<div class="line">  }</div>
<div class="ttc" id="aclasskatana_1_1FixedSizeAllocator_html"><div class="ttname"><a href="classkatana_1_1FixedSizeAllocator.html">katana::FixedSizeAllocator</a></div><div class="ttdoc">Scalable fixed-sized allocator for T that conforms to STL allocator interface but does not support va...</div><div class="ttdef"><b>Definition:</b> Allocators.h:680</div></div>
<div class="ttc" id="aclasskatana_1_1FixedSizeAllocator_html_a4c8d5ca6c9c64f0fee1e0a79ad5284b8"><div class="ttname"><a href="classkatana_1_1FixedSizeAllocator.html#a4c8d5ca6c9c64f0fee1e0a79ad5284b8">katana::FixedSizeAllocator::deallocate</a></div><div class="ttdeci">void deallocate(pointer ptr, [[maybe_unused]] size_type len)</div><div class="ttdef"><b>Definition:</b> Allocators.h:719</div></div>
<div class="ttc" id="aclasskatana_1_1FixedSizeAllocator_html_a8d75cbc36c83fa81df2650164ecd9a3f"><div class="ttname"><a href="classkatana_1_1FixedSizeAllocator.html#a8d75cbc36c83fa81df2650164ecd9a3f">katana::FixedSizeAllocator::allocate</a></div><div class="ttdeci">pointer allocate(size_type size)</div><div class="ttdef"><b>Definition:</b> Allocators.h:713</div></div>
</div><!-- fragment --><h1><a class="anchor" id="conflict_aware_ds"></a>
Conflict-aware Galois Data Structures</h1>
<p>Suppose we want to write a program to count the number of neighbors for each node in a 2D torus using a push-style operator, where each node increments its neighbors' labels. There are conflicts among node activities, so we need the torus nodes to be conflict-aware if we do not want to handle synchronization in our operator code.</p>
<p>The neighbors of a 2D torus node can be inferred given the width, height and node numbering scheme of the torus. Therefore, it suffices to store only node data in an array, e.g. <a class="el" href="classkatana_1_1LargeArray.html" title="Large array of objects with proper specialization for void type and supporting various allocation and...">katana::LargeArray</a>. Using a graph to represent a 2D torus is possible but would be an overkill. For simplicity of this presentation, torus nodes are numbered from 0 onwards in row-major order.</p>
<h2><a class="anchor" id="torus_conflict_awareness"></a>
Conflict Awareness</h2>
<p>To make torus nodes be aware of conflicts, we can (1) use an internal struct to hold the real data, and (2) let the internal struct inherit from katana::Locakble. See the code snippet below for an example. T, given as a template parameter, is the type of actual node data. </p><div class="fragment"><div class="line">  <span class="comment">//************************************************************************</span></div>
<div class="line">  <span class="comment">// internal type to combine user data with Lockable object</span></div>
<div class="line">  <span class="comment">//************************************************************************</span></div>
<div class="line">  <span class="keyword">struct </span><a class="code" href="jaccard_8cpp.html#a405b470ab22306722b6329829e4e1aa6">NodeData</a> : <span class="keyword">public</span> <a class="code" href="classkatana_1_1Lockable.html">katana::Lockable</a> {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using</span> reference = T&amp;;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    T v;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    reference getData() { <span class="keywordflow">return</span> v; }</div>
<div class="line">  };</div>
<div class="ttc" id="aclasskatana_1_1Lockable_html"><div class="ttname"><a href="classkatana_1_1Lockable.html">katana::Lockable</a></div><div class="ttdoc">All objects that may be locked (nodes primarily) must inherit from Lockable.</div><div class="ttdef"><b>Definition:</b> Context.h:81</div></div>
<div class="ttc" id="ajaccard_8cpp_html_a405b470ab22306722b6329829e4e1aa6"><div class="ttname"><a href="jaccard_8cpp.html#a405b470ab22306722b6329829e4e1aa6">NodeData</a></div><div class="ttdeci">std::tuple&lt; JaccardSimilarity &gt; NodeData</div><div class="ttdef"><b>Definition:</b> jaccard.cpp:27</div></div>
</div><!-- fragment --><p> To store node data with locks for a torus, we instantiate a <a class="el" href="classkatana_1_1LargeArray.html" title="Large array of objects with proper specialization for void type and supporting various allocation and...">katana::LargeArray</a> containing elements of the internal struct: </p><div class="fragment"><div class="line">  <span class="keywordtype">size_t</span> numRows, numCols;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// use katana::LargeArray for NUMA-aware allocation</span></div>
<div class="line">  <span class="comment">// will allocate numRows*numCols elements in constructors</span></div>
<div class="line">  <a class="code" href="classkatana_1_1LargeArray.html">katana::LargeArray&lt;NodeData&gt;</a> data;</div>
<div class="ttc" id="aclasskatana_1_1LargeArray_html"><div class="ttname"><a href="classkatana_1_1LargeArray.html">katana::LargeArray</a></div><div class="ttdoc">Large array of objects with proper specialization for void type and supporting various allocation and...</div><div class="ttdef"><b>Definition:</b> LargeArray.h:39</div></div>
</div><!-- fragment --><p> To detect conflicts, we need to call <a class="el" href="namespacekatana.html#a79d59247a304c083855ea74a9cd24205" title="Master function which handles conflict detection used to acquire a lockable thing.">katana::acquire</a> on instances of the internal struct. All functions acquiring node ownership need to do so, so it is convenient to implement the call inside a wrapper function, as the following code snippet shows. size() returns the number of nodes in the torus. The parameter mflag is default to <a class="el" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246ad4b9e47f65b6e79b010582f15785867e">katana::MethodFlag::WRITE</a>. We will see an example of optimizing out conflict detection using this parameter later. </p><div class="fragment"><div class="line">  <span class="comment">//************************************************************************</span></div>
<div class="line">  <span class="comment">// functions to acquire node ownership</span></div>
<div class="line">  <span class="comment">//************************************************************************</span></div>
<div class="line">  <span class="keywordtype">void</span> acquireNode(</div>
<div class="line">      TorusNode n, <a class="code" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246">katana::MethodFlag</a> mflag = <a class="code" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246ad4b9e47f65b6e79b010582f15785867e">katana::MethodFlag::WRITE</a>) {</div>
<div class="line">    <span class="comment">// sanity check</span></div>
<div class="line">    <a class="code" href="Logging_8h.html#acb4f5b0dd598df41573616f8f1e2da3f">KATANA_LOG_DEBUG_ASSERT</a>(n &lt; size());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// use this call to detect conflicts and handling aborts</span></div>
<div class="line">    <a class="code" href="namespacekatana.html#a79d59247a304c083855ea74a9cd24205">katana::acquire</a>(&amp;data[n], mflag);</div>
<div class="line">  }</div>
<div class="ttc" id="aLogging_8h_html_acb4f5b0dd598df41573616f8f1e2da3f"><div class="ttname"><a href="Logging_8h.html#acb4f5b0dd598df41573616f8f1e2da3f">KATANA_LOG_DEBUG_ASSERT</a></div><div class="ttdeci">#define KATANA_LOG_DEBUG_ASSERT(cond)</div><div class="ttdef"><b>Definition:</b> Logging.h:150</div></div>
<div class="ttc" id="anamespacekatana_html_a679ab3b4021187532d65e16ceb3fc246"><div class="ttname"><a href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246">katana::MethodFlag</a></div><div class="ttdeci">MethodFlag</div><div class="ttdoc">What should the runtime do when executing a method.</div><div class="ttdef"><b>Definition:</b> MethodFlags.h:34</div></div>
<div class="ttc" id="anamespacekatana_html_a679ab3b4021187532d65e16ceb3fc246ad4b9e47f65b6e79b010582f15785867e"><div class="ttname"><a href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246ad4b9e47f65b6e79b010582f15785867e">katana::MethodFlag::WRITE</a></div><div class="ttdeci">@ WRITE</div></div>
<div class="ttc" id="anamespacekatana_html_a79d59247a304c083855ea74a9cd24205"><div class="ttname"><a href="namespacekatana.html#a79d59247a304c083855ea74a9cd24205">katana::acquire</a></div><div class="ttdeci">void acquire(Lockable *lockable, katana::MethodFlag m)</div><div class="ttdoc">Master function which handles conflict detection used to acquire a lockable thing.</div><div class="ttdef"><b>Definition:</b> Context.h:218</div></div>
</div><!-- fragment --><p> Now we need to let all methods that need ownership of a node call the wrapper function, as the code snippet below shows. Returning reference to node data allows users to modify it in-place. </p><div class="fragment"><div class="line">  <span class="comment">//************************************************************************</span></div>
<div class="line">  <span class="comment">// function to access node data</span></div>
<div class="line">  <span class="comment">//************************************************************************</span></div>
<div class="line">  <span class="keyword">typename</span> NodeData::reference getData(</div>
<div class="line">      TorusNode n, <a class="code" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246">katana::MethodFlag</a> mflag = <a class="code" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246ad4b9e47f65b6e79b010582f15785867e">katana::MethodFlag::WRITE</a>) {</div>
<div class="line">    acquireNode(n, mflag);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// use the internal wrapper type to encapsulate users from Lockable objects</span></div>
<div class="line">    <span class="keywordflow">return</span> data[n].getData();</div>
<div class="line">  }</div>
</div><!-- fragment --><h2><a class="anchor" id="torus_stl"></a>
Container Interface</h2>
<p>Recall that <a class="el" href="namespacekatana.html#ab9ea3b9de54b0c2f223eb585f4aefaff" title="Standard do-all loop.">katana::do_all</a> and <a class="el" href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81" title="Galois unordered set iterator.">katana::for_each</a> expect <a class="el" href="namespacekatana.html#a664a7f49a65e22807577f6cc809a7827" title="Iterate returns a specialized range object for various container-like objects:">katana::iterate</a>, whose parameter can be a pair of integers or a container with well-defined iterator. To make our 2D torus interoperable with Galois, we need to provide size-related functions or the iterator, given by begin() and end(), to loop through nodes. Size-related functions are easy to provide: </p><div class="fragment"><div class="line">  <span class="comment">//************************************************************************</span></div>
<div class="line">  <span class="comment">// functions for size of the torus</span></div>
<div class="line">  <span class="comment">//************************************************************************</span></div>
<div class="line">  <span class="keywordtype">size_t</span> height() { <span class="keywordflow">return</span> numRows; }</div>
<div class="line">  <span class="keywordtype">size_t</span> width() { <span class="keywordflow">return</span> numCols; }</div>
<div class="line">  <span class="keywordtype">size_t</span> size() { <span class="keywordflow">return</span> width() * height(); }</div>
</div><!-- fragment --><p> Iterators can be defined as the following: </p><div class="fragment"><div class="line">  <span class="comment">//************************************************************************</span></div>
<div class="line">  <span class="comment">// subtypes visible to user</span></div>
<div class="line">  <span class="comment">//************************************************************************</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// opaque type for node</span></div>
<div class="line">  <span class="keyword">using</span> TorusNode = size_t;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// iterator for an STL container</span></div>
<div class="line">  <span class="keyword">using</span> iterator = boost::counting_iterator&lt;TorusNode&gt;;</div>
</div><!-- fragment --><p> Users may instantiate iterators by begin() and end(), which are implemented as the following: </p><div class="fragment"><div class="line">  <span class="comment">//************************************************************************</span></div>
<div class="line">  <span class="comment">// functions to traverse nodes</span></div>
<div class="line">  <span class="comment">//************************************************************************</span></div>
<div class="line">  iterator begin() { <span class="keywordflow">return</span> iterator(0); }</div>
<div class="line">  iterator end() { <span class="keywordflow">return</span> iterator(size()); }</div>
</div><!-- fragment --><h2><a class="anchor" id="torus_easy_cautiousness"></a>
Easy Operator Cautiousness</h2>
<p>In our current example, we need to increment each node's immediate neighbors. Hence, we need APIs to get neighbors for a given node. Since we need to lock all neighbors before actual increments for operator cautiousness, it will be convenient to have a function locking all neighbors for a given node. The following code snippet shows how to achieve this. </p><div class="fragment"><div class="line">  <span class="comment">//************************************************************************</span></div>
<div class="line">  <span class="comment">// functions to access neighboring nodes, i.e. edges in a general graph</span></div>
<div class="line">  <span class="comment">//************************************************************************</span></div>
<div class="line">  iterator upNeighbor(TorusNode n) {</div>
<div class="line">    <span class="keyword">auto</span> r = n / numCols, c = n % numCols;</div>
<div class="line">    <span class="keyword">auto</span> newR = (r + numRows - 1) % numRows;</div>
<div class="line">    <span class="keywordflow">return</span> iterator(newR * numCols + c);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  iterator downNeighbor(TorusNode n) {</div>
<div class="line">    <span class="keyword">auto</span> r = n / numCols, c = n % numCols;</div>
<div class="line">    <span class="keyword">auto</span> newR = (r + 1) % numRows;</div>
<div class="line">    <span class="keywordflow">return</span> iterator(newR * numCols + c);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  iterator leftNeighbor(TorusNode n) {</div>
<div class="line">    <span class="keyword">auto</span> r = n / numCols, c = n % numCols;</div>
<div class="line">    <span class="keyword">auto</span> newC = (c + numCols - 1) % numCols;</div>
<div class="line">    <span class="keywordflow">return</span> iterator(r * numCols + newC);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  iterator rightNeighbor(TorusNode n) {</div>
<div class="line">    <span class="keyword">auto</span> r = n / numCols, c = n % numCols;</div>
<div class="line">    <span class="keyword">auto</span> newC = (c + 1) % numCols;</div>
<div class="line">    <span class="keywordflow">return</span> iterator(r * numCols + newC);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//************************************************************************</span></div>
<div class="line">  <span class="comment">// function to lock all neighbors of node n</span></div>
<div class="line">  <span class="comment">// similar to edge_begin(), edge_end() or edges() in a general graph</span></div>
<div class="line">  <span class="comment">//************************************************************************</span></div>
<div class="line">  <span class="keywordtype">void</span> acquireAllNeighbors(</div>
<div class="line">      TorusNode n, <a class="code" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246">katana::MethodFlag</a> mflag = <a class="code" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246ad4b9e47f65b6e79b010582f15785867e">katana::MethodFlag::WRITE</a>) {</div>
<div class="line">    acquireNode(*upNeighbor(n), mflag);</div>
<div class="line">    acquireNode(*downNeighbor(n), mflag);</div>
<div class="line">    acquireNode(*leftNeighbor(n), mflag);</div>
<div class="line">    acquireNode(*rightNeighbor(n), mflag);</div>
<div class="line">  }</div>
</div><!-- fragment --><h2><a class="anchor" id="torus_use"></a>
Use the 2D Torus</h2>
<p>Now we can use our 2D torus as the following. </p><div class="fragment"><div class="line">  <span class="keyword">using</span> Torus = Torus2D&lt;unsigned int&gt;;</div>
<div class="line">  <span class="keyword">using</span> TorusNode = Torus::TorusNode;</div>
<div class="line"> </div>
<div class="line">  Torus torus(std::atoi(argv[1]), std::atoi(argv[2]));</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="namespacekatana.html#ab9ea3b9de54b0c2f223eb585f4aefaff">katana::do_all</a>(</div>
<div class="line">      <a class="code" href="namespacekatana.html#a664a7f49a65e22807577f6cc809a7827">katana::iterate</a>(</div>
<div class="line">          <span class="keywordtype">size_t</span>{0},</div>
<div class="line">          torus.size()),  <span class="comment">// range as a pair of unsigned integers</span></div>
<div class="line">      [&amp;](TorusNode n) { torus.getData(n) = 0; }  <span class="comment">// operator</span></div>
<div class="line">      ,</div>
<div class="line">      <a class="code" href="structkatana_1_1loopname.html">katana::loopname</a>(<span class="stringliteral">&quot;do_all_torus_reset_self&quot;</span>)  <span class="comment">// options</span></div>
<div class="line">  );</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81">katana::for_each</a>(</div>
<div class="line">      <a class="code" href="namespacekatana.html#a664a7f49a65e22807577f6cc809a7827">katana::iterate</a>(</div>
<div class="line">          torus),  <span class="comment">// range as a container. assuming begin() and end()</span></div>
<div class="line">      [&amp;](TorusNode n, <span class="keyword">auto</span>&amp;) {  <span class="comment">// operator</span></div>
<div class="line">        <span class="comment">// cautious point</span></div>
<div class="line">        torus.acquireAllNeighbors(n);</div>
<div class="line"> </div>
<div class="line">        torus.getData(*torus.upNeighbor(n)) += 1;</div>
<div class="line">        torus.getData(*torus.downNeighbor(n)) += 1;</div>
<div class="line">        torus.getData(*torus.leftNeighbor(n)) += 1;</div>
<div class="line">        torus.getData(*torus.rightNeighbor(n)) += 1;</div>
<div class="line">      },</div>
<div class="line">      <a class="code" href="structkatana_1_1loopname.html">katana::loopname</a>(<span class="stringliteral">&quot;for_each_torus_add_neighbors&quot;</span>)  <span class="comment">// options</span></div>
<div class="line">      ,</div>
<div class="line">      <a class="code" href="structkatana_1_1no__pushes.html">katana::no_pushes</a>());</div>
<div class="ttc" id="anamespacekatana_html_a2eb855d38b5753d67def813f9a7edb81"><div class="ttname"><a href="namespacekatana.html#a2eb855d38b5753d67def813f9a7edb81">katana::for_each</a></div><div class="ttdeci">void for_each(const Range &amp;range, FunctionTy &amp;&amp;fn, Args &amp;&amp;... args)</div><div class="ttdoc">Galois unordered set iterator.</div><div class="ttdef"><b>Definition:</b> Loops.h:52</div></div>
<div class="ttc" id="anamespacekatana_html_a664a7f49a65e22807577f6cc809a7827"><div class="ttname"><a href="namespacekatana.html#a664a7f49a65e22807577f6cc809a7827">katana::iterate</a></div><div class="ttdeci">auto iterate(T &amp;container)</div><div class="ttdoc">Iterate returns a specialized range object for various container-like objects:</div><div class="ttdef"><b>Definition:</b> Range.h:296</div></div>
<div class="ttc" id="anamespacekatana_html_ab9ea3b9de54b0c2f223eb585f4aefaff"><div class="ttname"><a href="namespacekatana.html#ab9ea3b9de54b0c2f223eb585f4aefaff">katana::do_all</a></div><div class="ttdeci">void do_all(const Range &amp;range, FunctionTy &amp;&amp;fn, Args &amp;&amp;... args)</div><div class="ttdoc">Standard do-all loop.</div><div class="ttdef"><b>Definition:</b> Loops.h:69</div></div>
<div class="ttc" id="astructkatana_1_1loopname_html"><div class="ttname"><a href="structkatana_1_1loopname.html">katana::loopname</a></div><div class="ttdef"><b>Definition:</b> Traits.h:211</div></div>
<div class="ttc" id="astructkatana_1_1no__pushes_html"><div class="ttname"><a href="structkatana_1_1no__pushes.html">katana::no_pushes</a></div><div class="ttdef"><b>Definition:</b> Traits.h:250</div></div>
</div><!-- fragment --><p> Upon termination, this example app will output statistics similar to the following (generated with a 2000*2000 torus and 24 threads).</p>
<p>STAT_TYPE, REGION, CATEGORY, TOTAL_TYPE, TOTAL<br  />
 STAT, do_all_torus_reset_self, Iterations, TSUM, 4000000<br  />
 STAT, do_all_torus_reset_self, Time, TMAX, 70<br  />
 STAT, for_each_torus_add_neighbors, Iterations, TSUM, 4001481<br  />
 STAT, for_each_torus_add_neighbors, Time, TMAX, 88<br  />
 STAT, for_each_torus_add_neighbors, Commits, TSUM, 4000000<br  />
 STAT, for_each_torus_add_neighbors, Pushes, TSUM, 0<br  />
 STAT, for_each_torus_add_neighbors, Conflicts, TSUM, 1481<br  />
</p>
<p>Note that all conflicts are detected successfully and reported.</p>
<p>Conflict detection can be turned off when not required by passing <a class="el" href="namespacekatana.html#a679ab3b4021187532d65e16ceb3fc246a937e6a98c210e6d3d0af5ed55de70d3b">katana::MethodFlag::UNPROTECTED</a> to getData(), as shown below in the serial loop for verification. </p><div class="fragment"></div><!-- fragment --><p> The full example is available at <a class="el" href="lonestar_2tutorial_examples_2ConflictAwareTorus_8cpp-example.html">lonestar/tutorial_examples/ConflictAwareTorus.cpp</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="Manual.html">Manual</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
